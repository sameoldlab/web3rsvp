/// <reference types="node" />
import type * as fs from 'fs';
import type { sync as mkdirp } from 'mkdirp';
import type * as prettier from 'prettier';
import type { MarkOptional } from 'ts-essentials';
import type { RawAbiDefinition } from '../parser/abiParser';
export interface Config {
    cwd: string;
    target: string;
    outDir?: string | undefined;
    prettier?: object | undefined;
    filesToProcess: string[];
    allFiles: string[];
    /**
     * Optional path to directory with ABI files.
     * If not specified, inferred to be lowest common path of all input files.
     */
    inputDir: string;
    flags: CodegenConfig;
}
export interface CodegenConfig {
    alwaysGenerateOverloads: boolean;
    discriminateTypes: boolean;
    tsNocheck?: boolean;
    environment: 'hardhat' | undefined;
}
export declare type PublicConfig = MarkOptional<Config, 'flags' | 'inputDir'>;
export declare type ExtractAbiFunction = (rawJson: string) => RawAbiDefinition[];
export declare type FindChainTarget = {
    new (...args: any[]): TypeChainTarget;
    extractAbi?: ExtractAbiFunction;
};
export declare abstract class TypeChainTarget {
    readonly cfg: Config;
    abstract readonly name: string;
    constructor(cfg: Config);
    beforeRun(): Output | Promise<Output>;
    afterRun(): Output | Promise<Output>;
    abstract transformFile(file: FileDescription): Output | Promise<Output>;
}
export declare type Output = void | FileDescription | FileDescription[];
export interface FileDescription {
    path: string;
    contents: string;
}
export interface Services {
    fs: typeof fs;
    prettier: typeof prettier;
    mkdirp: typeof mkdirp;
}
//# sourceMappingURL=types.d.ts.map