import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-S5KM4IGW.js";

// browser-external:buffer
var require_buffer = __commonJS({
  "browser-external:buffer"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_6, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer().Buffer;
        }
      } catch (e2) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i7 = 0; i7 < this.length; i7++) {
          this.words[i7] = 0;
        }
        var j5, w8;
        var off = 0;
        if (endian === "be") {
          for (i7 = number.length - 1, j5 = 0; i7 >= 0; i7 -= 3) {
            w8 = number[i7] | number[i7 - 1] << 8 | number[i7 - 2] << 16;
            this.words[j5] |= w8 << off & 67108863;
            this.words[j5 + 1] = w8 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        } else if (endian === "le") {
          for (i7 = 0, j5 = 0; i7 < number.length; i7 += 3) {
            w8 = number[i7] | number[i7 + 1] << 8 | number[i7 + 2] << 16;
            this.words[j5] |= w8 << off & 67108863;
            this.words[j5 + 1] = w8 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c9 = string.charCodeAt(index);
        if (c9 >= 48 && c9 <= 57) {
          return c9 - 48;
        } else if (c9 >= 65 && c9 <= 70) {
          return c9 - 55;
        } else if (c9 >= 97 && c9 <= 102) {
          return c9 - 87;
        } else {
          assert(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r2 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r2 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r2;
      }
      BN2.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i7 = 0; i7 < this.length; i7++) {
          this.words[i7] = 0;
        }
        var off = 0;
        var j5 = 0;
        var w8;
        if (endian === "be") {
          for (i7 = number.length - 1; i7 >= start; i7 -= 2) {
            w8 = parseHexByte(number, start, i7) << off;
            this.words[j5] |= w8 & 67108863;
            if (off >= 18) {
              off -= 18;
              j5 += 1;
              this.words[j5] |= w8 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i7 = parseLength % 2 === 0 ? start + 1 : start; i7 < number.length; i7 += 2) {
            w8 = parseHexByte(number, start, i7) << off;
            this.words[j5] |= w8 & 67108863;
            if (off >= 18) {
              off -= 18;
              j5 += 1;
              this.words[j5] |= w8 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r2 = 0;
        var b9 = 0;
        var len = Math.min(str.length, end);
        for (var i7 = start; i7 < len; i7++) {
          var c9 = str.charCodeAt(i7) - 48;
          r2 *= mul;
          if (c9 >= 49) {
            b9 = c9 - 49 + 10;
          } else if (c9 >= 17) {
            b9 = c9 - 17 + 10;
          } else {
            b9 = c9;
          }
          assert(c9 >= 0 && b9 < mul, "Invalid character");
          r2 += b9;
        }
        return r2;
      }
      BN2.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i7 = start; i7 < end; i7 += limbLen) {
          word = parseBase(number, i7, i7 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i7, number.length, base);
          for (i7 = 0; i7 < mod; i7++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN2.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i7 = 0; i7 < this.length; i7++) {
          dest.words[i7] = this.words[i7];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN2.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN2.prototype.clone = function clone() {
        var r2 = new BN2(null);
        this.copy(r2);
        return r2;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect2;
        } catch (e2) {
          BN2.prototype.inspect = inspect2;
        }
      } else {
        BN2.prototype.inspect = inspect2;
      }
      function inspect2() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i7 = 0; i7 < this.length; i7++) {
            var w8 = this.words[i7];
            var word = ((w8 << off | carry) & 16777215).toString(16);
            carry = w8 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i7--;
            }
            if (carry !== 0 || i7 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c9 = this.clone();
          c9.negative = 0;
          while (!c9.isZero()) {
            var r2 = c9.modrn(groupBase).toString(base);
            c9 = c9.idivn(groupBase);
            if (!c9.isZero()) {
              out = zeros2[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN2.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN2.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i7 = 0, shift = 0; i7 < this.length; i7++) {
          var word = this.words[i7] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i7 = 0, shift = 0; i7 < this.length; i7++) {
          var word = this.words[i7] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w8) {
          return 32 - Math.clz32(w8);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w8) {
          var t5 = w8;
          var r2 = 0;
          if (t5 >= 4096) {
            r2 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r2 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r2 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r2 += 2;
            t5 >>>= 2;
          }
          return r2 + t5;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w8) {
        if (w8 === 0)
          return 26;
        var t5 = w8;
        var r2 = 0;
        if ((t5 & 8191) === 0) {
          r2 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r2 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r2 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r2 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r2++;
        }
        return r2;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w8 = this.words[this.length - 1];
        var hi = this._countBits(w8);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w8 = new Array(num.bitLength());
        for (var bit = 0; bit < w8.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w8[bit] = num.words[off] >>> wbit & 1;
        }
        return w8;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r2 = 0;
        for (var i7 = 0; i7 < this.length; i7++) {
          var b9 = this._zeroBits(this.words[i7]);
          r2 += b9;
          if (b9 !== 26)
            break;
        }
        return r2;
      };
      BN2.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i7 = 0; i7 < num.length; i7++) {
          this.words[i7] = this.words[i7] | num.words[i7];
        }
        return this._strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b9;
        if (this.length > num.length) {
          b9 = num;
        } else {
          b9 = this;
        }
        for (var i7 = 0; i7 < b9.length; i7++) {
          this.words[i7] = this.words[i7] & num.words[i7];
        }
        this.length = b9.length;
        return this._strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a6;
        var b9;
        if (this.length > num.length) {
          a6 = this;
          b9 = num;
        } else {
          a6 = num;
          b9 = this;
        }
        for (var i7 = 0; i7 < b9.length; i7++) {
          this.words[i7] = a6.words[i7] ^ b9.words[i7];
        }
        if (this !== a6) {
          for (; i7 < a6.length; i7++) {
            this.words[i7] = a6.words[i7];
          }
        }
        this.length = a6.length;
        return this._strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i7 = 0; i7 < bytesNeeded; i7++) {
          this.words[i7] = ~this.words[i7] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i7] = ~this.words[i7] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a6, b9;
        if (this.length > num.length) {
          a6 = this;
          b9 = num;
        } else {
          a6 = num;
          b9 = this;
        }
        var carry = 0;
        for (var i7 = 0; i7 < b9.length; i7++) {
          r2 = (a6.words[i7] | 0) + (b9.words[i7] | 0) + carry;
          this.words[i7] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i7 < a6.length; i7++) {
          r2 = (a6.words[i7] | 0) + carry;
          this.words[i7] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a6.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a6 !== this) {
          for (; i7 < a6.length; i7++) {
            this.words[i7] = a6.words[i7];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a6, b9;
        if (cmp > 0) {
          a6 = this;
          b9 = num;
        } else {
          a6 = num;
          b9 = this;
        }
        var carry = 0;
        for (var i7 = 0; i7 < b9.length; i7++) {
          r2 = (a6.words[i7] | 0) - (b9.words[i7] | 0) + carry;
          carry = r2 >> 26;
          this.words[i7] = r2 & 67108863;
        }
        for (; carry !== 0 && i7 < a6.length; i7++) {
          r2 = (a6.words[i7] | 0) + carry;
          carry = r2 >> 26;
          this.words[i7] = r2 & 67108863;
        }
        if (carry === 0 && i7 < a6.length && a6 !== this) {
          for (; i7 < a6.length; i7++) {
            this.words[i7] = a6.words[i7];
          }
        }
        this.length = Math.max(this.length, i7);
        if (a6 !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a6 = self2.words[0] | 0;
        var b9 = num.words[0] | 0;
        var r2 = a6 * b9;
        var lo = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i7 = k5 - j5 | 0;
            a6 = self2.words[i7] | 0;
            b9 = num.words[j5] | 0;
            r2 = a6 * b9 + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a6 = self2.words;
        var b9 = num.words;
        var o4 = out.words;
        var c9 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a6[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a6[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a6[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a6[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a6[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a6[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a62 = a6[6] | 0;
        var al6 = a62 & 8191;
        var ah6 = a62 >>> 13;
        var a7 = a6[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a6[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a6[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b9[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b9[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b9[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b9[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b9[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b52 = b9[5] | 0;
        var bl5 = b52 & 8191;
        var bh5 = b52 >>> 13;
        var b62 = b9[6] | 0;
        var bl6 = b62 & 8191;
        var bh6 = b62 >>> 13;
        var b72 = b9[7] | 0;
        var bl7 = b72 & 8191;
        var bh7 = b72 >>> 13;
        var b82 = b9[8] | 0;
        var bl8 = b82 & 8191;
        var bh8 = b82 >>> 13;
        var b92 = b9[9] | 0;
        var bl9 = b92 & 8191;
        var bh9 = b92 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w62 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w62 >>> 26) | 0;
        w62 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w72 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w72 >>> 26) | 0;
        w72 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o4[0] = w0;
        o4[1] = w1;
        o4[2] = w22;
        o4[3] = w32;
        o4[4] = w42;
        o4[5] = w52;
        o4[6] = w62;
        o4[7] = w72;
        o4[8] = w8;
        o4[9] = w9;
        o4[10] = w10;
        o4[11] = w11;
        o4[12] = w12;
        o4[13] = w13;
        o4[14] = w14;
        o4[15] = w15;
        o4[16] = w16;
        o4[17] = w17;
        o4[18] = w18;
        if (c9 !== 0) {
          o4[19] = c9;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i7 = k5 - j5;
            var a6 = self2.words[i7] | 0;
            var b9 = num.words[j5] | 0;
            var r2 = a6 * b9;
            var lo = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x6, y4) {
        this.x = x6;
        this.y = y4;
      }
      FFTM.prototype.makeRBT = function makeRBT(N8) {
        var t5 = new Array(N8);
        var l7 = BN2.prototype._countBits(N8) - 1;
        for (var i7 = 0; i7 < N8; i7++) {
          t5[i7] = this.revBin(i7, l7, N8);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x6, l7, N8) {
        if (x6 === 0 || x6 === N8 - 1)
          return x6;
        var rb = 0;
        for (var i7 = 0; i7 < l7; i7++) {
          rb |= (x6 & 1) << l7 - i7 - 1;
          x6 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N8) {
        for (var i7 = 0; i7 < N8; i7++) {
          rtws[i7] = rws[rbt[i7]];
          itws[i7] = iws[rbt[i7]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N8, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N8);
        for (var s4 = 1; s4 < N8; s4 <<= 1) {
          var l7 = s4 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l7);
          var itwdf = Math.sin(2 * Math.PI / l7);
          for (var p6 = 0; p6 < N8; p6 += l7) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j5 = 0; j5 < s4; j5++) {
              var re4 = rtws[p6 + j5];
              var ie4 = itws[p6 + j5];
              var ro = rtws[p6 + j5 + s4];
              var io = itws[p6 + j5 + s4];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p6 + j5] = re4 + ro;
              itws[p6 + j5] = ie4 + io;
              rtws[p6 + j5 + s4] = re4 - ro;
              itws[p6 + j5 + s4] = ie4 - io;
              if (j5 !== l7) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m4) {
        var N8 = Math.max(m4, n3) | 1;
        var odd = N8 & 1;
        var i7 = 0;
        for (N8 = N8 / 2 | 0; N8; N8 = N8 >>> 1) {
          i7++;
        }
        return 1 << i7 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N8) {
        if (N8 <= 1)
          return;
        for (var i7 = 0; i7 < N8 / 2; i7++) {
          var t5 = rws[i7];
          rws[i7] = rws[N8 - i7 - 1];
          rws[N8 - i7 - 1] = t5;
          t5 = iws[i7];
          iws[i7] = -iws[N8 - i7 - 1];
          iws[N8 - i7 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N8) {
        var carry = 0;
        for (var i7 = 0; i7 < N8 / 2; i7++) {
          var w8 = Math.round(ws[2 * i7 + 1] / N8) * 8192 + Math.round(ws[2 * i7] / N8) + carry;
          ws[i7] = w8 & 67108863;
          if (w8 < 67108864) {
            carry = 0;
          } else {
            carry = w8 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N8) {
        var carry = 0;
        for (var i7 = 0; i7 < len; i7++) {
          carry = carry + (ws[i7] | 0);
          rws[2 * i7] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i7 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i7 = 2 * len; i7 < N8; ++i7) {
          rws[i7] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N8) {
        var ph = new Array(N8);
        for (var i7 = 0; i7 < N8; i7++) {
          ph[i7] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x6, y4, out) {
        var N8 = 2 * this.guessLen13b(x6.length, y4.length);
        var rbt = this.makeRBT(N8);
        var _6 = this.stub(N8);
        var rws = new Array(N8);
        var rwst = new Array(N8);
        var iwst = new Array(N8);
        var nrws = new Array(N8);
        var nrwst = new Array(N8);
        var niwst = new Array(N8);
        var rmws = out.words;
        rmws.length = N8;
        this.convert13b(x6.words, x6.length, rws, N8);
        this.convert13b(y4.words, y4.length, nrws, N8);
        this.transform(rws, _6, rwst, iwst, N8, rbt);
        this.transform(nrws, _6, nrwst, niwst, N8, rbt);
        for (var i7 = 0; i7 < N8; i7++) {
          var rx = rwst[i7] * nrwst[i7] - iwst[i7] * niwst[i7];
          iwst[i7] = rwst[i7] * niwst[i7] + iwst[i7] * nrwst[i7];
          rwst[i7] = rx;
        }
        this.conjugate(rwst, iwst, N8);
        this.transform(rwst, iwst, rmws, _6, N8, rbt);
        this.conjugate(rmws, _6, N8);
        this.normalize13b(rmws, N8);
        out.negative = x6.negative ^ y4.negative;
        out.length = x6.length + y4.length;
        return out._strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i7 = 0; i7 < this.length; i7++) {
          var w8 = (this.words[i7] | 0) * num;
          var lo = (w8 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w8 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i7] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i7] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w8 = toBitArray(num);
        if (w8.length === 0)
          return new BN2(1);
        var res = this;
        for (var i7 = 0; i7 < w8.length; i7++, res = res.sqr()) {
          if (w8[i7] !== 0)
            break;
        }
        if (++i7 < w8.length) {
          for (var q5 = res.sqr(); i7 < w8.length; i7++, q5 = q5.sqr()) {
            if (w8[i7] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s4 = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i7;
        if (r2 !== 0) {
          var carry = 0;
          for (i7 = 0; i7 < this.length; i7++) {
            var newCarry = this.words[i7] & carryMask;
            var c9 = (this.words[i7] | 0) - newCarry << r2;
            this.words[i7] = c9 | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i7] = carry;
            this.length++;
          }
        }
        if (s4 !== 0) {
          for (i7 = this.length - 1; i7 >= 0; i7--) {
            this.words[i7 + s4] = this.words[i7];
          }
          for (i7 = 0; i7 < s4; i7++) {
            this.words[i7] = 0;
          }
          this.length += s4;
        }
        return this._strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r2 = bits % 26;
        var s4 = Math.min((bits - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h5 -= s4;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i7 = 0; i7 < s4; i7++) {
            maskedWords.words[i7] = this.words[i7];
          }
          maskedWords.length = s4;
        }
        if (s4 === 0) {
        } else if (this.length > s4) {
          this.length -= s4;
          for (i7 = 0; i7 < this.length; i7++) {
            this.words[i7] = this.words[i7 + s4];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i7 = this.length - 1; i7 >= 0 && (carry !== 0 || i7 >= h5); i7--) {
          var word = this.words[i7] | 0;
          this.words[i7] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s4 = (bit - r2) / 26;
        var q5 = 1 << r2;
        if (this.length <= s4)
          return false;
        var w8 = this.words[s4];
        return !!(w8 & q5);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s4 = (bits - r2) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s4) {
          return this;
        }
        if (r2 !== 0) {
          s4++;
        }
        this.length = Math.min(s4, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i7 = 0; i7 < this.length && this.words[i7] >= 67108864; i7++) {
          this.words[i7] -= 67108864;
          if (i7 === this.length - 1) {
            this.words[i7 + 1] = 1;
          } else {
            this.words[i7 + 1]++;
          }
        }
        this.length = Math.max(this.length, i7 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i7 = 0; i7 < this.length && this.words[i7] < 0; i7++) {
            this.words[i7] += 67108864;
            this.words[i7 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i7;
        this._expand(len);
        var w8;
        var carry = 0;
        for (i7 = 0; i7 < num.length; i7++) {
          w8 = (this.words[i7 + shift] | 0) + carry;
          var right = (num.words[i7] | 0) * mul;
          w8 -= right & 67108863;
          carry = (w8 >> 26) - (right / 67108864 | 0);
          this.words[i7 + shift] = w8 & 67108863;
        }
        for (; i7 < this.length - shift; i7++) {
          w8 = (this.words[i7 + shift] | 0) + carry;
          carry = w8 >> 26;
          this.words[i7 + shift] = w8 & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert(carry === -1);
        carry = 0;
        for (i7 = 0; i7 < this.length; i7++) {
          w8 = -(this.words[i7] | 0) + carry;
          carry = w8 >> 26;
          this.words[i7] = w8 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a6 = this.clone();
        var b9 = num;
        var bhi = b9.words[b9.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b9 = b9.ushln(shift);
          a6.iushln(shift);
          bhi = b9.words[b9.length - 1] | 0;
        }
        var m4 = a6.length - b9.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN2(null);
          q5.length = m4 + 1;
          q5.words = new Array(q5.length);
          for (var i7 = 0; i7 < q5.length; i7++) {
            q5.words[i7] = 0;
          }
        }
        var diff = a6.clone()._ishlnsubmul(b9, 1, m4);
        if (diff.negative === 0) {
          a6 = diff;
          if (q5) {
            q5.words[m4] = 1;
          }
        }
        for (var j5 = m4 - 1; j5 >= 0; j5--) {
          var qj = (a6.words[b9.length + j5] | 0) * 67108864 + (a6.words[b9.length + j5 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a6._ishlnsubmul(b9, qj, j5);
          while (a6.negative !== 0) {
            qj--;
            a6.negative = 0;
            a6._ishlnsubmul(b9, 1, j5);
            if (!a6.isZero()) {
              a6.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j5] = qj;
          }
        }
        if (q5) {
          q5._strip();
        }
        a6._strip();
        if (mode !== "div" && shift !== 0) {
          a6.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a6
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var p6 = (1 << 26) % num;
        var acc = 0;
        for (var i7 = this.length - 1; i7 >= 0; i7--) {
          acc = (p6 * acc + (this.words[i7] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN2.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN2.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var carry = 0;
        for (var i7 = this.length - 1; i7 >= 0; i7--) {
          var w8 = (this.words[i7] | 0) + carry * 67108864;
          this.words[i7] = w8 / num | 0;
          carry = w8 % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p6) {
        assert(p6.negative === 0);
        assert(!p6.isZero());
        var x6 = this;
        var y4 = p6.clone();
        if (x6.negative !== 0) {
          x6 = x6.umod(p6);
        } else {
          x6 = x6.clone();
        }
        var A6 = new BN2(1);
        var B7 = new BN2(0);
        var C6 = new BN2(0);
        var D7 = new BN2(1);
        var g4 = 0;
        while (x6.isEven() && y4.isEven()) {
          x6.iushrn(1);
          y4.iushrn(1);
          ++g4;
        }
        var yp = y4.clone();
        var xp = x6.clone();
        while (!x6.isZero()) {
          for (var i7 = 0, im = 1; (x6.words[0] & im) === 0 && i7 < 26; ++i7, im <<= 1)
            ;
          if (i7 > 0) {
            x6.iushrn(i7);
            while (i7-- > 0) {
              if (A6.isOdd() || B7.isOdd()) {
                A6.iadd(yp);
                B7.isub(xp);
              }
              A6.iushrn(1);
              B7.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (y4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            y4.iushrn(j5);
            while (j5-- > 0) {
              if (C6.isOdd() || D7.isOdd()) {
                C6.iadd(yp);
                D7.isub(xp);
              }
              C6.iushrn(1);
              D7.iushrn(1);
            }
          }
          if (x6.cmp(y4) >= 0) {
            x6.isub(y4);
            A6.isub(C6);
            B7.isub(D7);
          } else {
            y4.isub(x6);
            C6.isub(A6);
            D7.isub(B7);
          }
        }
        return {
          a: C6,
          b: D7,
          gcd: y4.iushln(g4)
        };
      };
      BN2.prototype._invmp = function _invmp(p6) {
        assert(p6.negative === 0);
        assert(!p6.isZero());
        var a6 = this;
        var b9 = p6.clone();
        if (a6.negative !== 0) {
          a6 = a6.umod(p6);
        } else {
          a6 = a6.clone();
        }
        var x1 = new BN2(1);
        var x22 = new BN2(0);
        var delta = b9.clone();
        while (a6.cmpn(1) > 0 && b9.cmpn(1) > 0) {
          for (var i7 = 0, im = 1; (a6.words[0] & im) === 0 && i7 < 26; ++i7, im <<= 1)
            ;
          if (i7 > 0) {
            a6.iushrn(i7);
            while (i7-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (b9.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            b9.iushrn(j5);
            while (j5-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a6.cmp(b9) >= 0) {
            a6.isub(b9);
            x1.isub(x22);
          } else {
            b9.isub(a6);
            x22.isub(x1);
          }
        }
        var res;
        if (a6.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p6);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a6 = this.clone();
        var b9 = num.clone();
        a6.negative = 0;
        b9.negative = 0;
        for (var shift = 0; a6.isEven() && b9.isEven(); shift++) {
          a6.iushrn(1);
          b9.iushrn(1);
        }
        do {
          while (a6.isEven()) {
            a6.iushrn(1);
          }
          while (b9.isEven()) {
            b9.iushrn(1);
          }
          var r2 = a6.cmp(b9);
          if (r2 < 0) {
            var t5 = a6;
            a6 = b9;
            b9 = t5;
          } else if (r2 === 0 || b9.cmpn(1) === 0) {
            break;
          }
          a6.isub(b9);
        } while (true);
        return b9.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r2 = bit % 26;
        var s4 = (bit - r2) / 26;
        var q5 = 1 << r2;
        if (this.length <= s4) {
          this._expand(s4 + 1);
          this.words[s4] |= q5;
          return this;
        }
        var carry = q5;
        for (var i7 = s4; carry !== 0 && i7 < this.length; i7++) {
          var w8 = this.words[i7] | 0;
          w8 += carry;
          carry = w8 >>> 26;
          w8 &= 67108863;
          this.words[i7] = w8;
        }
        if (carry !== 0) {
          this.words[i7] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w8 = this.words[0] | 0;
          res = w8 === num ? 0 : w8 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i7 = this.length - 1; i7 >= 0; i7--) {
          var a6 = this.words[i7] | 0;
          var b9 = num.words[i7] | 0;
          if (a6 === b9)
            continue;
          if (a6 < b9) {
            res = -1;
          } else if (a6 > b9) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt2(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt2(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p6) {
        this.name = name;
        this.p = new BN2(p6, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          if (r2.strip !== void 0) {
            r2.strip();
          } else {
            r2._strip();
          }
        }
        return r2;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i7 = 0; i7 < outLen; i7++) {
          output.words[i7] = input.words[i7];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i7 = 10; i7 < input.length; i7++) {
          var next = input.words[i7] | 0;
          input.words[i7 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i7 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i7 = 0; i7 < num.length; i7++) {
          var w8 = num.words[i7] | 0;
          lo += w8 * 977;
          num.words[i7] = lo & 67108863;
          lo = w8 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i7 = 0; i7 < num.length; i7++) {
          var hi = (num.words[i7] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i7] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m4) {
        if (typeof m4 === "string") {
          var prime = BN2._prime(m4);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m4.gtn(1), "modulus must be greater than 1");
          this.m = m4;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a6) {
        assert(a6.negative === 0, "red works only with positives");
        assert(a6.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a6, b9) {
        assert((a6.negative | b9.negative) === 0, "red works only with positives");
        assert(
          a6.red && a6.red === b9.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a6) {
        if (this.prime)
          return this.prime.ireduce(a6)._forceRed(this);
        move(a6, a6.umod(this.m)._forceRed(this));
        return a6;
      };
      Red.prototype.neg = function neg(a6) {
        if (a6.isZero()) {
          return a6.clone();
        }
        return this.m.sub(a6)._forceRed(this);
      };
      Red.prototype.add = function add(a6, b9) {
        this._verify2(a6, b9);
        var res = a6.add(b9);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a6, b9) {
        this._verify2(a6, b9);
        var res = a6.iadd(b9);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a6, b9) {
        this._verify2(a6, b9);
        var res = a6.sub(b9);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a6, b9) {
        this._verify2(a6, b9);
        var res = a6.isub(b9);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a6, num) {
        this._verify1(a6);
        return this.imod(a6.ushln(num));
      };
      Red.prototype.imul = function imul(a6, b9) {
        this._verify2(a6, b9);
        return this.imod(a6.imul(b9));
      };
      Red.prototype.mul = function mul(a6, b9) {
        this._verify2(a6, b9);
        return this.imod(a6.mul(b9));
      };
      Red.prototype.isqr = function isqr(a6) {
        return this.imul(a6, a6.clone());
      };
      Red.prototype.sqr = function sqr(a6) {
        return this.mul(a6, a6);
      };
      Red.prototype.sqrt = function sqrt(a6) {
        if (a6.isZero())
          return a6.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a6, pow);
        }
        var q5 = this.m.subn(1);
        var s4 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s4++;
          q5.iushrn(1);
        }
        assert(!q5.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z4 = this.m.bitLength();
        z4 = new BN2(2 * z4 * z4).toRed(this);
        while (this.pow(z4, lpow).cmp(nOne) !== 0) {
          z4.redIAdd(nOne);
        }
        var c9 = this.pow(z4, q5);
        var r2 = this.pow(a6, q5.addn(1).iushrn(1));
        var t5 = this.pow(a6, q5);
        var m4 = s4;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i7 = 0; tmp.cmp(one) !== 0; i7++) {
            tmp = tmp.redSqr();
          }
          assert(i7 < m4);
          var b9 = this.pow(c9, new BN2(1).iushln(m4 - i7 - 1));
          r2 = r2.redMul(b9);
          c9 = b9.redSqr();
          t5 = t5.redMul(c9);
          m4 = i7;
        }
        return r2;
      };
      Red.prototype.invm = function invm(a6) {
        var inv = a6._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a6, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a6.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a6;
        for (var i7 = 2; i7 < wnd.length; i7++) {
          wnd[i7] = this.mul(wnd[i7 - 1], a6);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i7 = num.length - 1; i7 >= 0; i7--) {
          var word = num.words[i7];
          for (var j5 = start - 1; j5 >= 0; j5--) {
            var bit = word >> j5 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i7 !== 0 || j5 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m4) {
        Red.call(this, m4);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      };
      Mont.prototype.imul = function imul(a6, b9) {
        if (a6.isZero() || b9.isZero()) {
          a6.words[0] = 0;
          a6.length = 1;
          return a6;
        }
        var t5 = a6.imul(b9);
        var c9 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u4 = t5.isub(c9).iushrn(this.shift);
        var res = u4;
        if (u4.cmp(this.m) >= 0) {
          res = u4.isub(this.m);
        } else if (u4.cmpn(0) < 0) {
          res = u4.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a6, b9) {
        if (a6.isZero() || b9.isZero())
          return new BN2(0)._forceRed(this);
        var t5 = a6.mul(b9);
        var c9 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u4 = t5.isub(c9).iushrn(this.shift);
        var res = u4;
        if (u4.cmp(this.m) >= 0) {
          res = u4.isub(this.m);
        } else if (u4.cmpn(0) < 0) {
          res = u4.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a6) {
        var res = this.imod(a6._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/minimalistic-assert/index.js"(exports, module) {
    module.exports = assert;
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert.equal = function assertEqual(l7, r2, msg) {
      if (l7 != r2)
        throw new Error(msg || "Assertion failed: " + l7 + " != " + r2);
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils = __commonJS({
  "node_modules/hash.js/lib/hash/utils.js"(exports) {
    "use strict";
    var assert = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    exports.inherits = inherits;
    function isSurrogatePair(msg, i7) {
      if ((msg.charCodeAt(i7) & 64512) !== 55296) {
        return false;
      }
      if (i7 < 0 || i7 + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i7 + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p6 = 0;
          for (var i7 = 0; i7 < msg.length; i7++) {
            var c9 = msg.charCodeAt(i7);
            if (c9 < 128) {
              res[p6++] = c9;
            } else if (c9 < 2048) {
              res[p6++] = c9 >> 6 | 192;
              res[p6++] = c9 & 63 | 128;
            } else if (isSurrogatePair(msg, i7)) {
              c9 = 65536 + ((c9 & 1023) << 10) + (msg.charCodeAt(++i7) & 1023);
              res[p6++] = c9 >> 18 | 240;
              res[p6++] = c9 >> 12 & 63 | 128;
              res[p6++] = c9 >> 6 & 63 | 128;
              res[p6++] = c9 & 63 | 128;
            } else {
              res[p6++] = c9 >> 12 | 224;
              res[p6++] = c9 >> 6 & 63 | 128;
              res[p6++] = c9 & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i7 = 0; i7 < msg.length; i7 += 2)
            res.push(parseInt(msg[i7] + msg[i7 + 1], 16));
        }
      } else {
        for (i7 = 0; i7 < msg.length; i7++)
          res[i7] = msg[i7] | 0;
      }
      return res;
    }
    exports.toArray = toArray;
    function toHex2(msg) {
      var res = "";
      for (var i7 = 0; i7 < msg.length; i7++)
        res += zero2(msg[i7].toString(16));
      return res;
    }
    exports.toHex = toHex2;
    function htonl(w8) {
      var res = w8 >>> 24 | w8 >>> 8 & 65280 | w8 << 8 & 16711680 | (w8 & 255) << 24;
      return res >>> 0;
    }
    exports.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i7 = 0; i7 < msg.length; i7++) {
        var w8 = msg[i7];
        if (endian === "little")
          w8 = htonl(w8);
        res += zero8(w8.toString(16));
      }
      return res;
    }
    exports.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i7 = 0, k5 = start; i7 < res.length; i7++, k5 += 4) {
        var w8;
        if (endian === "big")
          w8 = msg[k5] << 24 | msg[k5 + 1] << 16 | msg[k5 + 2] << 8 | msg[k5 + 3];
        else
          w8 = msg[k5 + 3] << 24 | msg[k5 + 2] << 16 | msg[k5 + 1] << 8 | msg[k5];
        res[i7] = w8 >>> 0;
      }
      return res;
    }
    exports.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i7 = 0, k5 = 0; i7 < msg.length; i7++, k5 += 4) {
        var m4 = msg[i7];
        if (endian === "big") {
          res[k5] = m4 >>> 24;
          res[k5 + 1] = m4 >>> 16 & 255;
          res[k5 + 2] = m4 >>> 8 & 255;
          res[k5 + 3] = m4 & 255;
        } else {
          res[k5 + 3] = m4 >>> 24;
          res[k5 + 2] = m4 >>> 16 & 255;
          res[k5 + 1] = m4 >>> 8 & 255;
          res[k5] = m4 & 255;
        }
      }
      return res;
    }
    exports.split32 = split32;
    function rotr32(w8, b9) {
      return w8 >>> b9 | w8 << 32 - b9;
    }
    exports.rotr32 = rotr32;
    function rotl32(w8, b9) {
      return w8 << b9 | w8 >>> 32 - b9;
    }
    exports.rotl32 = rotl32;
    function sum32(a6, b9) {
      return a6 + b9 >>> 0;
    }
    exports.sum32 = sum32;
    function sum32_3(a6, b9, c9) {
      return a6 + b9 + c9 >>> 0;
    }
    exports.sum32_3 = sum32_3;
    function sum32_4(a6, b9, c9, d3) {
      return a6 + b9 + c9 + d3 >>> 0;
    }
    exports.sum32_4 = sum32_4;
    function sum32_5(a6, b9, c9, d3, e2) {
      return a6 + b9 + c9 + d3 + e2 >>> 0;
    }
    exports.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
      var bh = buf[pos];
      var bl = buf[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf[pos] = hi >>> 0;
      buf[pos + 1] = lo;
    }
    exports.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r2 = al << 32 - num | ah >>> num;
      return r2 >>> 0;
    }
    exports.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r2 = ah << 32 - num | al >>> num;
      return r2 >>> 0;
    }
    exports.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r2 = ah << 32 - num | al >>> num;
      return r2 >>> 0;
    }
    exports.shr64_lo = shr64_lo;
  }
});

// node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "node_modules/hash.js/lib/hash/common.js"(exports) {
    "use strict";
    var utils = require_utils();
    var assert = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports.BlockHash = BlockHash;
    BlockHash.prototype.update = function update(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r2 = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r2, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r2, this.endian);
        for (var i7 = 0; i7 < msg.length; i7 += this._delta32)
          this._update(msg, i7, i7 + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest(enc) {
      this.update(this._pad());
      assert(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k5 = bytes - (len + this.padLength) % bytes;
      var res = new Array(k5 + this.padLength);
      res[0] = 128;
      for (var i7 = 1; i7 < k5; i7++)
        res[i7] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t5 = 8; t5 < this.padLength; t5++)
          res[i7++] = 0;
        res[i7++] = 0;
        res[i7++] = 0;
        res[i7++] = 0;
        res[i7++] = 0;
        res[i7++] = len >>> 24 & 255;
        res[i7++] = len >>> 16 & 255;
        res[i7++] = len >>> 8 & 255;
        res[i7++] = len & 255;
      } else {
        res[i7++] = len & 255;
        res[i7++] = len >>> 8 & 255;
        res[i7++] = len >>> 16 & 255;
        res[i7++] = len >>> 24 & 255;
        res[i7++] = 0;
        res[i7++] = 0;
        res[i7++] = 0;
        res[i7++] = 0;
        for (t5 = 8; t5 < this.padLength; t5++)
          res[i7++] = 0;
      }
      return res;
    };
  }
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/common.js"(exports) {
    "use strict";
    var utils = require_utils();
    var rotr32 = utils.rotr32;
    function ft_1(s4, x6, y4, z4) {
      if (s4 === 0)
        return ch32(x6, y4, z4);
      if (s4 === 1 || s4 === 3)
        return p32(x6, y4, z4);
      if (s4 === 2)
        return maj32(x6, y4, z4);
    }
    exports.ft_1 = ft_1;
    function ch32(x6, y4, z4) {
      return x6 & y4 ^ ~x6 & z4;
    }
    exports.ch32 = ch32;
    function maj32(x6, y4, z4) {
      return x6 & y4 ^ x6 & z4 ^ y4 & z4;
    }
    exports.maj32 = maj32;
    function p32(x6, y4, z4) {
      return x6 ^ y4 ^ z4;
    }
    exports.p32 = p32;
    function s0_256(x6) {
      return rotr32(x6, 2) ^ rotr32(x6, 13) ^ rotr32(x6, 22);
    }
    exports.s0_256 = s0_256;
    function s1_256(x6) {
      return rotr32(x6, 6) ^ rotr32(x6, 11) ^ rotr32(x6, 25);
    }
    exports.s1_256 = s1_256;
    function g0_256(x6) {
      return rotr32(x6, 7) ^ rotr32(x6, 18) ^ x6 >>> 3;
    }
    exports.g0_256 = g0_256;
    function g1_256(x6) {
      return rotr32(x6, 17) ^ rotr32(x6, 19) ^ x6 >>> 10;
    }
    exports.g1_256 = g1_256;
  }
});

// node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "node_modules/hash.js/lib/hash/sha/1.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W4 = this.W;
      for (var i7 = 0; i7 < 16; i7++)
        W4[i7] = msg[start + i7];
      for (; i7 < W4.length; i7++)
        W4[i7] = rotl32(W4[i7 - 3] ^ W4[i7 - 8] ^ W4[i7 - 14] ^ W4[i7 - 16], 1);
      var a6 = this.h[0];
      var b9 = this.h[1];
      var c9 = this.h[2];
      var d3 = this.h[3];
      var e2 = this.h[4];
      for (i7 = 0; i7 < W4.length; i7++) {
        var s4 = ~~(i7 / 20);
        var t5 = sum32_5(rotl32(a6, 5), ft_1(s4, b9, c9, d3), e2, W4[i7], sha1_K[s4]);
        e2 = d3;
        d3 = c9;
        c9 = rotl32(b9, 30);
        b9 = a6;
        a6 = t5;
      }
      this.h[0] = sum32(this.h[0], a6);
      this.h[1] = sum32(this.h[1], b9);
      this.h[2] = sum32(this.h[2], c9);
      this.h[3] = sum32(this.h[3], d3);
      this.h[4] = sum32(this.h[4], e2);
    };
    SHA1.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/256.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var common = require_common();
    var shaCommon = require_common2();
    var assert = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA256, BlockHash);
    module.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W4 = this.W;
      for (var i7 = 0; i7 < 16; i7++)
        W4[i7] = msg[start + i7];
      for (; i7 < W4.length; i7++)
        W4[i7] = sum32_4(g1_256(W4[i7 - 2]), W4[i7 - 7], g0_256(W4[i7 - 15]), W4[i7 - 16]);
      var a6 = this.h[0];
      var b9 = this.h[1];
      var c9 = this.h[2];
      var d3 = this.h[3];
      var e2 = this.h[4];
      var f6 = this.h[5];
      var g4 = this.h[6];
      var h5 = this.h[7];
      assert(this.k.length === W4.length);
      for (i7 = 0; i7 < W4.length; i7++) {
        var T1 = sum32_5(h5, s1_256(e2), ch32(e2, f6, g4), this.k[i7], W4[i7]);
        var T22 = sum32(s0_256(a6), maj32(a6, b9, c9));
        h5 = g4;
        g4 = f6;
        f6 = e2;
        e2 = sum32(d3, T1);
        d3 = c9;
        c9 = b9;
        b9 = a6;
        a6 = sum32(T1, T22);
      }
      this.h[0] = sum32(this.h[0], a6);
      this.h[1] = sum32(this.h[1], b9);
      this.h[2] = sum32(this.h[2], c9);
      this.h[3] = sum32(this.h[3], d3);
      this.h[4] = sum32(this.h[4], e2);
      this.h[5] = sum32(this.h[5], f6);
      this.h[6] = sum32(this.h[6], g4);
      this.h[7] = sum32(this.h[7], h5);
    };
    SHA256.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/224.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA224, SHA256);
    module.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/512.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var common = require_common();
    var assert = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W4 = this.W;
      for (var i7 = 0; i7 < 32; i7++)
        W4[i7] = msg[start + i7];
      for (; i7 < W4.length; i7 += 2) {
        var c0_hi = g1_512_hi(W4[i7 - 4], W4[i7 - 3]);
        var c0_lo = g1_512_lo(W4[i7 - 4], W4[i7 - 3]);
        var c1_hi = W4[i7 - 14];
        var c1_lo = W4[i7 - 13];
        var c2_hi = g0_512_hi(W4[i7 - 30], W4[i7 - 29]);
        var c2_lo = g0_512_lo(W4[i7 - 30], W4[i7 - 29]);
        var c3_hi = W4[i7 - 32];
        var c3_lo = W4[i7 - 31];
        W4[i7] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W4[i7 + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W4 = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert(this.k.length === W4.length);
      for (var i7 = 0; i7 < W4.length; i7 += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i7];
        var c3_lo = this.k[i7 + 1];
        var c4_hi = W4[i7];
        var c4_lo = W4[i7 + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r2 = xh & yh ^ ~xh & zh;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r2 = xl & yl ^ ~xl & zl;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r2 = xh & yh ^ xh & zh ^ yh & zh;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r2 = xl & yl ^ xl & zl ^ yl & zl;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
  }
});

// node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/384.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA384, SHA512);
    module.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS({
  "node_modules/hash.js/lib/hash/sha.js"(exports) {
    "use strict";
    exports.sha1 = require__();
    exports.sha224 = require__3();
    exports.sha256 = require__2();
    exports.sha384 = require__5();
    exports.sha512 = require__4();
  }
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/hash.js/lib/hash/ripemd.js"(exports) {
    "use strict";
    var utils = require_utils();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update(msg, start) {
      var A6 = this.h[0];
      var B7 = this.h[1];
      var C6 = this.h[2];
      var D7 = this.h[3];
      var E7 = this.h[4];
      var Ah = A6;
      var Bh = B7;
      var Ch = C6;
      var Dh = D7;
      var Eh = E7;
      for (var j5 = 0; j5 < 80; j5++) {
        var T6 = sum32(
          rotl32(
            sum32_4(A6, f6(j5, B7, C6, D7), msg[r2[j5] + start], K4(j5)),
            s4[j5]
          ),
          E7
        );
        A6 = E7;
        E7 = D7;
        D7 = rotl32(C6, 10);
        C6 = B7;
        B7 = T6;
        T6 = sum32(
          rotl32(
            sum32_4(Ah, f6(79 - j5, Bh, Ch, Dh), msg[rh[j5] + start], Kh(j5)),
            sh[j5]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T6;
      }
      T6 = sum32_3(this.h[1], C6, Dh);
      this.h[1] = sum32_3(this.h[2], D7, Eh);
      this.h[2] = sum32_3(this.h[3], E7, Ah);
      this.h[3] = sum32_3(this.h[4], A6, Bh);
      this.h[4] = sum32_3(this.h[0], B7, Ch);
      this.h[0] = T6;
    };
    RIPEMD160.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f6(j5, x6, y4, z4) {
      if (j5 <= 15)
        return x6 ^ y4 ^ z4;
      else if (j5 <= 31)
        return x6 & y4 | ~x6 & z4;
      else if (j5 <= 47)
        return (x6 | ~y4) ^ z4;
      else if (j5 <= 63)
        return x6 & z4 | y4 & ~z4;
      else
        return x6 ^ (y4 | ~z4);
    }
    function K4(j5) {
      if (j5 <= 15)
        return 0;
      else if (j5 <= 31)
        return 1518500249;
      else if (j5 <= 47)
        return 1859775393;
      else if (j5 <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j5) {
      if (j5 <= 15)
        return 1352829926;
      else if (j5 <= 31)
        return 1548603684;
      else if (j5 <= 47)
        return 1836072691;
      else if (j5 <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r2 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s4 = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS({
  "node_modules/hash.js/lib/hash/hmac.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var assert = require_minimalistic_assert();
    function Hmac(hash2, key, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash2, key, enc);
      this.Hash = hash2;
      this.blockSize = hash2.blockSize / 8;
      this.outSize = hash2.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key, enc));
    }
    module.exports = Hmac;
    Hmac.prototype._init = function init(key) {
      if (key.length > this.blockSize)
        key = new this.Hash().update(key).digest();
      assert(key.length <= this.blockSize);
      for (var i7 = key.length; i7 < this.blockSize; i7++)
        key.push(0);
      for (i7 = 0; i7 < key.length; i7++)
        key[i7] ^= 54;
      this.inner = new this.Hash().update(key);
      for (i7 = 0; i7 < key.length; i7++)
        key[i7] ^= 106;
      this.outer = new this.Hash().update(key);
    };
    Hmac.prototype.update = function update(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// node_modules/hash.js/lib/hash.js
var require_hash = __commonJS({
  "node_modules/hash.js/lib/hash.js"(exports) {
    var hash2 = exports;
    hash2.utils = require_utils();
    hash2.common = require_common();
    hash2.sha = require_sha();
    hash2.ripemd = require_ripemd();
    hash2.hmac = require_hmac();
    hash2.sha1 = hash2.sha.sha1;
    hash2.sha256 = hash2.sha.sha256;
    hash2.sha224 = hash2.sha.sha224;
    hash2.sha384 = hash2.sha.sha384;
    hash2.sha512 = hash2.sha.sha512;
    hash2.ripemd160 = hash2.ripemd.ripemd160;
  }
});

// node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}
var init_devAssert = __esm({
  "node_modules/graphql/jsutils/devAssert.mjs"() {
  }
});

// node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}
var init_isObjectLike = __esm({
  "node_modules/graphql/jsutils/isObjectLike.mjs"() {
  }
});

// node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message != null ? message : "Unexpected invariant triggered."
    );
  }
}
var init_invariant = __esm({
  "node_modules/graphql/jsutils/invariant.mjs"() {
  }
});

// node_modules/graphql/language/location.mjs
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}
var LineRegExp;
var init_location = __esm({
  "node_modules/graphql/language/location.mjs"() {
    init_invariant();
    LineRegExp = /\r\n|[\n\r]/g;
  }
});

// node_modules/graphql/language/printLocation.mjs
function printLocation(location) {
  return printSourceLocation(
    location.source,
    getLocation(location.source, location.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i7 = 0; i7 < locationLine.length; i7 += 80) {
      subLines.push(locationLine.slice(i7, i7 + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_6, line]) => line !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
}
var init_printLocation = __esm({
  "node_modules/graphql/language/printLocation.mjs"() {
    init_location();
  }
});

// node_modules/graphql/error/GraphQLError.mjs
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}
var GraphQLError;
var init_GraphQLError = __esm({
  "node_modules/graphql/error/GraphQLError.mjs"() {
    init_isObjectLike();
    init_location();
    init_printLocation();
    GraphQLError = class extends Error {
      constructor(message, ...rawArgs) {
        var _this$nodes, _nodeLocations$, _ref;
        const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
        super(message);
        this.name = "GraphQLError";
        this.path = path !== null && path !== void 0 ? path : void 0;
        this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
        this.nodes = undefinedIfEmpty(
          Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
        );
        const nodeLocations = undefinedIfEmpty(
          (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
        );
        this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
        this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
        this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
        const originalExtensions = isObjectLike(
          originalError === null || originalError === void 0 ? void 0 : originalError.extensions
        ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
        this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
        Object.defineProperties(this, {
          message: {
            writable: true,
            enumerable: true
          },
          name: {
            enumerable: false
          },
          nodes: {
            enumerable: false
          },
          source: {
            enumerable: false
          },
          positions: {
            enumerable: false
          },
          originalError: {
            enumerable: false
          }
        });
        if (originalError !== null && originalError !== void 0 && originalError.stack) {
          Object.defineProperty(this, "stack", {
            value: originalError.stack,
            writable: true,
            configurable: true
          });
        } else if (Error.captureStackTrace) {
          Error.captureStackTrace(this, GraphQLError);
        } else {
          Object.defineProperty(this, "stack", {
            value: Error().stack,
            writable: true,
            configurable: true
          });
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLError";
      }
      toString() {
        let output = this.message;
        if (this.nodes) {
          for (const node of this.nodes) {
            if (node.loc) {
              output += "\n\n" + printLocation(node.loc);
            }
          }
        } else if (this.source && this.locations) {
          for (const location of this.locations) {
            output += "\n\n" + printSourceLocation(this.source, location);
          }
        }
        return output;
      }
      toJSON() {
        const formattedError = {
          message: this.message
        };
        if (this.locations != null) {
          formattedError.locations = this.locations;
        }
        if (this.path != null) {
          formattedError.path = this.path;
        }
        if (this.extensions != null && Object.keys(this.extensions).length > 0) {
          formattedError.extensions = this.extensions;
        }
        return formattedError;
      }
    };
  }
});

// node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position]
  });
}
var init_syntaxError = __esm({
  "node_modules/graphql/error/syntaxError.mjs"() {
    init_GraphQLError();
  }
});

// node_modules/graphql/language/ast.mjs
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var Location, Token, QueryDocumentKeys, kindValues, OperationTypeNode;
var init_ast = __esm({
  "node_modules/graphql/language/ast.mjs"() {
    Location = class {
      constructor(startToken, endToken, source) {
        this.start = startToken.start;
        this.end = endToken.end;
        this.startToken = startToken;
        this.endToken = endToken;
        this.source = source;
      }
      get [Symbol.toStringTag]() {
        return "Location";
      }
      toJSON() {
        return {
          start: this.start,
          end: this.end
        };
      }
    };
    Token = class {
      constructor(kind, start, end, line, column, value) {
        this.kind = kind;
        this.start = start;
        this.end = end;
        this.line = line;
        this.column = column;
        this.value = value;
        this.prev = null;
        this.next = null;
      }
      get [Symbol.toStringTag]() {
        return "Token";
      }
      toJSON() {
        return {
          kind: this.kind,
          value: this.value,
          line: this.line,
          column: this.column
        };
      }
    };
    QueryDocumentKeys = {
      Name: [],
      Document: ["definitions"],
      OperationDefinition: [
        "name",
        "variableDefinitions",
        "directives",
        "selectionSet"
      ],
      VariableDefinition: ["variable", "type", "defaultValue", "directives"],
      Variable: ["name"],
      SelectionSet: ["selections"],
      Field: ["alias", "name", "arguments", "directives", "selectionSet"],
      Argument: ["name", "value"],
      FragmentSpread: ["name", "directives"],
      InlineFragment: ["typeCondition", "directives", "selectionSet"],
      FragmentDefinition: [
        "name",
        "variableDefinitions",
        "typeCondition",
        "directives",
        "selectionSet"
      ],
      IntValue: [],
      FloatValue: [],
      StringValue: [],
      BooleanValue: [],
      NullValue: [],
      EnumValue: [],
      ListValue: ["values"],
      ObjectValue: ["fields"],
      ObjectField: ["name", "value"],
      Directive: ["name", "arguments"],
      NamedType: ["name"],
      ListType: ["type"],
      NonNullType: ["type"],
      SchemaDefinition: ["description", "directives", "operationTypes"],
      OperationTypeDefinition: ["type"],
      ScalarTypeDefinition: ["description", "name", "directives"],
      ObjectTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      FieldDefinition: ["description", "name", "arguments", "type", "directives"],
      InputValueDefinition: [
        "description",
        "name",
        "type",
        "defaultValue",
        "directives"
      ],
      InterfaceTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      UnionTypeDefinition: ["description", "name", "directives", "types"],
      EnumTypeDefinition: ["description", "name", "directives", "values"],
      EnumValueDefinition: ["description", "name", "directives"],
      InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
      DirectiveDefinition: ["description", "name", "arguments", "locations"],
      SchemaExtension: ["directives", "operationTypes"],
      ScalarTypeExtension: ["name", "directives"],
      ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
      InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
      UnionTypeExtension: ["name", "directives", "types"],
      EnumTypeExtension: ["name", "directives", "values"],
      InputObjectTypeExtension: ["name", "directives", "fields"]
    };
    kindValues = new Set(Object.keys(QueryDocumentKeys));
    (function(OperationTypeNode2) {
      OperationTypeNode2["QUERY"] = "query";
      OperationTypeNode2["MUTATION"] = "mutation";
      OperationTypeNode2["SUBSCRIPTION"] = "subscription";
    })(OperationTypeNode || (OperationTypeNode = {}));
  }
});

// node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
var init_directiveLocation = __esm({
  "node_modules/graphql/language/directiveLocation.mjs"() {
    (function(DirectiveLocation2) {
      DirectiveLocation2["QUERY"] = "QUERY";
      DirectiveLocation2["MUTATION"] = "MUTATION";
      DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
      DirectiveLocation2["FIELD"] = "FIELD";
      DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      DirectiveLocation2["SCHEMA"] = "SCHEMA";
      DirectiveLocation2["SCALAR"] = "SCALAR";
      DirectiveLocation2["OBJECT"] = "OBJECT";
      DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      DirectiveLocation2["INTERFACE"] = "INTERFACE";
      DirectiveLocation2["UNION"] = "UNION";
      DirectiveLocation2["ENUM"] = "ENUM";
      DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
      DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
      DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(DirectiveLocation || (DirectiveLocation = {}));
  }
});

// node_modules/graphql/language/kinds.mjs
var Kind;
var init_kinds = __esm({
  "node_modules/graphql/language/kinds.mjs"() {
    (function(Kind2) {
      Kind2["NAME"] = "Name";
      Kind2["DOCUMENT"] = "Document";
      Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
      Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
      Kind2["SELECTION_SET"] = "SelectionSet";
      Kind2["FIELD"] = "Field";
      Kind2["ARGUMENT"] = "Argument";
      Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
      Kind2["INLINE_FRAGMENT"] = "InlineFragment";
      Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
      Kind2["VARIABLE"] = "Variable";
      Kind2["INT"] = "IntValue";
      Kind2["FLOAT"] = "FloatValue";
      Kind2["STRING"] = "StringValue";
      Kind2["BOOLEAN"] = "BooleanValue";
      Kind2["NULL"] = "NullValue";
      Kind2["ENUM"] = "EnumValue";
      Kind2["LIST"] = "ListValue";
      Kind2["OBJECT"] = "ObjectValue";
      Kind2["OBJECT_FIELD"] = "ObjectField";
      Kind2["DIRECTIVE"] = "Directive";
      Kind2["NAMED_TYPE"] = "NamedType";
      Kind2["LIST_TYPE"] = "ListType";
      Kind2["NON_NULL_TYPE"] = "NonNullType";
      Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
      Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
      Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
      Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
      Kind2["FIELD_DEFINITION"] = "FieldDefinition";
      Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
      Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
      Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
      Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
      Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
      Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
      Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
      Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
      Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
      Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
      Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
      Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
      Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
      Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
    })(Kind || (Kind = {}));
  }
});

// node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}
var init_characterClasses = __esm({
  "node_modules/graphql/language/characterClasses.mjs"() {
  }
});

// node_modules/graphql/language/blockString.mjs
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i7 = 0; i7 < lines.length; ++i7) {
    var _firstNonEmptyLine;
    const line = lines[i7];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i7;
    lastNonEmptyLine = i7;
    if (i7 !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line, i7) => i7 === 0 ? line : line.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace(str) {
  let i7 = 0;
  while (i7 < str.length && isWhiteSpace(str.charCodeAt(i7))) {
    ++i7;
  }
  return i7;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}
var init_blockString = __esm({
  "node_modules/graphql/language/blockString.mjs"() {
    init_characterClasses();
  }
});

// node_modules/graphql/language/tokenKind.mjs
var TokenKind;
var init_tokenKind = __esm({
  "node_modules/graphql/language/tokenKind.mjs"() {
    (function(TokenKind2) {
      TokenKind2["SOF"] = "<SOF>";
      TokenKind2["EOF"] = "<EOF>";
      TokenKind2["BANG"] = "!";
      TokenKind2["DOLLAR"] = "$";
      TokenKind2["AMP"] = "&";
      TokenKind2["PAREN_L"] = "(";
      TokenKind2["PAREN_R"] = ")";
      TokenKind2["SPREAD"] = "...";
      TokenKind2["COLON"] = ":";
      TokenKind2["EQUALS"] = "=";
      TokenKind2["AT"] = "@";
      TokenKind2["BRACKET_L"] = "[";
      TokenKind2["BRACKET_R"] = "]";
      TokenKind2["BRACE_L"] = "{";
      TokenKind2["PIPE"] = "|";
      TokenKind2["BRACE_R"] = "}";
      TokenKind2["NAME"] = "Name";
      TokenKind2["INT"] = "Int";
      TokenKind2["FLOAT"] = "Float";
      TokenKind2["STRING"] = "String";
      TokenKind2["BLOCK_STRING"] = "BlockString";
      TokenKind2["COMMENT"] = "Comment";
    })(TokenKind || (TokenKind = {}));
  }
});

// node_modules/graphql/language/lexer.mjs
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function isUnicodeScalarValue(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
}
function isSupplementaryCodePoint(body, location) {
  return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
}
function isLeadingSurrogate(code) {
  return code >= 55296 && code <= 56319;
}
function isTrailingSurrogate(code) {
  return code >= 56320 && code <= 57343;
}
function printCodePointAt(lexer, location) {
  const code = lexer.source.body.codePointAt(location);
  if (code === void 0) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char = String.fromCodePoint(code);
    return char === '"' ? `'"'` : `"${char}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
}
function createToken(lexer, kind, start, end, value) {
  const line = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token(kind, start, end, line, col, value);
}
function readNextToken(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position;
        continue;
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 35:
        return readComment(lexer, position);
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString(lexer, position);
    }
    if (isDigit(code) || code === 45) {
      return readNumber(lexer, position, code);
    }
    if (isNameStart(code)) {
      return readName(lexer, position);
    }
    throw syntaxError(
      lexer.source,
      position,
      code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
    );
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
}
function readComment(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.COMMENT,
    start,
    position,
    body.slice(start + 1, position)
  );
}
function readNumber(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position = start;
  let code = firstCode;
  let isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (isDigit(code)) {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid number, unexpected digit after 0: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  } else {
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(
      lexer.source,
      position,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        position
      )}.`
    );
  }
  return createToken(
    lexer,
    isFloat ? TokenKind.FLOAT : TokenKind.INT,
    start,
    position,
    body.slice(start, position)
  );
}
function readDigits(lexer, start, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(
      lexer.source,
      start,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        start
      )}.`
    );
  }
  const body = lexer.source.body;
  let position = start + 1;
  while (isDigit(body.charCodeAt(position))) {
    ++position;
  }
  return position;
}
function readString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  let chunkStart = position;
  let value = "";
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start, position + 1, value);
    }
    if (code === 92) {
      value += body.slice(chunkStart, position);
      const escape = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value += escape.value;
      position += escape.size;
      chunkStart = position;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readEscapedUnicodeVariableWidth(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code = body.charCodeAt(position + size++);
    if (code === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(
      position,
      position + size
    )}".`
  );
}
function readEscapedUnicodeFixedWidth(lexer, position) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
  );
}
function read16BitHexCode(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
}
function readHexDigit(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
}
function readEscapedCharacter(lexer, position) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: "\n",
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid character escape sequence: "${body.slice(
      position,
      position + 2
    )}".`
  );
}
function readBlockString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token = createToken(
        lexer,
        TokenKind.BLOCK_STRING,
        start,
        position + 3,
        dedentBlockStringLines(blockLines).join("\n")
      );
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token;
    }
    if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readName(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (isNameContinue(code)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.NAME,
    start,
    position,
    body.slice(start, position)
  );
}
var Lexer;
var init_lexer = __esm({
  "node_modules/graphql/language/lexer.mjs"() {
    init_syntaxError();
    init_ast();
    init_blockString();
    init_characterClasses();
    init_tokenKind();
    Lexer = class {
      constructor(source) {
        const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
        this.source = source;
        this.lastToken = startOfFileToken;
        this.token = startOfFileToken;
        this.line = 1;
        this.lineStart = 0;
      }
      get [Symbol.toStringTag]() {
        return "Lexer";
      }
      advance() {
        this.lastToken = this.token;
        const token = this.token = this.lookahead();
        return token;
      }
      lookahead() {
        let token = this.token;
        if (token.kind !== TokenKind.EOF) {
          do {
            if (token.next) {
              token = token.next;
            } else {
              const nextToken = readNextToken(this, token.end);
              token.next = nextToken;
              nextToken.prev = token;
              token = nextToken;
            }
          } while (token.kind === TokenKind.COMMENT);
        }
        return token;
      }
    };
  }
});

// node_modules/graphql/jsutils/inspect.mjs
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(
    ([key, value]) => key + ": " + formatValue(value, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i7 = 0; i7 < len; ++i7) {
    items.push(formatValue(array[i7], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}
var MAX_ARRAY_LENGTH, MAX_RECURSIVE_DEPTH;
var init_inspect = __esm({
  "node_modules/graphql/jsutils/inspect.mjs"() {
    MAX_ARRAY_LENGTH = 10;
    MAX_RECURSIVE_DEPTH = 2;
  }
});

// node_modules/graphql/jsutils/instanceOf.mjs
var instanceOf;
var init_instanceOf = __esm({
  "node_modules/graphql/jsutils/instanceOf.mjs"() {
    init_inspect();
    instanceOf = false ? function instanceOf2(value, constructor) {
      return value instanceof constructor;
    } : function instanceOf3(value, constructor) {
      if (value instanceof constructor) {
        return true;
      }
      if (typeof value === "object" && value !== null) {
        var _value$constructor;
        const className = constructor.prototype[Symbol.toStringTag];
        const valueClassName = Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name;
        if (className === valueClassName) {
          const stringifiedValue = inspect(value);
          throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
        }
      }
      return false;
    };
  }
});

// node_modules/graphql/language/source.mjs
function isSource(source) {
  return instanceOf(source, Source);
}
var Source;
var init_source = __esm({
  "node_modules/graphql/language/source.mjs"() {
    init_devAssert();
    init_inspect();
    init_instanceOf();
    Source = class {
      constructor(body, name = "GraphQL request", locationOffset = {
        line: 1,
        column: 1
      }) {
        typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
        this.body = body;
        this.name = name;
        this.locationOffset = locationOffset;
        this.locationOffset.line > 0 || devAssert(
          false,
          "line in locationOffset is 1-indexed and must be positive."
        );
        this.locationOffset.column > 0 || devAssert(
          false,
          "column in locationOffset is 1-indexed and must be positive."
        );
      }
      get [Symbol.toStringTag]() {
        return "Source";
      }
    };
  }
});

// node_modules/graphql/language/parser.mjs
var parser_exports = {};
__export(parser_exports, {
  Parser: () => Parser,
  parse: () => parse,
  parseConstValue: () => parseConstValue,
  parseType: () => parseType,
  parseValue: () => parseValue
});
function parse(source, options) {
  const parser = new Parser(source, options);
  return parser.parseDocument();
}
function parseValue(source, options) {
  const parser = new Parser(source, options);
  parser.expectToken(TokenKind.SOF);
  const value = parser.parseValueLiteral(false);
  parser.expectToken(TokenKind.EOF);
  return value;
}
function parseConstValue(source, options) {
  const parser = new Parser(source, options);
  parser.expectToken(TokenKind.SOF);
  const value = parser.parseConstValueLiteral();
  parser.expectToken(TokenKind.EOF);
  return value;
}
function parseType(source, options) {
  const parser = new Parser(source, options);
  parser.expectToken(TokenKind.SOF);
  const type = parser.parseTypeReference();
  parser.expectToken(TokenKind.EOF);
  return type;
}
function getTokenDesc(token) {
  const value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
}
var Parser;
var init_parser = __esm({
  "node_modules/graphql/language/parser.mjs"() {
    init_syntaxError();
    init_ast();
    init_directiveLocation();
    init_kinds();
    init_lexer();
    init_source();
    init_tokenKind();
    Parser = class {
      constructor(source, options = {}) {
        const sourceObj = isSource(source) ? source : new Source(source);
        this._lexer = new Lexer(sourceObj);
        this._options = options;
        this._tokenCounter = 0;
      }
      parseName() {
        const token = this.expectToken(TokenKind.NAME);
        return this.node(token, {
          kind: Kind.NAME,
          value: token.value
        });
      }
      parseDocument() {
        return this.node(this._lexer.token, {
          kind: Kind.DOCUMENT,
          definitions: this.many(
            TokenKind.SOF,
            this.parseDefinition,
            TokenKind.EOF
          )
        });
      }
      parseDefinition() {
        if (this.peek(TokenKind.BRACE_L)) {
          return this.parseOperationDefinition();
        }
        const hasDescription = this.peekDescription();
        const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
        if (keywordToken.kind === TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaDefinition();
            case "scalar":
              return this.parseScalarTypeDefinition();
            case "type":
              return this.parseObjectTypeDefinition();
            case "interface":
              return this.parseInterfaceTypeDefinition();
            case "union":
              return this.parseUnionTypeDefinition();
            case "enum":
              return this.parseEnumTypeDefinition();
            case "input":
              return this.parseInputObjectTypeDefinition();
            case "directive":
              return this.parseDirectiveDefinition();
          }
          if (hasDescription) {
            throw syntaxError(
              this._lexer.source,
              this._lexer.token.start,
              "Unexpected description, descriptions are supported only on type definitions."
            );
          }
          switch (keywordToken.value) {
            case "query":
            case "mutation":
            case "subscription":
              return this.parseOperationDefinition();
            case "fragment":
              return this.parseFragmentDefinition();
            case "extend":
              return this.parseTypeSystemExtension();
          }
        }
        throw this.unexpected(keywordToken);
      }
      parseOperationDefinition() {
        const start = this._lexer.token;
        if (this.peek(TokenKind.BRACE_L)) {
          return this.node(start, {
            kind: Kind.OPERATION_DEFINITION,
            operation: OperationTypeNode.QUERY,
            name: void 0,
            variableDefinitions: [],
            directives: [],
            selectionSet: this.parseSelectionSet()
          });
        }
        const operation = this.parseOperationType();
        let name;
        if (this.peek(TokenKind.NAME)) {
          name = this.parseName();
        }
        return this.node(start, {
          kind: Kind.OPERATION_DEFINITION,
          operation,
          name,
          variableDefinitions: this.parseVariableDefinitions(),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      parseOperationType() {
        const operationToken = this.expectToken(TokenKind.NAME);
        switch (operationToken.value) {
          case "query":
            return OperationTypeNode.QUERY;
          case "mutation":
            return OperationTypeNode.MUTATION;
          case "subscription":
            return OperationTypeNode.SUBSCRIPTION;
        }
        throw this.unexpected(operationToken);
      }
      parseVariableDefinitions() {
        return this.optionalMany(
          TokenKind.PAREN_L,
          this.parseVariableDefinition,
          TokenKind.PAREN_R
        );
      }
      parseVariableDefinition() {
        return this.node(this._lexer.token, {
          kind: Kind.VARIABLE_DEFINITION,
          variable: this.parseVariable(),
          type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
          defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
          directives: this.parseConstDirectives()
        });
      }
      parseVariable() {
        const start = this._lexer.token;
        this.expectToken(TokenKind.DOLLAR);
        return this.node(start, {
          kind: Kind.VARIABLE,
          name: this.parseName()
        });
      }
      parseSelectionSet() {
        return this.node(this._lexer.token, {
          kind: Kind.SELECTION_SET,
          selections: this.many(
            TokenKind.BRACE_L,
            this.parseSelection,
            TokenKind.BRACE_R
          )
        });
      }
      parseSelection() {
        return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
      }
      parseField() {
        const start = this._lexer.token;
        const nameOrAlias = this.parseName();
        let alias;
        let name;
        if (this.expectOptionalToken(TokenKind.COLON)) {
          alias = nameOrAlias;
          name = this.parseName();
        } else {
          name = nameOrAlias;
        }
        return this.node(start, {
          kind: Kind.FIELD,
          alias,
          name,
          arguments: this.parseArguments(false),
          directives: this.parseDirectives(false),
          selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
        });
      }
      parseArguments(isConst) {
        const item = isConst ? this.parseConstArgument : this.parseArgument;
        return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
      }
      parseArgument(isConst = false) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(TokenKind.COLON);
        return this.node(start, {
          kind: Kind.ARGUMENT,
          name,
          value: this.parseValueLiteral(isConst)
        });
      }
      parseConstArgument() {
        return this.parseArgument(true);
      }
      parseFragment() {
        const start = this._lexer.token;
        this.expectToken(TokenKind.SPREAD);
        const hasTypeCondition = this.expectOptionalKeyword("on");
        if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
          return this.node(start, {
            kind: Kind.FRAGMENT_SPREAD,
            name: this.parseFragmentName(),
            directives: this.parseDirectives(false)
          });
        }
        return this.node(start, {
          kind: Kind.INLINE_FRAGMENT,
          typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      parseFragmentDefinition() {
        const start = this._lexer.token;
        this.expectKeyword("fragment");
        if (this._options.allowLegacyFragmentVariables === true) {
          return this.node(start, {
            kind: Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            variableDefinitions: this.parseVariableDefinitions(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        return this.node(start, {
          kind: Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      parseFragmentName() {
        if (this._lexer.token.value === "on") {
          throw this.unexpected();
        }
        return this.parseName();
      }
      parseValueLiteral(isConst) {
        const token = this._lexer.token;
        switch (token.kind) {
          case TokenKind.BRACKET_L:
            return this.parseList(isConst);
          case TokenKind.BRACE_L:
            return this.parseObject(isConst);
          case TokenKind.INT:
            this.advanceLexer();
            return this.node(token, {
              kind: Kind.INT,
              value: token.value
            });
          case TokenKind.FLOAT:
            this.advanceLexer();
            return this.node(token, {
              kind: Kind.FLOAT,
              value: token.value
            });
          case TokenKind.STRING:
          case TokenKind.BLOCK_STRING:
            return this.parseStringLiteral();
          case TokenKind.NAME:
            this.advanceLexer();
            switch (token.value) {
              case "true":
                return this.node(token, {
                  kind: Kind.BOOLEAN,
                  value: true
                });
              case "false":
                return this.node(token, {
                  kind: Kind.BOOLEAN,
                  value: false
                });
              case "null":
                return this.node(token, {
                  kind: Kind.NULL
                });
              default:
                return this.node(token, {
                  kind: Kind.ENUM,
                  value: token.value
                });
            }
          case TokenKind.DOLLAR:
            if (isConst) {
              this.expectToken(TokenKind.DOLLAR);
              if (this._lexer.token.kind === TokenKind.NAME) {
                const varName = this._lexer.token.value;
                throw syntaxError(
                  this._lexer.source,
                  token.start,
                  `Unexpected variable "$${varName}" in constant value.`
                );
              } else {
                throw this.unexpected(token);
              }
            }
            return this.parseVariable();
          default:
            throw this.unexpected();
        }
      }
      parseConstValueLiteral() {
        return this.parseValueLiteral(true);
      }
      parseStringLiteral() {
        const token = this._lexer.token;
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.STRING,
          value: token.value,
          block: token.kind === TokenKind.BLOCK_STRING
        });
      }
      parseList(isConst) {
        const item = () => this.parseValueLiteral(isConst);
        return this.node(this._lexer.token, {
          kind: Kind.LIST,
          values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
        });
      }
      parseObject(isConst) {
        const item = () => this.parseObjectField(isConst);
        return this.node(this._lexer.token, {
          kind: Kind.OBJECT,
          fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
        });
      }
      parseObjectField(isConst) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(TokenKind.COLON);
        return this.node(start, {
          kind: Kind.OBJECT_FIELD,
          name,
          value: this.parseValueLiteral(isConst)
        });
      }
      parseDirectives(isConst) {
        const directives = [];
        while (this.peek(TokenKind.AT)) {
          directives.push(this.parseDirective(isConst));
        }
        return directives;
      }
      parseConstDirectives() {
        return this.parseDirectives(true);
      }
      parseDirective(isConst) {
        const start = this._lexer.token;
        this.expectToken(TokenKind.AT);
        return this.node(start, {
          kind: Kind.DIRECTIVE,
          name: this.parseName(),
          arguments: this.parseArguments(isConst)
        });
      }
      parseTypeReference() {
        const start = this._lexer.token;
        let type;
        if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
          const innerType = this.parseTypeReference();
          this.expectToken(TokenKind.BRACKET_R);
          type = this.node(start, {
            kind: Kind.LIST_TYPE,
            type: innerType
          });
        } else {
          type = this.parseNamedType();
        }
        if (this.expectOptionalToken(TokenKind.BANG)) {
          return this.node(start, {
            kind: Kind.NON_NULL_TYPE,
            type
          });
        }
        return type;
      }
      parseNamedType() {
        return this.node(this._lexer.token, {
          kind: Kind.NAMED_TYPE,
          name: this.parseName()
        });
      }
      peekDescription() {
        return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
      }
      parseDescription() {
        if (this.peekDescription()) {
          return this.parseStringLiteral();
        }
      }
      parseSchemaDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.many(
          TokenKind.BRACE_L,
          this.parseOperationTypeDefinition,
          TokenKind.BRACE_R
        );
        return this.node(start, {
          kind: Kind.SCHEMA_DEFINITION,
          description,
          directives,
          operationTypes
        });
      }
      parseOperationTypeDefinition() {
        const start = this._lexer.token;
        const operation = this.parseOperationType();
        this.expectToken(TokenKind.COLON);
        const type = this.parseNamedType();
        return this.node(start, {
          kind: Kind.OPERATION_TYPE_DEFINITION,
          operation,
          type
        });
      }
      parseScalarTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: Kind.SCALAR_TYPE_DEFINITION,
          description,
          name,
          directives
        });
      }
      parseObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
          kind: Kind.OBJECT_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields
        });
      }
      parseImplementsInterfaces() {
        return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
      }
      parseFieldsDefinition() {
        return this.optionalMany(
          TokenKind.BRACE_L,
          this.parseFieldDefinition,
          TokenKind.BRACE_R
        );
      }
      parseFieldDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        this.expectToken(TokenKind.COLON);
        const type = this.parseTypeReference();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: Kind.FIELD_DEFINITION,
          description,
          name,
          arguments: args,
          type,
          directives
        });
      }
      parseArgumentDefs() {
        return this.optionalMany(
          TokenKind.PAREN_L,
          this.parseInputValueDef,
          TokenKind.PAREN_R
        );
      }
      parseInputValueDef() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        this.expectToken(TokenKind.COLON);
        const type = this.parseTypeReference();
        let defaultValue;
        if (this.expectOptionalToken(TokenKind.EQUALS)) {
          defaultValue = this.parseConstValueLiteral();
        }
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: Kind.INPUT_VALUE_DEFINITION,
          description,
          name,
          type,
          defaultValue,
          directives
        });
      }
      parseInterfaceTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
          kind: Kind.INTERFACE_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields
        });
      }
      parseUnionTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types = this.parseUnionMemberTypes();
        return this.node(start, {
          kind: Kind.UNION_TYPE_DEFINITION,
          description,
          name,
          directives,
          types
        });
      }
      parseUnionMemberTypes() {
        return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
      }
      parseEnumTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        return this.node(start, {
          kind: Kind.ENUM_TYPE_DEFINITION,
          description,
          name,
          directives,
          values
        });
      }
      parseEnumValuesDefinition() {
        return this.optionalMany(
          TokenKind.BRACE_L,
          this.parseEnumValueDefinition,
          TokenKind.BRACE_R
        );
      }
      parseEnumValueDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseEnumValueName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: Kind.ENUM_VALUE_DEFINITION,
          description,
          name,
          directives
        });
      }
      parseEnumValueName() {
        if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
          throw syntaxError(
            this._lexer.source,
            this._lexer.token.start,
            `${getTokenDesc(
              this._lexer.token
            )} is reserved and cannot be used for an enum value.`
          );
        }
        return this.parseName();
      }
      parseInputObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        return this.node(start, {
          kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
          description,
          name,
          directives,
          fields
        });
      }
      parseInputFieldsDefinition() {
        return this.optionalMany(
          TokenKind.BRACE_L,
          this.parseInputValueDef,
          TokenKind.BRACE_R
        );
      }
      parseTypeSystemExtension() {
        const keywordToken = this._lexer.lookahead();
        if (keywordToken.kind === TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaExtension();
            case "scalar":
              return this.parseScalarTypeExtension();
            case "type":
              return this.parseObjectTypeExtension();
            case "interface":
              return this.parseInterfaceTypeExtension();
            case "union":
              return this.parseUnionTypeExtension();
            case "enum":
              return this.parseEnumTypeExtension();
            case "input":
              return this.parseInputObjectTypeExtension();
          }
        }
        throw this.unexpected(keywordToken);
      }
      parseSchemaExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.optionalMany(
          TokenKind.BRACE_L,
          this.parseOperationTypeDefinition,
          TokenKind.BRACE_R
        );
        if (directives.length === 0 && operationTypes.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.SCHEMA_EXTENSION,
          directives,
          operationTypes
        });
      }
      parseScalarTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        if (directives.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.SCALAR_TYPE_EXTENSION,
          name,
          directives
        });
      }
      parseObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.OBJECT_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields
        });
      }
      parseInterfaceTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.INTERFACE_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields
        });
      }
      parseUnionTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types = this.parseUnionMemberTypes();
        if (directives.length === 0 && types.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.UNION_TYPE_EXTENSION,
          name,
          directives,
          types
        });
      }
      parseEnumTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        if (directives.length === 0 && values.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.ENUM_TYPE_EXTENSION,
          name,
          directives,
          values
        });
      }
      parseInputObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        if (directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
          name,
          directives,
          fields
        });
      }
      parseDirectiveDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("directive");
        this.expectToken(TokenKind.AT);
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        const repeatable = this.expectOptionalKeyword("repeatable");
        this.expectKeyword("on");
        const locations = this.parseDirectiveLocations();
        return this.node(start, {
          kind: Kind.DIRECTIVE_DEFINITION,
          description,
          name,
          arguments: args,
          repeatable,
          locations
        });
      }
      parseDirectiveLocations() {
        return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
      }
      parseDirectiveLocation() {
        const start = this._lexer.token;
        const name = this.parseName();
        if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
          return name;
        }
        throw this.unexpected(start);
      }
      node(startToken, node) {
        if (this._options.noLocation !== true) {
          node.loc = new Location(
            startToken,
            this._lexer.lastToken,
            this._lexer.source
          );
        }
        return node;
      }
      peek(kind) {
        return this._lexer.token.kind === kind;
      }
      expectToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
          this.advanceLexer();
          return token;
        }
        throw syntaxError(
          this._lexer.source,
          token.start,
          `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
        );
      }
      expectOptionalToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
          this.advanceLexer();
          return true;
        }
        return false;
      }
      expectKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === TokenKind.NAME && token.value === value) {
          this.advanceLexer();
        } else {
          throw syntaxError(
            this._lexer.source,
            token.start,
            `Expected "${value}", found ${getTokenDesc(token)}.`
          );
        }
      }
      expectOptionalKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === TokenKind.NAME && token.value === value) {
          this.advanceLexer();
          return true;
        }
        return false;
      }
      unexpected(atToken) {
        const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
        return syntaxError(
          this._lexer.source,
          token.start,
          `Unexpected ${getTokenDesc(token)}.`
        );
      }
      any(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        while (!this.expectOptionalToken(closeKind)) {
          nodes.push(parseFn.call(this));
        }
        return nodes;
      }
      optionalMany(openKind, parseFn, closeKind) {
        if (this.expectOptionalToken(openKind)) {
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));
          return nodes;
        }
        return [];
      }
      many(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      }
      delimitedMany(delimiterKind, parseFn) {
        this.expectOptionalToken(delimiterKind);
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (this.expectOptionalToken(delimiterKind));
        return nodes;
      }
      advanceLexer() {
        const { maxTokens } = this._options;
        const token = this._lexer.advance();
        if (maxTokens !== void 0 && token.kind !== TokenKind.EOF) {
          ++this._tokenCounter;
          if (this._tokenCounter > maxTokens) {
            throw syntaxError(
              this._lexer.source,
              token.start,
              `Document contains more that ${maxTokens} tokens. Parsing aborted.`
            );
          }
        }
      }
    };
  }
});

// node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
var escapedRegExp, escapeSequences;
var init_printString = __esm({
  "node_modules/graphql/language/printString.mjs"() {
    escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
    escapeSequences = [
      "\\u0000",
      "\\u0001",
      "\\u0002",
      "\\u0003",
      "\\u0004",
      "\\u0005",
      "\\u0006",
      "\\u0007",
      "\\b",
      "\\t",
      "\\n",
      "\\u000B",
      "\\f",
      "\\r",
      "\\u000E",
      "\\u000F",
      "\\u0010",
      "\\u0011",
      "\\u0012",
      "\\u0013",
      "\\u0014",
      "\\u0015",
      "\\u0016",
      "\\u0017",
      "\\u0018",
      "\\u0019",
      "\\u001A",
      "\\u001B",
      "\\u001C",
      "\\u001D",
      "\\u001E",
      "\\u001F",
      "",
      "",
      '\\"',
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\\\",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\u007F",
      "\\u0080",
      "\\u0081",
      "\\u0082",
      "\\u0083",
      "\\u0084",
      "\\u0085",
      "\\u0086",
      "\\u0087",
      "\\u0088",
      "\\u0089",
      "\\u008A",
      "\\u008B",
      "\\u008C",
      "\\u008D",
      "\\u008E",
      "\\u008F",
      "\\u0090",
      "\\u0091",
      "\\u0092",
      "\\u0093",
      "\\u0094",
      "\\u0095",
      "\\u0096",
      "\\u0097",
      "\\u0098",
      "\\u0099",
      "\\u009A",
      "\\u009B",
      "\\u009C",
      "\\u009D",
      "\\u009E",
      "\\u009F"
    ];
  }
});

// node_modules/graphql/language/visitor.mjs
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index = -1;
  let edits = [];
  let node = root;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node)
          );
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}
var BREAK;
var init_visitor = __esm({
  "node_modules/graphql/language/visitor.mjs"() {
    init_devAssert();
    init_inspect();
    init_ast();
    init_kinds();
    BREAK = Object.freeze({});
  }
});

// node_modules/graphql/language/printer.mjs
var printer_exports = {};
__export(printer_exports, {
  print: () => print
});
function print(ast) {
  return visit(ast, printDocASTReducer);
}
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x6) => x6).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
}
function wrap(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}
var MAX_LINE_LENGTH, printDocASTReducer;
var init_printer = __esm({
  "node_modules/graphql/language/printer.mjs"() {
    init_blockString();
    init_printString();
    init_visitor();
    MAX_LINE_LENGTH = 80;
    printDocASTReducer = {
      Name: {
        leave: (node) => node.value
      },
      Variable: {
        leave: (node) => "$" + node.name
      },
      Document: {
        leave: (node) => join(node.definitions, "\n\n")
      },
      OperationDefinition: {
        leave(node) {
          const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
          const prefix = join(
            [
              node.operation,
              join([node.name, varDefs]),
              join(node.directives, " ")
            ],
            " "
          );
          return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
        }
      },
      VariableDefinition: {
        leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
      },
      SelectionSet: {
        leave: ({ selections }) => block(selections)
      },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap("", alias, ": ") + name;
          let argsLine = prefix + wrap("(", join(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH) {
            argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
          }
          return join([argsLine, join(directives, " "), selectionSet], " ");
        }
      },
      Argument: {
        leave: ({ name, value }) => name + ": " + value
      },
      FragmentSpread: {
        leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
      },
      InlineFragment: {
        leave: ({ typeCondition, directives, selectionSet }) => join(
          [
            "...",
            wrap("on ", typeCondition),
            join(directives, " "),
            selectionSet
          ],
          " "
        )
      },
      FragmentDefinition: {
        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
      },
      IntValue: {
        leave: ({ value }) => value
      },
      FloatValue: {
        leave: ({ value }) => value
      },
      StringValue: {
        leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
      },
      BooleanValue: {
        leave: ({ value }) => value ? "true" : "false"
      },
      NullValue: {
        leave: () => "null"
      },
      EnumValue: {
        leave: ({ value }) => value
      },
      ListValue: {
        leave: ({ values }) => "[" + join(values, ", ") + "]"
      },
      ObjectValue: {
        leave: ({ fields }) => "{" + join(fields, ", ") + "}"
      },
      ObjectField: {
        leave: ({ name, value }) => name + ": " + value
      },
      Directive: {
        leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
      },
      NamedType: {
        leave: ({ name }) => name
      },
      ListType: {
        leave: ({ type }) => "[" + type + "]"
      },
      NonNullType: {
        leave: ({ type }) => type + "!"
      },
      SchemaDefinition: {
        leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
      },
      OperationTypeDefinition: {
        leave: ({ operation, type }) => operation + ": " + type
      },
      ScalarTypeDefinition: {
        leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
      },
      ObjectTypeDefinition: {
        leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
          [
            "type",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      FieldDefinition: {
        leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
      },
      InputValueDefinition: {
        leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join(
          [name + ": " + type, wrap("= ", defaultValue), join(directives, " ")],
          " "
        )
      },
      InterfaceTypeDefinition: {
        leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
          [
            "interface",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      UnionTypeDefinition: {
        leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(
          ["union", name, join(directives, " "), wrap("= ", join(types, " | "))],
          " "
        )
      },
      EnumTypeDefinition: {
        leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
      },
      EnumValueDefinition: {
        leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
      },
      InputObjectTypeDefinition: {
        leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
      },
      DirectiveDefinition: {
        leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
      },
      SchemaExtension: {
        leave: ({ directives, operationTypes }) => join(
          ["extend schema", join(directives, " "), block(operationTypes)],
          " "
        )
      },
      ScalarTypeExtension: {
        leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
      },
      ObjectTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join(
          [
            "extend type",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      InterfaceTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join(
          [
            "extend interface",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      UnionTypeExtension: {
        leave: ({ name, directives, types }) => join(
          [
            "extend union",
            name,
            join(directives, " "),
            wrap("= ", join(types, " | "))
          ],
          " "
        )
      },
      EnumTypeExtension: {
        leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
      },
      InputObjectTypeExtension: {
        leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
      }
    };
  }
});

// node_modules/bech32/dist/index.js
var require_dist = __commonJS({
  "node_modules/bech32/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bech32m = exports.bech32 = void 0;
    var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (let z4 = 0; z4 < ALPHABET.length; z4++) {
      const x6 = ALPHABET.charAt(z4);
      ALPHABET_MAP[x6] = z4;
    }
    function polymodStep(pre) {
      const b9 = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b9 >> 0 & 1) & 996825010 ^ -(b9 >> 1 & 1) & 642813549 ^ -(b9 >> 2 & 1) & 513874426 ^ -(b9 >> 3 & 1) & 1027748829 ^ -(b9 >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      let chk = 1;
      for (let i7 = 0; i7 < prefix.length; ++i7) {
        const c9 = prefix.charCodeAt(i7);
        if (c9 < 33 || c9 > 126)
          return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c9 >> 5;
      }
      chk = polymodStep(chk);
      for (let i7 = 0; i7 < prefix.length; ++i7) {
        const v9 = prefix.charCodeAt(i7);
        chk = polymodStep(chk) ^ v9 & 31;
      }
      return chk;
    }
    function convert(data, inBits, outBits, pad) {
      let value = 0;
      let bits = 0;
      const maxV = (1 << outBits) - 1;
      const result = [];
      for (let i7 = 0; i7 < data.length; ++i7) {
        value = value << inBits | data[i7];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value >> bits & maxV);
        }
      }
      if (pad) {
        if (bits > 0) {
          result.push(value << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits)
          return "Excess padding";
        if (value << outBits - bits & maxV)
          return "Non-zero padding";
      }
      return result;
    }
    function toWords(bytes) {
      return convert(bytes, 8, 5, true);
    }
    function fromWordsUnsafe(words) {
      const res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
    }
    function fromWords(words) {
      const res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    function getLibraryFromEncoding(encoding) {
      let ENCODING_CONST;
      if (encoding === "bech32") {
        ENCODING_CONST = 1;
      } else {
        ENCODING_CONST = 734539939;
      }
      function encode(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT)
          throw new TypeError("Exceeds length limit");
        prefix = prefix.toLowerCase();
        let chk = prefixChk(prefix);
        if (typeof chk === "string")
          throw new Error(chk);
        let result = prefix + "1";
        for (let i7 = 0; i7 < words.length; ++i7) {
          const x6 = words[i7];
          if (x6 >> 5 !== 0)
            throw new Error("Non 5-bit word");
          chk = polymodStep(chk) ^ x6;
          result += ALPHABET.charAt(x6);
        }
        for (let i7 = 0; i7 < 6; ++i7) {
          chk = polymodStep(chk);
        }
        chk ^= ENCODING_CONST;
        for (let i7 = 0; i7 < 6; ++i7) {
          const v9 = chk >> (5 - i7) * 5 & 31;
          result += ALPHABET.charAt(v9);
        }
        return result;
      }
      function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
          return str + " too short";
        if (str.length > LIMIT)
          return "Exceeds length limit";
        const lowered = str.toLowerCase();
        const uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
          return "Mixed-case string " + str;
        str = lowered;
        const split = str.lastIndexOf("1");
        if (split === -1)
          return "No separator character for " + str;
        if (split === 0)
          return "Missing prefix for " + str;
        const prefix = str.slice(0, split);
        const wordChars = str.slice(split + 1);
        if (wordChars.length < 6)
          return "Data too short";
        let chk = prefixChk(prefix);
        if (typeof chk === "string")
          return chk;
        const words = [];
        for (let i7 = 0; i7 < wordChars.length; ++i7) {
          const c9 = wordChars.charAt(i7);
          const v9 = ALPHABET_MAP[c9];
          if (v9 === void 0)
            return "Unknown character " + c9;
          chk = polymodStep(chk) ^ v9;
          if (i7 + 6 >= wordChars.length)
            continue;
          words.push(v9);
        }
        if (chk !== ENCODING_CONST)
          return "Invalid checksum for " + str;
        return { prefix, words };
      }
      function decodeUnsafe(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === "object")
          return res;
      }
      function decode(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === "object")
          return res;
        throw new Error(res);
      }
      return {
        decodeUnsafe,
        decode,
        encode,
        toWords,
        fromWordsUnsafe,
        fromWords
      };
    }
    exports.bech32 = getLibraryFromEncoding("bech32");
    exports.bech32m = getLibraryFromEncoding("bech32m");
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var global2 = typeof self !== "undefined" ? self : exports;
    var __self__ = function() {
      function F4() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      F4.prototype = global2;
      return new F4();
    }();
    (function(self2) {
      var irrelevant = function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e2) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers2(headers) {
          this.map = {};
          if (headers instanceof Headers2) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers2.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers2.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers2.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers2.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers2.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers2.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers2.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i7 = 0; i7 < view.length; i7++) {
            chars[i7] = String.fromCharCode(view[i7]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers2(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers2(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers2();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers2(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers2(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch;
          self2.Headers = Headers2;
          self2.Request = Request;
          self2.Response = Response;
        }
        exports2.Headers = Headers2;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/extract-files/public/ReactNativeFile.js
var require_ReactNativeFile = __commonJS({
  "node_modules/extract-files/public/ReactNativeFile.js"(exports, module) {
    "use strict";
    module.exports = function ReactNativeFile(_ref) {
      var uri = _ref.uri, name = _ref.name, type = _ref.type;
      this.uri = uri;
      this.name = name;
      this.type = type;
    };
  }
});

// node_modules/extract-files/public/isExtractableFile.js
var require_isExtractableFile = __commonJS({
  "node_modules/extract-files/public/isExtractableFile.js"(exports, module) {
    "use strict";
    var ReactNativeFile = require_ReactNativeFile();
    module.exports = function isExtractableFile(value) {
      return typeof File !== "undefined" && value instanceof File || typeof Blob !== "undefined" && value instanceof Blob || value instanceof ReactNativeFile;
    };
  }
});

// node_modules/extract-files/public/extractFiles.js
var require_extractFiles = __commonJS({
  "node_modules/extract-files/public/extractFiles.js"(exports, module) {
    "use strict";
    var defaultIsExtractableFile = require_isExtractableFile();
    module.exports = function extractFiles(value, path, isExtractableFile) {
      if (path === void 0) {
        path = "";
      }
      if (isExtractableFile === void 0) {
        isExtractableFile = defaultIsExtractableFile;
      }
      var clone;
      var files = /* @__PURE__ */ new Map();
      function addFile(paths, file) {
        var storedPaths = files.get(file);
        if (storedPaths)
          storedPaths.push.apply(storedPaths, paths);
        else
          files.set(file, paths);
      }
      if (isExtractableFile(value)) {
        clone = null;
        addFile([path], value);
      } else {
        var prefix = path ? path + "." : "";
        if (typeof FileList !== "undefined" && value instanceof FileList)
          clone = Array.prototype.map.call(value, function(file, i8) {
            addFile(["" + prefix + i8], file);
            return null;
          });
        else if (Array.isArray(value))
          clone = value.map(function(child, i8) {
            var result2 = extractFiles(child, "" + prefix + i8, isExtractableFile);
            result2.files.forEach(addFile);
            return result2.clone;
          });
        else if (value && value.constructor === Object) {
          clone = {};
          for (var i7 in value) {
            var result = extractFiles(value[i7], "" + prefix + i7, isExtractableFile);
            result.files.forEach(addFile);
            clone[i7] = result.clone;
          }
        } else
          clone = value;
      }
      return {
        clone,
        files
      };
    };
  }
});

// node_modules/extract-files/public/index.js
var require_public = __commonJS({
  "node_modules/extract-files/public/index.js"(exports) {
    "use strict";
    exports.ReactNativeFile = require_ReactNativeFile();
    exports.extractFiles = require_extractFiles();
    exports.isExtractableFile = require_isExtractableFile();
  }
});

// node_modules/form-data/lib/browser.js
var require_browser = __commonJS({
  "node_modules/form-data/lib/browser.js"(exports, module) {
    module.exports = typeof self == "object" ? self.FormData : window.FormData;
  }
});

// node_modules/graphql-request/dist/defaultJsonSerializer.js
var require_defaultJsonSerializer = __commonJS({
  "node_modules/graphql-request/dist/defaultJsonSerializer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultJsonSerializer = void 0;
    exports.defaultJsonSerializer = {
      parse: JSON.parse,
      stringify: JSON.stringify
    };
  }
});

// node_modules/graphql-request/dist/createRequestBody.js
var require_createRequestBody = __commonJS({
  "node_modules/graphql-request/dist/createRequestBody.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var extract_files_1 = require_public();
    var form_data_1 = __importDefault(require_browser());
    var defaultJsonSerializer_1 = require_defaultJsonSerializer();
    var isExtractableFileEnhanced = function(value) {
      return extract_files_1.isExtractableFile(value) || value !== null && typeof value === "object" && typeof value.pipe === "function";
    };
    function createRequestBody(query, variables, operationName, jsonSerializer) {
      if (jsonSerializer === void 0) {
        jsonSerializer = defaultJsonSerializer_1.defaultJsonSerializer;
      }
      var _a = extract_files_1.extractFiles({ query, variables, operationName }, "", isExtractableFileEnhanced), clone = _a.clone, files = _a.files;
      if (files.size === 0) {
        if (!Array.isArray(query)) {
          return jsonSerializer.stringify(clone);
        }
        if (typeof variables !== "undefined" && !Array.isArray(variables)) {
          throw new Error("Cannot create request body with given variable type, array expected");
        }
        var payload = query.reduce(function(accu, currentQuery, index) {
          accu.push({ query: currentQuery, variables: variables ? variables[index] : void 0 });
          return accu;
        }, []);
        return jsonSerializer.stringify(payload);
      }
      var Form = typeof FormData === "undefined" ? form_data_1.default : FormData;
      var form = new Form();
      form.append("operations", jsonSerializer.stringify(clone));
      var map = {};
      var i7 = 0;
      files.forEach(function(paths) {
        map[++i7] = paths;
      });
      form.append("map", jsonSerializer.stringify(map));
      i7 = 0;
      files.forEach(function(paths, file) {
        form.append("" + ++i7, file);
      });
      return form;
    }
    exports.default = createRequestBody;
  }
});

// node_modules/graphql-request/dist/parseArgs.js
var require_parseArgs = __commonJS({
  "node_modules/graphql-request/dist/parseArgs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseBatchRequestsExtendedArgs = exports.parseRawRequestExtendedArgs = exports.parseRequestExtendedArgs = exports.parseBatchRequestArgs = exports.parseRawRequestArgs = exports.parseRequestArgs = void 0;
    function parseRequestArgs(documentOrOptions, variables, requestHeaders) {
      return documentOrOptions.document ? documentOrOptions : {
        document: documentOrOptions,
        variables,
        requestHeaders,
        signal: void 0
      };
    }
    exports.parseRequestArgs = parseRequestArgs;
    function parseRawRequestArgs(queryOrOptions, variables, requestHeaders) {
      return queryOrOptions.query ? queryOrOptions : {
        query: queryOrOptions,
        variables,
        requestHeaders,
        signal: void 0
      };
    }
    exports.parseRawRequestArgs = parseRawRequestArgs;
    function parseBatchRequestArgs(documentsOrOptions, requestHeaders) {
      return documentsOrOptions.documents ? documentsOrOptions : {
        documents: documentsOrOptions,
        requestHeaders,
        signal: void 0
      };
    }
    exports.parseBatchRequestArgs = parseBatchRequestArgs;
    function parseRequestExtendedArgs(urlOrOptions, document, variables, requestHeaders) {
      return urlOrOptions.document ? urlOrOptions : {
        url: urlOrOptions,
        document,
        variables,
        requestHeaders,
        signal: void 0
      };
    }
    exports.parseRequestExtendedArgs = parseRequestExtendedArgs;
    function parseRawRequestExtendedArgs(urlOrOptions, query, variables, requestHeaders) {
      return urlOrOptions.query ? urlOrOptions : {
        url: urlOrOptions,
        query,
        variables,
        requestHeaders,
        signal: void 0
      };
    }
    exports.parseRawRequestExtendedArgs = parseRawRequestExtendedArgs;
    function parseBatchRequestsExtendedArgs(urlOrOptions, documents, requestHeaders) {
      return urlOrOptions.documents ? urlOrOptions : {
        url: urlOrOptions,
        documents,
        requestHeaders,
        signal: void 0
      };
    }
    exports.parseBatchRequestsExtendedArgs = parseBatchRequestsExtendedArgs;
  }
});

// node_modules/graphql-request/dist/types.js
var require_types = __commonJS({
  "node_modules/graphql-request/dist/types.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d3, b9) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b10) {
          d4.__proto__ = b10;
        } || function(d4, b10) {
          for (var p6 in b10)
            if (Object.prototype.hasOwnProperty.call(b10, p6))
              d4[p6] = b10[p6];
        };
        return extendStatics(d3, b9);
      };
      return function(d3, b9) {
        if (typeof b9 !== "function" && b9 !== null)
          throw new TypeError("Class extends value " + String(b9) + " is not a constructor or null");
        extendStatics(d3, b9);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b9 === null ? Object.create(b9) : (__.prototype = b9.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClientError = void 0;
    var ClientError = function(_super) {
      __extends(ClientError2, _super);
      function ClientError2(response, request) {
        var _this = this;
        var message = ClientError2.extractMessage(response) + ": " + JSON.stringify({
          response,
          request
        });
        _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, ClientError2.prototype);
        _this.response = response;
        _this.request = request;
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(_this, ClientError2);
        }
        return _this;
      }
      ClientError2.extractMessage = function(response) {
        try {
          return response.errors[0].message;
        } catch (e2) {
          return "GraphQL Error (Code: " + response.status + ")";
        }
      };
      return ClientError2;
    }(Error);
    exports.ClientError = ClientError;
  }
});

// node_modules/graphql-request/dist/graphql-ws.js
var require_graphql_ws = __commonJS({
  "node_modules/graphql-request/dist/graphql-ws.js"(exports) {
    "use strict";
    var __assign2 = exports && exports.__assign || function() {
      __assign2 = Object.assign || function(t5) {
        for (var s4, i7 = 1, n3 = arguments.length; i7 < n3; i7++) {
          s4 = arguments[i7];
          for (var p6 in s4)
            if (Object.prototype.hasOwnProperty.call(s4, p6))
              t5[p6] = s4[p6];
        }
        return t5;
      };
      return __assign2.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P6, generator) {
      function adopt(value) {
        return value instanceof P6 ? value : new P6(function(resolve) {
          resolve(value);
        });
      }
      return new (P6 || (P6 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _6 = { label: 0, sent: function() {
        if (t5[0] & 1)
          throw t5[1];
        return t5[1];
      }, trys: [], ops: [] }, f6, y4, t5, g4;
      return g4 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g4[Symbol.iterator] = function() {
        return this;
      }), g4;
      function verb(n3) {
        return function(v9) {
          return step([n3, v9]);
        };
      }
      function step(op) {
        if (f6)
          throw new TypeError("Generator is already executing.");
        while (_6)
          try {
            if (f6 = 1, y4 && (t5 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t5 = y4["return"]) && t5.call(y4), 0) : y4.next) && !(t5 = t5.call(y4, op[1])).done)
              return t5;
            if (y4 = 0, t5)
              op = [op[0] & 2, t5.value];
            switch (op[0]) {
              case 0:
              case 1:
                t5 = op;
                break;
              case 4:
                _6.label++;
                return { value: op[1], done: false };
              case 5:
                _6.label++;
                y4 = op[1];
                op = [0];
                continue;
              case 7:
                op = _6.ops.pop();
                _6.trys.pop();
                continue;
              default:
                if (!(t5 = _6.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _6 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
                  _6.label = op[1];
                  break;
                }
                if (op[0] === 6 && _6.label < t5[1]) {
                  _6.label = t5[1];
                  t5 = op;
                  break;
                }
                if (t5 && _6.label < t5[2]) {
                  _6.label = t5[2];
                  _6.ops.push(op);
                  break;
                }
                if (t5[2])
                  _6.ops.pop();
                _6.trys.pop();
                continue;
            }
            op = body.call(thisArg, _6);
          } catch (e2) {
            op = [6, e2];
            y4 = 0;
          } finally {
            f6 = t5 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GraphQLWebSocketClient = void 0;
    var types_1 = require_types();
    var _1 = require_dist2();
    var CONNECTION_INIT = "connection_init";
    var CONNECTION_ACK = "connection_ack";
    var PING = "ping";
    var PONG = "pong";
    var SUBSCRIBE = "subscribe";
    var NEXT = "next";
    var ERROR = "error";
    var COMPLETE = "complete";
    var GraphQLWebSocketMessage = function() {
      function GraphQLWebSocketMessage2(type, payload, id) {
        this._type = type;
        this._payload = payload;
        this._id = id;
      }
      Object.defineProperty(GraphQLWebSocketMessage2.prototype, "type", {
        get: function() {
          return this._type;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(GraphQLWebSocketMessage2.prototype, "id", {
        get: function() {
          return this._id;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(GraphQLWebSocketMessage2.prototype, "payload", {
        get: function() {
          return this._payload;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(GraphQLWebSocketMessage2.prototype, "text", {
        get: function() {
          var result = { type: this.type };
          if (this.id != null && this.id != void 0)
            result.id = this.id;
          if (this.payload != null && this.payload != void 0)
            result.payload = this.payload;
          return JSON.stringify(result);
        },
        enumerable: false,
        configurable: true
      });
      GraphQLWebSocketMessage2.parse = function(data, f6) {
        var _a = JSON.parse(data), type = _a.type, payload = _a.payload, id = _a.id;
        return new GraphQLWebSocketMessage2(type, f6(payload), id);
      };
      return GraphQLWebSocketMessage2;
    }();
    var GraphQLWebSocketClient = function() {
      function GraphQLWebSocketClient2(socket, _a) {
        var _this = this;
        var onInit = _a.onInit, onAcknowledged = _a.onAcknowledged, onPing = _a.onPing, onPong = _a.onPong;
        this.socketState = { acknowledged: false, lastRequestId: 0, subscriptions: {} };
        this.socket = socket;
        socket.onopen = function(e2) {
          return __awaiter(_this, void 0, void 0, function() {
            var _a2, _b, _c, _d;
            return __generator(this, function(_e2) {
              switch (_e2.label) {
                case 0:
                  this.socketState.acknowledged = false;
                  this.socketState.subscriptions = {};
                  _b = (_a2 = socket).send;
                  _c = ConnectionInit;
                  if (!onInit)
                    return [3, 2];
                  return [4, onInit()];
                case 1:
                  _d = _e2.sent();
                  return [3, 3];
                case 2:
                  _d = null;
                  _e2.label = 3;
                case 3:
                  _b.apply(_a2, [_c.apply(void 0, [_d]).text]);
                  return [2];
              }
            });
          });
        };
        socket.onclose = function(e2) {
          _this.socketState.acknowledged = false;
          _this.socketState.subscriptions = {};
        };
        socket.onerror = function(e2) {
          console.error(e2);
        };
        socket.onmessage = function(e2) {
          try {
            var message = parseMessage(e2.data);
            switch (message.type) {
              case CONNECTION_ACK: {
                if (_this.socketState.acknowledged) {
                  console.warn("Duplicate CONNECTION_ACK message ignored");
                } else {
                  _this.socketState.acknowledged = true;
                  if (onAcknowledged)
                    onAcknowledged(message.payload);
                }
                return;
              }
              case PING: {
                if (onPing)
                  onPing(message.payload).then(function(r2) {
                    return socket.send(Pong(r2).text);
                  });
                else
                  socket.send(Pong(null).text);
                return;
              }
              case PONG: {
                if (onPong)
                  onPong(message.payload);
                return;
              }
            }
            if (!_this.socketState.acknowledged) {
              return;
            }
            if (message.id === void 0 || message.id === null || !_this.socketState.subscriptions[message.id]) {
              return;
            }
            var _a2 = _this.socketState.subscriptions[message.id], query = _a2.query, variables = _a2.variables, subscriber = _a2.subscriber;
            switch (message.type) {
              case NEXT: {
                if (!message.payload.errors && message.payload.data) {
                  subscriber.next && subscriber.next(message.payload.data);
                }
                if (message.payload.errors) {
                  subscriber.error && subscriber.error(new types_1.ClientError(__assign2(__assign2({}, message.payload), { status: 200 }), { query, variables }));
                } else {
                }
                return;
              }
              case ERROR: {
                subscriber.error && subscriber.error(new types_1.ClientError({ errors: message.payload, status: 200 }, { query, variables }));
                return;
              }
              case COMPLETE: {
                subscriber.complete && subscriber.complete();
                delete _this.socketState.subscriptions[message.id];
                return;
              }
            }
          } catch (e3) {
            console.error(e3);
            socket.close(1006);
          }
          socket.close(4400, "Unknown graphql-ws message.");
        };
      }
      GraphQLWebSocketClient2.prototype.makeSubscribe = function(query, operationName, variables, subscriber) {
        var _this = this;
        var subscriptionId = (this.socketState.lastRequestId++).toString();
        this.socketState.subscriptions[subscriptionId] = { query, variables, subscriber };
        this.socket.send(Subscribe(subscriptionId, { query, operationName, variables }).text);
        return function() {
          _this.socket.send(Complete(subscriptionId).text);
          delete _this.socketState.subscriptions[subscriptionId];
        };
      };
      GraphQLWebSocketClient2.prototype.rawRequest = function(query, variables) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          var result;
          _this.rawSubscribe(query, {
            next: function(data, extensions) {
              return result = { data, extensions };
            },
            error: reject,
            complete: function() {
              return resolve(result);
            }
          }, variables);
        });
      };
      GraphQLWebSocketClient2.prototype.request = function(document, variables) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          var result;
          _this.subscribe(document, {
            next: function(data) {
              return result = data;
            },
            error: reject,
            complete: function() {
              return resolve(result);
            }
          }, variables);
        });
      };
      GraphQLWebSocketClient2.prototype.subscribe = function(document, subscriber, variables) {
        var _a = _1.resolveRequestDocument(document), query = _a.query, operationName = _a.operationName;
        return this.makeSubscribe(query, operationName, variables, subscriber);
      };
      GraphQLWebSocketClient2.prototype.rawSubscribe = function(query, subscriber, variables) {
        return this.makeSubscribe(query, void 0, variables, subscriber);
      };
      GraphQLWebSocketClient2.prototype.ping = function(payload) {
        this.socket.send(Ping(payload).text);
      };
      GraphQLWebSocketClient2.prototype.close = function() {
        this.socket.close(1e3);
      };
      GraphQLWebSocketClient2.PROTOCOL = "graphql-transport-ws";
      return GraphQLWebSocketClient2;
    }();
    exports.GraphQLWebSocketClient = GraphQLWebSocketClient;
    function parseMessage(data, f6) {
      if (f6 === void 0) {
        f6 = function(a6) {
          return a6;
        };
      }
      var m4 = GraphQLWebSocketMessage.parse(data, f6);
      return m4;
    }
    function ConnectionInit(payload) {
      return new GraphQLWebSocketMessage(CONNECTION_INIT, payload);
    }
    function Ping(payload) {
      return new GraphQLWebSocketMessage(PING, payload, void 0);
    }
    function Pong(payload) {
      return new GraphQLWebSocketMessage(PONG, payload, void 0);
    }
    function Subscribe(id, payload) {
      return new GraphQLWebSocketMessage(SUBSCRIBE, payload, id);
    }
    function Complete(id) {
      return new GraphQLWebSocketMessage(COMPLETE, void 0, id);
    }
  }
});

// node_modules/graphql-request/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/graphql-request/dist/index.js"(exports) {
    "use strict";
    var __assign2 = exports && exports.__assign || function() {
      __assign2 = Object.assign || function(t5) {
        for (var s4, i7 = 1, n3 = arguments.length; i7 < n3; i7++) {
          s4 = arguments[i7];
          for (var p6 in s4)
            if (Object.prototype.hasOwnProperty.call(s4, p6))
              t5[p6] = s4[p6];
        }
        return t5;
      };
      return __assign2.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m4, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      Object.defineProperty(o4, k22, { enumerable: true, get: function() {
        return m4[k5];
      } });
    } : function(o4, m4, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m4[k5];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o4, v9) {
      Object.defineProperty(o4, "default", { enumerable: true, value: v9 });
    } : function(o4, v9) {
      o4["default"] = v9;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k5 in mod)
          if (k5 !== "default" && Object.prototype.hasOwnProperty.call(mod, k5))
            __createBinding(result, mod, k5);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P6, generator) {
      function adopt(value) {
        return value instanceof P6 ? value : new P6(function(resolve) {
          resolve(value);
        });
      }
      return new (P6 || (P6 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _6 = { label: 0, sent: function() {
        if (t5[0] & 1)
          throw t5[1];
        return t5[1];
      }, trys: [], ops: [] }, f6, y4, t5, g4;
      return g4 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g4[Symbol.iterator] = function() {
        return this;
      }), g4;
      function verb(n3) {
        return function(v9) {
          return step([n3, v9]);
        };
      }
      function step(op) {
        if (f6)
          throw new TypeError("Generator is already executing.");
        while (_6)
          try {
            if (f6 = 1, y4 && (t5 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t5 = y4["return"]) && t5.call(y4), 0) : y4.next) && !(t5 = t5.call(y4, op[1])).done)
              return t5;
            if (y4 = 0, t5)
              op = [op[0] & 2, t5.value];
            switch (op[0]) {
              case 0:
              case 1:
                t5 = op;
                break;
              case 4:
                _6.label++;
                return { value: op[1], done: false };
              case 5:
                _6.label++;
                y4 = op[1];
                op = [0];
                continue;
              case 7:
                op = _6.ops.pop();
                _6.trys.pop();
                continue;
              default:
                if (!(t5 = _6.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _6 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
                  _6.label = op[1];
                  break;
                }
                if (op[0] === 6 && _6.label < t5[1]) {
                  _6.label = t5[1];
                  t5 = op;
                  break;
                }
                if (t5 && _6.label < t5[2]) {
                  _6.label = t5[2];
                  _6.ops.push(op);
                  break;
                }
                if (t5[2])
                  _6.ops.pop();
                _6.trys.pop();
                continue;
            }
            op = body.call(thisArg, _6);
          } catch (e2) {
            op = [6, e2];
            y4 = 0;
          } finally {
            f6 = t5 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __rest = exports && exports.__rest || function(s4, e2) {
      var t5 = {};
      for (var p6 in s4)
        if (Object.prototype.hasOwnProperty.call(s4, p6) && e2.indexOf(p6) < 0)
          t5[p6] = s4[p6];
      if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i7 = 0, p6 = Object.getOwnPropertySymbols(s4); i7 < p6.length; i7++) {
          if (e2.indexOf(p6[i7]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p6[i7]))
            t5[p6[i7]] = s4[p6[i7]];
        }
      return t5;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GraphQLWebSocketClient = exports.gql = exports.resolveRequestDocument = exports.batchRequests = exports.request = exports.rawRequest = exports.GraphQLClient = exports.ClientError = void 0;
    var cross_fetch_1 = __importStar(require_browser_ponyfill());
    var CrossFetch = cross_fetch_1;
    var parser_1 = (init_parser(), __toCommonJS(parser_exports));
    var printer_1 = (init_printer(), __toCommonJS(printer_exports));
    var createRequestBody_1 = __importDefault(require_createRequestBody());
    var defaultJsonSerializer_1 = require_defaultJsonSerializer();
    var parseArgs_1 = require_parseArgs();
    var types_1 = require_types();
    Object.defineProperty(exports, "ClientError", { enumerable: true, get: function() {
      return types_1.ClientError;
    } });
    var resolveHeaders = function(headers) {
      var oHeaders = {};
      if (headers) {
        if (typeof Headers !== "undefined" && headers instanceof Headers || CrossFetch && CrossFetch.Headers && headers instanceof CrossFetch.Headers) {
          oHeaders = HeadersInstanceToPlainObject(headers);
        } else if (Array.isArray(headers)) {
          headers.forEach(function(_a) {
            var name = _a[0], value = _a[1];
            oHeaders[name] = value;
          });
        } else {
          oHeaders = headers;
        }
      }
      return oHeaders;
    };
    var queryCleanner = function(str) {
      return str.replace(/([\s,]|#[^\n\r]+)+/g, " ").trim();
    };
    var buildGetQueryParams = function(_a) {
      var query = _a.query, variables = _a.variables, operationName = _a.operationName, jsonSerializer = _a.jsonSerializer;
      if (!Array.isArray(query)) {
        var search = ["query=" + encodeURIComponent(queryCleanner(query))];
        if (variables) {
          search.push("variables=" + encodeURIComponent(jsonSerializer.stringify(variables)));
        }
        if (operationName) {
          search.push("operationName=" + encodeURIComponent(operationName));
        }
        return search.join("&");
      }
      if (typeof variables !== "undefined" && !Array.isArray(variables)) {
        throw new Error("Cannot create query with given variable type, array expected");
      }
      var payload = query.reduce(function(accu, currentQuery, index) {
        accu.push({
          query: queryCleanner(currentQuery),
          variables: variables ? jsonSerializer.stringify(variables[index]) : void 0
        });
        return accu;
      }, []);
      return "query=" + encodeURIComponent(jsonSerializer.stringify(payload));
    };
    var post = function(_a) {
      var url = _a.url, query = _a.query, variables = _a.variables, operationName = _a.operationName, headers = _a.headers, fetch = _a.fetch, fetchOptions = _a.fetchOptions, middleware = _a.middleware;
      return __awaiter(void 0, void 0, void 0, function() {
        var body, options;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              body = createRequestBody_1.default(query, variables, operationName, fetchOptions.jsonSerializer);
              options = __assign2({ method: "POST", headers: __assign2(__assign2({}, typeof body === "string" ? { "Content-Type": "application/json" } : {}), headers), body }, fetchOptions);
              if (!middleware)
                return [3, 2];
              return [4, Promise.resolve(middleware(options))];
            case 1:
              options = _b.sent();
              _b.label = 2;
            case 2:
              return [4, fetch(url, options)];
            case 3:
              return [2, _b.sent()];
          }
        });
      });
    };
    var get = function(_a) {
      var url = _a.url, query = _a.query, variables = _a.variables, operationName = _a.operationName, headers = _a.headers, fetch = _a.fetch, fetchOptions = _a.fetchOptions, middleware = _a.middleware;
      return __awaiter(void 0, void 0, void 0, function() {
        var queryParams, options;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              queryParams = buildGetQueryParams({
                query,
                variables,
                operationName,
                jsonSerializer: fetchOptions.jsonSerializer
              });
              options = __assign2({ method: "GET", headers }, fetchOptions);
              if (!middleware)
                return [3, 2];
              return [4, Promise.resolve(middleware(options))];
            case 1:
              options = _b.sent();
              _b.label = 2;
            case 2:
              return [4, fetch(url + "?" + queryParams, options)];
            case 3:
              return [2, _b.sent()];
          }
        });
      });
    };
    var GraphQLClient = function() {
      function GraphQLClient2(url, options) {
        if (options === void 0) {
          options = {};
        }
        this.url = url;
        this.options = options;
      }
      GraphQLClient2.prototype.rawRequest = function(queryOrOptions, variables, requestHeaders) {
        return __awaiter(this, void 0, void 0, function() {
          var rawRequestOptions, _a, headers, _b, fetch, _c, method, requestMiddleware, responseMiddleware, fetchOptions, url, operationName;
          return __generator(this, function(_d) {
            rawRequestOptions = parseArgs_1.parseRawRequestArgs(queryOrOptions, variables, requestHeaders);
            _a = this.options, headers = _a.headers, _b = _a.fetch, fetch = _b === void 0 ? cross_fetch_1.default : _b, _c = _a.method, method = _c === void 0 ? "POST" : _c, requestMiddleware = _a.requestMiddleware, responseMiddleware = _a.responseMiddleware, fetchOptions = __rest(_a, ["headers", "fetch", "method", "requestMiddleware", "responseMiddleware"]);
            url = this.url;
            if (rawRequestOptions.signal !== void 0) {
              fetchOptions.signal = rawRequestOptions.signal;
            }
            operationName = resolveRequestDocument(rawRequestOptions.query).operationName;
            return [2, makeRequest({
              url,
              query: rawRequestOptions.query,
              variables: rawRequestOptions.variables,
              headers: __assign2(__assign2({}, resolveHeaders(callOrIdentity(headers))), resolveHeaders(rawRequestOptions.requestHeaders)),
              operationName,
              fetch,
              method,
              fetchOptions,
              middleware: requestMiddleware
            }).then(function(response) {
              if (responseMiddleware) {
                responseMiddleware(response);
              }
              return response;
            }).catch(function(error) {
              if (responseMiddleware) {
                responseMiddleware(error);
              }
              throw error;
            })];
          });
        });
      };
      GraphQLClient2.prototype.request = function(documentOrOptions) {
        var variablesAndRequestHeaders = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          variablesAndRequestHeaders[_i - 1] = arguments[_i];
        }
        var variables = variablesAndRequestHeaders[0], requestHeaders = variablesAndRequestHeaders[1];
        var requestOptions = parseArgs_1.parseRequestArgs(documentOrOptions, variables, requestHeaders);
        var _a = this.options, headers = _a.headers, _b = _a.fetch, fetch = _b === void 0 ? cross_fetch_1.default : _b, _c = _a.method, method = _c === void 0 ? "POST" : _c, requestMiddleware = _a.requestMiddleware, responseMiddleware = _a.responseMiddleware, fetchOptions = __rest(_a, ["headers", "fetch", "method", "requestMiddleware", "responseMiddleware"]);
        var url = this.url;
        if (requestOptions.signal !== void 0) {
          fetchOptions.signal = requestOptions.signal;
        }
        var _d = resolveRequestDocument(requestOptions.document), query = _d.query, operationName = _d.operationName;
        return makeRequest({
          url,
          query,
          variables: requestOptions.variables,
          headers: __assign2(__assign2({}, resolveHeaders(callOrIdentity(headers))), resolveHeaders(requestOptions.requestHeaders)),
          operationName,
          fetch,
          method,
          fetchOptions,
          middleware: requestMiddleware
        }).then(function(response) {
          if (responseMiddleware) {
            responseMiddleware(response);
          }
          return response.data;
        }).catch(function(error) {
          if (responseMiddleware) {
            responseMiddleware(error);
          }
          throw error;
        });
      };
      GraphQLClient2.prototype.batchRequests = function(documentsOrOptions, requestHeaders) {
        var batchRequestOptions = parseArgs_1.parseBatchRequestArgs(documentsOrOptions, requestHeaders);
        var _a = this.options, headers = _a.headers, _b = _a.fetch, fetch = _b === void 0 ? cross_fetch_1.default : _b, _c = _a.method, method = _c === void 0 ? "POST" : _c, requestMiddleware = _a.requestMiddleware, responseMiddleware = _a.responseMiddleware, fetchOptions = __rest(_a, ["headers", "fetch", "method", "requestMiddleware", "responseMiddleware"]);
        var url = this.url;
        if (batchRequestOptions.signal !== void 0) {
          fetchOptions.signal = batchRequestOptions.signal;
        }
        var queries = batchRequestOptions.documents.map(function(_a2) {
          var document = _a2.document;
          return resolveRequestDocument(document).query;
        });
        var variables = batchRequestOptions.documents.map(function(_a2) {
          var variables2 = _a2.variables;
          return variables2;
        });
        return makeRequest({
          url,
          query: queries,
          variables,
          headers: __assign2(__assign2({}, resolveHeaders(callOrIdentity(headers))), resolveHeaders(batchRequestOptions.requestHeaders)),
          operationName: void 0,
          fetch,
          method,
          fetchOptions,
          middleware: requestMiddleware
        }).then(function(response) {
          if (responseMiddleware) {
            responseMiddleware(response);
          }
          return response.data;
        }).catch(function(error) {
          if (responseMiddleware) {
            responseMiddleware(error);
          }
          throw error;
        });
      };
      GraphQLClient2.prototype.setHeaders = function(headers) {
        this.options.headers = headers;
        return this;
      };
      GraphQLClient2.prototype.setHeader = function(key, value) {
        var _a;
        var headers = this.options.headers;
        if (headers) {
          headers[key] = value;
        } else {
          this.options.headers = (_a = {}, _a[key] = value, _a);
        }
        return this;
      };
      GraphQLClient2.prototype.setEndpoint = function(value) {
        this.url = value;
        return this;
      };
      return GraphQLClient2;
    }();
    exports.GraphQLClient = GraphQLClient;
    function makeRequest(_a) {
      var url = _a.url, query = _a.query, variables = _a.variables, headers = _a.headers, operationName = _a.operationName, fetch = _a.fetch, _b = _a.method, method = _b === void 0 ? "POST" : _b, fetchOptions = _a.fetchOptions, middleware = _a.middleware;
      return __awaiter(this, void 0, void 0, function() {
        var fetcher, isBathchingQuery, response, result, successfullyReceivedData, successfullyPassedErrorPolicy, headers_1, status_1, errors, rest, data, errorResult;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              fetcher = method.toUpperCase() === "POST" ? post : get;
              isBathchingQuery = Array.isArray(query);
              return [4, fetcher({
                url,
                query,
                variables,
                operationName,
                headers,
                fetch,
                fetchOptions,
                middleware
              })];
            case 1:
              response = _c.sent();
              return [4, getResult(response, fetchOptions.jsonSerializer)];
            case 2:
              result = _c.sent();
              successfullyReceivedData = isBathchingQuery && Array.isArray(result) ? !result.some(function(_a2) {
                var data2 = _a2.data;
                return !data2;
              }) : !!result.data;
              successfullyPassedErrorPolicy = !result.errors || fetchOptions.errorPolicy === "all" || fetchOptions.errorPolicy === "ignore";
              if (response.ok && successfullyPassedErrorPolicy && successfullyReceivedData) {
                headers_1 = response.headers, status_1 = response.status;
                errors = result.errors, rest = __rest(result, ["errors"]);
                data = fetchOptions.errorPolicy === "ignore" ? rest : result;
                return [2, __assign2(__assign2({}, isBathchingQuery ? { data } : data), { headers: headers_1, status: status_1 })];
              } else {
                errorResult = typeof result === "string" ? { error: result } : result;
                throw new types_1.ClientError(__assign2(__assign2({}, errorResult), { status: response.status, headers: response.headers }), { query, variables });
              }
              return [2];
          }
        });
      });
    }
    function rawRequest(urlOrOptions, query, variables, requestHeaders) {
      return __awaiter(this, void 0, void 0, function() {
        var requestOptions, client;
        return __generator(this, function(_a) {
          requestOptions = parseArgs_1.parseRawRequestExtendedArgs(urlOrOptions, query, variables, requestHeaders);
          client = new GraphQLClient(requestOptions.url);
          return [2, client.rawRequest(__assign2({}, requestOptions))];
        });
      });
    }
    exports.rawRequest = rawRequest;
    function request(urlOrOptions, document) {
      var variablesAndRequestHeaders = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        variablesAndRequestHeaders[_i - 2] = arguments[_i];
      }
      return __awaiter(this, void 0, void 0, function() {
        var variables, requestHeaders, requestOptions, client;
        return __generator(this, function(_a) {
          variables = variablesAndRequestHeaders[0], requestHeaders = variablesAndRequestHeaders[1];
          requestOptions = parseArgs_1.parseRequestExtendedArgs(urlOrOptions, document, variables, requestHeaders);
          client = new GraphQLClient(requestOptions.url);
          return [2, client.request(__assign2({}, requestOptions))];
        });
      });
    }
    exports.request = request;
    function batchRequests(urlOrOptions, documents, requestHeaders) {
      return __awaiter(this, void 0, void 0, function() {
        var requestOptions, client;
        return __generator(this, function(_a) {
          requestOptions = parseArgs_1.parseBatchRequestsExtendedArgs(urlOrOptions, documents, requestHeaders);
          client = new GraphQLClient(requestOptions.url);
          return [2, client.batchRequests(__assign2({}, requestOptions))];
        });
      });
    }
    exports.batchRequests = batchRequests;
    exports.default = request;
    function getResult(response, jsonSerializer) {
      if (jsonSerializer === void 0) {
        jsonSerializer = defaultJsonSerializer_1.defaultJsonSerializer;
      }
      return __awaiter(this, void 0, void 0, function() {
        var contentType, _a, _b;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              response.headers.forEach(function(value, key) {
                if (key.toLowerCase() === "content-type") {
                  contentType = value;
                }
              });
              if (!(contentType && contentType.toLowerCase().startsWith("application/json")))
                return [3, 2];
              _b = (_a = jsonSerializer).parse;
              return [4, response.text()];
            case 1:
              return [2, _b.apply(_a, [_c.sent()])];
            case 2:
              return [2, response.text()];
          }
        });
      });
    }
    function extractOperationName(document) {
      var _a;
      var operationName = void 0;
      var operationDefinitions = document.definitions.filter(function(definition) {
        return definition.kind === "OperationDefinition";
      });
      if (operationDefinitions.length === 1) {
        operationName = (_a = operationDefinitions[0].name) === null || _a === void 0 ? void 0 : _a.value;
      }
      return operationName;
    }
    function resolveRequestDocument(document) {
      if (typeof document === "string") {
        var operationName_1 = void 0;
        try {
          var parsedDocument = parser_1.parse(document);
          operationName_1 = extractOperationName(parsedDocument);
        } catch (err) {
        }
        return { query: document, operationName: operationName_1 };
      }
      var operationName = extractOperationName(document);
      return { query: printer_1.print(document), operationName };
    }
    exports.resolveRequestDocument = resolveRequestDocument;
    function callOrIdentity(value) {
      return typeof value === "function" ? value() : value;
    }
    function gql2(chunks) {
      var variables = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        variables[_i - 1] = arguments[_i];
      }
      return chunks.reduce(function(accumulator, chunk, index) {
        return "" + accumulator + chunk + (index in variables ? variables[index] : "");
      }, "");
    }
    exports.gql = gql2;
    function HeadersInstanceToPlainObject(headers) {
      var o4 = {};
      headers.forEach(function(v9, k5) {
        o4[k5] = v9;
      });
      return o4;
    }
    var graphql_ws_1 = require_graphql_ws();
    Object.defineProperty(exports, "GraphQLWebSocketClient", { enumerable: true, get: function() {
      return graphql_ws_1.GraphQLWebSocketClient;
    } });
  }
});

// node_modules/lodash.clonedeep/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.clonedeep/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n3, iteratee) {
      var index = -1, result = Array(n3);
      while (++index < n3) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e2) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty2.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function cloneDeep(value) {
      return baseClone(value, true, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike2(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike2(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = cloneDeep;
  }
});

// node_modules/elliptic/package.json
var require_package = __commonJS({
  "node_modules/elliptic/package.json"(exports, module) {
    module.exports = {
      name: "elliptic",
      version: "6.5.4",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// node_modules/elliptic/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/elliptic/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer().Buffer;
        }
      } catch (e2) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i7 = 0; i7 < this.length; i7++) {
          this.words[i7] = 0;
        }
        var j5, w8;
        var off = 0;
        if (endian === "be") {
          for (i7 = number.length - 1, j5 = 0; i7 >= 0; i7 -= 3) {
            w8 = number[i7] | number[i7 - 1] << 8 | number[i7 - 2] << 16;
            this.words[j5] |= w8 << off & 67108863;
            this.words[j5 + 1] = w8 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        } else if (endian === "le") {
          for (i7 = 0, j5 = 0; i7 < number.length; i7 += 3) {
            w8 = number[i7] | number[i7 + 1] << 8 | number[i7 + 2] << 16;
            this.words[j5] |= w8 << off & 67108863;
            this.words[j5 + 1] = w8 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c9 = string.charCodeAt(index);
        if (c9 >= 65 && c9 <= 70) {
          return c9 - 55;
        } else if (c9 >= 97 && c9 <= 102) {
          return c9 - 87;
        } else {
          return c9 - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r2 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r2 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r2;
      }
      BN2.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i7 = 0; i7 < this.length; i7++) {
          this.words[i7] = 0;
        }
        var off = 0;
        var j5 = 0;
        var w8;
        if (endian === "be") {
          for (i7 = number.length - 1; i7 >= start; i7 -= 2) {
            w8 = parseHexByte(number, start, i7) << off;
            this.words[j5] |= w8 & 67108863;
            if (off >= 18) {
              off -= 18;
              j5 += 1;
              this.words[j5] |= w8 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i7 = parseLength % 2 === 0 ? start + 1 : start; i7 < number.length; i7 += 2) {
            w8 = parseHexByte(number, start, i7) << off;
            this.words[j5] |= w8 & 67108863;
            if (off >= 18) {
              off -= 18;
              j5 += 1;
              this.words[j5] |= w8 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r2 = 0;
        var len = Math.min(str.length, end);
        for (var i7 = start; i7 < len; i7++) {
          var c9 = str.charCodeAt(i7) - 48;
          r2 *= mul;
          if (c9 >= 49) {
            r2 += c9 - 49 + 10;
          } else if (c9 >= 17) {
            r2 += c9 - 17 + 10;
          } else {
            r2 += c9;
          }
        }
        return r2;
      }
      BN2.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i7 = start; i7 < end; i7 += limbLen) {
          word = parseBase(number, i7, i7 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i7, number.length, base);
          for (i7 = 0; i7 < mod; i7++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN2.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i7 = 0; i7 < this.length; i7++) {
          dest.words[i7] = this.words[i7];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN2.prototype.clone = function clone() {
        var r2 = new BN2(null);
        this.copy(r2);
        return r2;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN2.prototype.inspect = function inspect2() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i7 = 0; i7 < this.length; i7++) {
            var w8 = this.words[i7];
            var word = ((w8 << off | carry) & 16777215).toString(16);
            carry = w8 >>> 24 - off & 16777215;
            if (carry !== 0 || i7 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i7--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c9 = this.clone();
          c9.negative = 0;
          while (!c9.isZero()) {
            var r2 = c9.modn(groupBase).toString(base);
            c9 = c9.idivn(groupBase);
            if (!c9.isZero()) {
              out = zeros2[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN2.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b9, i7;
        var q5 = this.clone();
        if (!littleEndian) {
          for (i7 = 0; i7 < reqLength - byteLength; i7++) {
            res[i7] = 0;
          }
          for (i7 = 0; !q5.isZero(); i7++) {
            b9 = q5.andln(255);
            q5.iushrn(8);
            res[reqLength - i7 - 1] = b9;
          }
        } else {
          for (i7 = 0; !q5.isZero(); i7++) {
            b9 = q5.andln(255);
            q5.iushrn(8);
            res[i7] = b9;
          }
          for (; i7 < reqLength; i7++) {
            res[i7] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w8) {
          return 32 - Math.clz32(w8);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w8) {
          var t5 = w8;
          var r2 = 0;
          if (t5 >= 4096) {
            r2 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r2 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r2 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r2 += 2;
            t5 >>>= 2;
          }
          return r2 + t5;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w8) {
        if (w8 === 0)
          return 26;
        var t5 = w8;
        var r2 = 0;
        if ((t5 & 8191) === 0) {
          r2 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r2 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r2 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r2 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r2++;
        }
        return r2;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w8 = this.words[this.length - 1];
        var hi = this._countBits(w8);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w8 = new Array(num.bitLength());
        for (var bit = 0; bit < w8.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w8[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w8;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r2 = 0;
        for (var i7 = 0; i7 < this.length; i7++) {
          var b9 = this._zeroBits(this.words[i7]);
          r2 += b9;
          if (b9 !== 26)
            break;
        }
        return r2;
      };
      BN2.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i7 = 0; i7 < num.length; i7++) {
          this.words[i7] = this.words[i7] | num.words[i7];
        }
        return this.strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b9;
        if (this.length > num.length) {
          b9 = num;
        } else {
          b9 = this;
        }
        for (var i7 = 0; i7 < b9.length; i7++) {
          this.words[i7] = this.words[i7] & num.words[i7];
        }
        this.length = b9.length;
        return this.strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a6;
        var b9;
        if (this.length > num.length) {
          a6 = this;
          b9 = num;
        } else {
          a6 = num;
          b9 = this;
        }
        for (var i7 = 0; i7 < b9.length; i7++) {
          this.words[i7] = a6.words[i7] ^ b9.words[i7];
        }
        if (this !== a6) {
          for (; i7 < a6.length; i7++) {
            this.words[i7] = a6.words[i7];
          }
        }
        this.length = a6.length;
        return this.strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i7 = 0; i7 < bytesNeeded; i7++) {
          this.words[i7] = ~this.words[i7] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i7] = ~this.words[i7] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a6, b9;
        if (this.length > num.length) {
          a6 = this;
          b9 = num;
        } else {
          a6 = num;
          b9 = this;
        }
        var carry = 0;
        for (var i7 = 0; i7 < b9.length; i7++) {
          r2 = (a6.words[i7] | 0) + (b9.words[i7] | 0) + carry;
          this.words[i7] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i7 < a6.length; i7++) {
          r2 = (a6.words[i7] | 0) + carry;
          this.words[i7] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a6.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a6 !== this) {
          for (; i7 < a6.length; i7++) {
            this.words[i7] = a6.words[i7];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a6, b9;
        if (cmp > 0) {
          a6 = this;
          b9 = num;
        } else {
          a6 = num;
          b9 = this;
        }
        var carry = 0;
        for (var i7 = 0; i7 < b9.length; i7++) {
          r2 = (a6.words[i7] | 0) - (b9.words[i7] | 0) + carry;
          carry = r2 >> 26;
          this.words[i7] = r2 & 67108863;
        }
        for (; carry !== 0 && i7 < a6.length; i7++) {
          r2 = (a6.words[i7] | 0) + carry;
          carry = r2 >> 26;
          this.words[i7] = r2 & 67108863;
        }
        if (carry === 0 && i7 < a6.length && a6 !== this) {
          for (; i7 < a6.length; i7++) {
            this.words[i7] = a6.words[i7];
          }
        }
        this.length = Math.max(this.length, i7);
        if (a6 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a6 = self2.words[0] | 0;
        var b9 = num.words[0] | 0;
        var r2 = a6 * b9;
        var lo = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i7 = k5 - j5 | 0;
            a6 = self2.words[i7] | 0;
            b9 = num.words[j5] | 0;
            r2 = a6 * b9 + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a6 = self2.words;
        var b9 = num.words;
        var o4 = out.words;
        var c9 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a6[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a6[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a6[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a6[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a6[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a6[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a62 = a6[6] | 0;
        var al6 = a62 & 8191;
        var ah6 = a62 >>> 13;
        var a7 = a6[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a6[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a6[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b9[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b9[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b9[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b9[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b9[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b52 = b9[5] | 0;
        var bl5 = b52 & 8191;
        var bh5 = b52 >>> 13;
        var b62 = b9[6] | 0;
        var bl6 = b62 & 8191;
        var bh6 = b62 >>> 13;
        var b72 = b9[7] | 0;
        var bl7 = b72 & 8191;
        var bh7 = b72 >>> 13;
        var b82 = b9[8] | 0;
        var bl8 = b82 & 8191;
        var bh8 = b82 >>> 13;
        var b92 = b9[9] | 0;
        var bl9 = b92 & 8191;
        var bh9 = b92 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w62 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w62 >>> 26) | 0;
        w62 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w72 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w72 >>> 26) | 0;
        w72 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c9 + lo | 0) + ((mid & 8191) << 13) | 0;
        c9 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o4[0] = w0;
        o4[1] = w1;
        o4[2] = w22;
        o4[3] = w32;
        o4[4] = w42;
        o4[5] = w52;
        o4[6] = w62;
        o4[7] = w72;
        o4[8] = w8;
        o4[9] = w9;
        o4[10] = w10;
        o4[11] = w11;
        o4[12] = w12;
        o4[13] = w13;
        o4[14] = w14;
        o4[15] = w15;
        o4[16] = w16;
        o4[17] = w17;
        o4[18] = w18;
        if (c9 !== 0) {
          o4[19] = c9;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j5 = Math.max(0, k5 - self2.length + 1); j5 <= maxJ; j5++) {
            var i7 = k5 - j5;
            var a6 = self2.words[i7] | 0;
            var b9 = num.words[j5] | 0;
            var r2 = a6 * b9;
            var lo = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x6, y4) {
        this.x = x6;
        this.y = y4;
      }
      FFTM.prototype.makeRBT = function makeRBT(N8) {
        var t5 = new Array(N8);
        var l7 = BN2.prototype._countBits(N8) - 1;
        for (var i7 = 0; i7 < N8; i7++) {
          t5[i7] = this.revBin(i7, l7, N8);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x6, l7, N8) {
        if (x6 === 0 || x6 === N8 - 1)
          return x6;
        var rb = 0;
        for (var i7 = 0; i7 < l7; i7++) {
          rb |= (x6 & 1) << l7 - i7 - 1;
          x6 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N8) {
        for (var i7 = 0; i7 < N8; i7++) {
          rtws[i7] = rws[rbt[i7]];
          itws[i7] = iws[rbt[i7]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N8, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N8);
        for (var s4 = 1; s4 < N8; s4 <<= 1) {
          var l7 = s4 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l7);
          var itwdf = Math.sin(2 * Math.PI / l7);
          for (var p6 = 0; p6 < N8; p6 += l7) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j5 = 0; j5 < s4; j5++) {
              var re4 = rtws[p6 + j5];
              var ie4 = itws[p6 + j5];
              var ro = rtws[p6 + j5 + s4];
              var io = itws[p6 + j5 + s4];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p6 + j5] = re4 + ro;
              itws[p6 + j5] = ie4 + io;
              rtws[p6 + j5 + s4] = re4 - ro;
              itws[p6 + j5 + s4] = ie4 - io;
              if (j5 !== l7) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m4) {
        var N8 = Math.max(m4, n3) | 1;
        var odd = N8 & 1;
        var i7 = 0;
        for (N8 = N8 / 2 | 0; N8; N8 = N8 >>> 1) {
          i7++;
        }
        return 1 << i7 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N8) {
        if (N8 <= 1)
          return;
        for (var i7 = 0; i7 < N8 / 2; i7++) {
          var t5 = rws[i7];
          rws[i7] = rws[N8 - i7 - 1];
          rws[N8 - i7 - 1] = t5;
          t5 = iws[i7];
          iws[i7] = -iws[N8 - i7 - 1];
          iws[N8 - i7 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N8) {
        var carry = 0;
        for (var i7 = 0; i7 < N8 / 2; i7++) {
          var w8 = Math.round(ws[2 * i7 + 1] / N8) * 8192 + Math.round(ws[2 * i7] / N8) + carry;
          ws[i7] = w8 & 67108863;
          if (w8 < 67108864) {
            carry = 0;
          } else {
            carry = w8 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N8) {
        var carry = 0;
        for (var i7 = 0; i7 < len; i7++) {
          carry = carry + (ws[i7] | 0);
          rws[2 * i7] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i7 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i7 = 2 * len; i7 < N8; ++i7) {
          rws[i7] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N8) {
        var ph = new Array(N8);
        for (var i7 = 0; i7 < N8; i7++) {
          ph[i7] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x6, y4, out) {
        var N8 = 2 * this.guessLen13b(x6.length, y4.length);
        var rbt = this.makeRBT(N8);
        var _6 = this.stub(N8);
        var rws = new Array(N8);
        var rwst = new Array(N8);
        var iwst = new Array(N8);
        var nrws = new Array(N8);
        var nrwst = new Array(N8);
        var niwst = new Array(N8);
        var rmws = out.words;
        rmws.length = N8;
        this.convert13b(x6.words, x6.length, rws, N8);
        this.convert13b(y4.words, y4.length, nrws, N8);
        this.transform(rws, _6, rwst, iwst, N8, rbt);
        this.transform(nrws, _6, nrwst, niwst, N8, rbt);
        for (var i7 = 0; i7 < N8; i7++) {
          var rx = rwst[i7] * nrwst[i7] - iwst[i7] * niwst[i7];
          iwst[i7] = rwst[i7] * niwst[i7] + iwst[i7] * nrwst[i7];
          rwst[i7] = rx;
        }
        this.conjugate(rwst, iwst, N8);
        this.transform(rwst, iwst, rmws, _6, N8, rbt);
        this.conjugate(rmws, _6, N8);
        this.normalize13b(rmws, N8);
        out.negative = x6.negative ^ y4.negative;
        out.length = x6.length + y4.length;
        return out.strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i7 = 0; i7 < this.length; i7++) {
          var w8 = (this.words[i7] | 0) * num;
          var lo = (w8 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w8 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i7] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i7] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w8 = toBitArray(num);
        if (w8.length === 0)
          return new BN2(1);
        var res = this;
        for (var i7 = 0; i7 < w8.length; i7++, res = res.sqr()) {
          if (w8[i7] !== 0)
            break;
        }
        if (++i7 < w8.length) {
          for (var q5 = res.sqr(); i7 < w8.length; i7++, q5 = q5.sqr()) {
            if (w8[i7] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s4 = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i7;
        if (r2 !== 0) {
          var carry = 0;
          for (i7 = 0; i7 < this.length; i7++) {
            var newCarry = this.words[i7] & carryMask;
            var c9 = (this.words[i7] | 0) - newCarry << r2;
            this.words[i7] = c9 | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i7] = carry;
            this.length++;
          }
        }
        if (s4 !== 0) {
          for (i7 = this.length - 1; i7 >= 0; i7--) {
            this.words[i7 + s4] = this.words[i7];
          }
          for (i7 = 0; i7 < s4; i7++) {
            this.words[i7] = 0;
          }
          this.length += s4;
        }
        return this.strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r2 = bits % 26;
        var s4 = Math.min((bits - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h5 -= s4;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i7 = 0; i7 < s4; i7++) {
            maskedWords.words[i7] = this.words[i7];
          }
          maskedWords.length = s4;
        }
        if (s4 === 0) {
        } else if (this.length > s4) {
          this.length -= s4;
          for (i7 = 0; i7 < this.length; i7++) {
            this.words[i7] = this.words[i7 + s4];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i7 = this.length - 1; i7 >= 0 && (carry !== 0 || i7 >= h5); i7--) {
          var word = this.words[i7] | 0;
          this.words[i7] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s4 = (bit - r2) / 26;
        var q5 = 1 << r2;
        if (this.length <= s4)
          return false;
        var w8 = this.words[s4];
        return !!(w8 & q5);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s4 = (bits - r2) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s4) {
          return this;
        }
        if (r2 !== 0) {
          s4++;
        }
        this.length = Math.min(s4, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i7 = 0; i7 < this.length && this.words[i7] >= 67108864; i7++) {
          this.words[i7] -= 67108864;
          if (i7 === this.length - 1) {
            this.words[i7 + 1] = 1;
          } else {
            this.words[i7 + 1]++;
          }
        }
        this.length = Math.max(this.length, i7 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i7 = 0; i7 < this.length && this.words[i7] < 0; i7++) {
            this.words[i7] += 67108864;
            this.words[i7 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i7;
        this._expand(len);
        var w8;
        var carry = 0;
        for (i7 = 0; i7 < num.length; i7++) {
          w8 = (this.words[i7 + shift] | 0) + carry;
          var right = (num.words[i7] | 0) * mul;
          w8 -= right & 67108863;
          carry = (w8 >> 26) - (right / 67108864 | 0);
          this.words[i7 + shift] = w8 & 67108863;
        }
        for (; i7 < this.length - shift; i7++) {
          w8 = (this.words[i7 + shift] | 0) + carry;
          carry = w8 >> 26;
          this.words[i7 + shift] = w8 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i7 = 0; i7 < this.length; i7++) {
          w8 = -(this.words[i7] | 0) + carry;
          carry = w8 >> 26;
          this.words[i7] = w8 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a6 = this.clone();
        var b9 = num;
        var bhi = b9.words[b9.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b9 = b9.ushln(shift);
          a6.iushln(shift);
          bhi = b9.words[b9.length - 1] | 0;
        }
        var m4 = a6.length - b9.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN2(null);
          q5.length = m4 + 1;
          q5.words = new Array(q5.length);
          for (var i7 = 0; i7 < q5.length; i7++) {
            q5.words[i7] = 0;
          }
        }
        var diff = a6.clone()._ishlnsubmul(b9, 1, m4);
        if (diff.negative === 0) {
          a6 = diff;
          if (q5) {
            q5.words[m4] = 1;
          }
        }
        for (var j5 = m4 - 1; j5 >= 0; j5--) {
          var qj = (a6.words[b9.length + j5] | 0) * 67108864 + (a6.words[b9.length + j5 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a6._ishlnsubmul(b9, qj, j5);
          while (a6.negative !== 0) {
            qj--;
            a6.negative = 0;
            a6._ishlnsubmul(b9, 1, j5);
            if (!a6.isZero()) {
              a6.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j5] = qj;
          }
        }
        if (q5) {
          q5.strip();
        }
        a6.strip();
        if (mode !== "div" && shift !== 0) {
          a6.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a6
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p6 = (1 << 26) % num;
        var acc = 0;
        for (var i7 = this.length - 1; i7 >= 0; i7--) {
          acc = (p6 * acc + (this.words[i7] | 0)) % num;
        }
        return acc;
      };
      BN2.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i7 = this.length - 1; i7 >= 0; i7--) {
          var w8 = (this.words[i7] | 0) + carry * 67108864;
          this.words[i7] = w8 / num | 0;
          carry = w8 % num;
        }
        return this.strip();
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p6) {
        assert(p6.negative === 0);
        assert(!p6.isZero());
        var x6 = this;
        var y4 = p6.clone();
        if (x6.negative !== 0) {
          x6 = x6.umod(p6);
        } else {
          x6 = x6.clone();
        }
        var A6 = new BN2(1);
        var B7 = new BN2(0);
        var C6 = new BN2(0);
        var D7 = new BN2(1);
        var g4 = 0;
        while (x6.isEven() && y4.isEven()) {
          x6.iushrn(1);
          y4.iushrn(1);
          ++g4;
        }
        var yp = y4.clone();
        var xp = x6.clone();
        while (!x6.isZero()) {
          for (var i7 = 0, im = 1; (x6.words[0] & im) === 0 && i7 < 26; ++i7, im <<= 1)
            ;
          if (i7 > 0) {
            x6.iushrn(i7);
            while (i7-- > 0) {
              if (A6.isOdd() || B7.isOdd()) {
                A6.iadd(yp);
                B7.isub(xp);
              }
              A6.iushrn(1);
              B7.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (y4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            y4.iushrn(j5);
            while (j5-- > 0) {
              if (C6.isOdd() || D7.isOdd()) {
                C6.iadd(yp);
                D7.isub(xp);
              }
              C6.iushrn(1);
              D7.iushrn(1);
            }
          }
          if (x6.cmp(y4) >= 0) {
            x6.isub(y4);
            A6.isub(C6);
            B7.isub(D7);
          } else {
            y4.isub(x6);
            C6.isub(A6);
            D7.isub(B7);
          }
        }
        return {
          a: C6,
          b: D7,
          gcd: y4.iushln(g4)
        };
      };
      BN2.prototype._invmp = function _invmp(p6) {
        assert(p6.negative === 0);
        assert(!p6.isZero());
        var a6 = this;
        var b9 = p6.clone();
        if (a6.negative !== 0) {
          a6 = a6.umod(p6);
        } else {
          a6 = a6.clone();
        }
        var x1 = new BN2(1);
        var x22 = new BN2(0);
        var delta = b9.clone();
        while (a6.cmpn(1) > 0 && b9.cmpn(1) > 0) {
          for (var i7 = 0, im = 1; (a6.words[0] & im) === 0 && i7 < 26; ++i7, im <<= 1)
            ;
          if (i7 > 0) {
            a6.iushrn(i7);
            while (i7-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (b9.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            b9.iushrn(j5);
            while (j5-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a6.cmp(b9) >= 0) {
            a6.isub(b9);
            x1.isub(x22);
          } else {
            b9.isub(a6);
            x22.isub(x1);
          }
        }
        var res;
        if (a6.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p6);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a6 = this.clone();
        var b9 = num.clone();
        a6.negative = 0;
        b9.negative = 0;
        for (var shift = 0; a6.isEven() && b9.isEven(); shift++) {
          a6.iushrn(1);
          b9.iushrn(1);
        }
        do {
          while (a6.isEven()) {
            a6.iushrn(1);
          }
          while (b9.isEven()) {
            b9.iushrn(1);
          }
          var r2 = a6.cmp(b9);
          if (r2 < 0) {
            var t5 = a6;
            a6 = b9;
            b9 = t5;
          } else if (r2 === 0 || b9.cmpn(1) === 0) {
            break;
          }
          a6.isub(b9);
        } while (true);
        return b9.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r2 = bit % 26;
        var s4 = (bit - r2) / 26;
        var q5 = 1 << r2;
        if (this.length <= s4) {
          this._expand(s4 + 1);
          this.words[s4] |= q5;
          return this;
        }
        var carry = q5;
        for (var i7 = s4; carry !== 0 && i7 < this.length; i7++) {
          var w8 = this.words[i7] | 0;
          w8 += carry;
          carry = w8 >>> 26;
          w8 &= 67108863;
          this.words[i7] = w8;
        }
        if (carry !== 0) {
          this.words[i7] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w8 = this.words[0] | 0;
          res = w8 === num ? 0 : w8 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i7 = this.length - 1; i7 >= 0; i7--) {
          var a6 = this.words[i7] | 0;
          var b9 = num.words[i7] | 0;
          if (a6 === b9)
            continue;
          if (a6 < b9) {
            res = -1;
          } else if (a6 > b9) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt2(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt2(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p6) {
        this.name = name;
        this.p = new BN2(p6, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          if (r2.strip !== void 0) {
            r2.strip();
          } else {
            r2._strip();
          }
        }
        return r2;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i7 = 0; i7 < outLen; i7++) {
          output.words[i7] = input.words[i7];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i7 = 10; i7 < input.length; i7++) {
          var next = input.words[i7] | 0;
          input.words[i7 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i7 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i7 = 0; i7 < num.length; i7++) {
          var w8 = num.words[i7] | 0;
          lo += w8 * 977;
          num.words[i7] = lo & 67108863;
          lo = w8 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i7 = 0; i7 < num.length; i7++) {
          var hi = (num.words[i7] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i7] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m4) {
        if (typeof m4 === "string") {
          var prime = BN2._prime(m4);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m4.gtn(1), "modulus must be greater than 1");
          this.m = m4;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a6) {
        assert(a6.negative === 0, "red works only with positives");
        assert(a6.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a6, b9) {
        assert((a6.negative | b9.negative) === 0, "red works only with positives");
        assert(
          a6.red && a6.red === b9.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a6) {
        if (this.prime)
          return this.prime.ireduce(a6)._forceRed(this);
        return a6.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a6) {
        if (a6.isZero()) {
          return a6.clone();
        }
        return this.m.sub(a6)._forceRed(this);
      };
      Red.prototype.add = function add(a6, b9) {
        this._verify2(a6, b9);
        var res = a6.add(b9);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a6, b9) {
        this._verify2(a6, b9);
        var res = a6.iadd(b9);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a6, b9) {
        this._verify2(a6, b9);
        var res = a6.sub(b9);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a6, b9) {
        this._verify2(a6, b9);
        var res = a6.isub(b9);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a6, num) {
        this._verify1(a6);
        return this.imod(a6.ushln(num));
      };
      Red.prototype.imul = function imul(a6, b9) {
        this._verify2(a6, b9);
        return this.imod(a6.imul(b9));
      };
      Red.prototype.mul = function mul(a6, b9) {
        this._verify2(a6, b9);
        return this.imod(a6.mul(b9));
      };
      Red.prototype.isqr = function isqr(a6) {
        return this.imul(a6, a6.clone());
      };
      Red.prototype.sqr = function sqr(a6) {
        return this.mul(a6, a6);
      };
      Red.prototype.sqrt = function sqrt(a6) {
        if (a6.isZero())
          return a6.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a6, pow);
        }
        var q5 = this.m.subn(1);
        var s4 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s4++;
          q5.iushrn(1);
        }
        assert(!q5.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z4 = this.m.bitLength();
        z4 = new BN2(2 * z4 * z4).toRed(this);
        while (this.pow(z4, lpow).cmp(nOne) !== 0) {
          z4.redIAdd(nOne);
        }
        var c9 = this.pow(z4, q5);
        var r2 = this.pow(a6, q5.addn(1).iushrn(1));
        var t5 = this.pow(a6, q5);
        var m4 = s4;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i7 = 0; tmp.cmp(one) !== 0; i7++) {
            tmp = tmp.redSqr();
          }
          assert(i7 < m4);
          var b9 = this.pow(c9, new BN2(1).iushln(m4 - i7 - 1));
          r2 = r2.redMul(b9);
          c9 = b9.redSqr();
          t5 = t5.redMul(c9);
          m4 = i7;
        }
        return r2;
      };
      Red.prototype.invm = function invm(a6) {
        var inv = a6._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a6, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a6.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a6;
        for (var i7 = 2; i7 < wnd.length; i7++) {
          wnd[i7] = this.mul(wnd[i7 - 1], a6);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i7 = num.length - 1; i7 >= 0; i7--) {
          var word = num.words[i7];
          for (var j5 = start - 1; j5 >= 0; j5--) {
            var bit = word >> j5 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i7 !== 0 || j5 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m4) {
        Red.call(this, m4);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      };
      Mont.prototype.imul = function imul(a6, b9) {
        if (a6.isZero() || b9.isZero()) {
          a6.words[0] = 0;
          a6.length = 1;
          return a6;
        }
        var t5 = a6.imul(b9);
        var c9 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u4 = t5.isub(c9).iushrn(this.shift);
        var res = u4;
        if (u4.cmp(this.m) >= 0) {
          res = u4.isub(this.m);
        } else if (u4.cmpn(0) < 0) {
          res = u4.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a6, b9) {
        if (a6.isZero() || b9.isZero())
          return new BN2(0)._forceRed(this);
        var t5 = a6.mul(b9);
        var c9 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u4 = t5.isub(c9).iushrn(this.shift);
        var res = u4;
        if (u4.cmp(this.m) >= 0) {
          res = u4.isub(this.m);
        } else if (u4.cmpn(0) < 0) {
          res = u4.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a6) {
        var res = this.imod(a6._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/minimalistic-crypto-utils/lib/utils.js"(exports) {
    "use strict";
    var utils = exports;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i7 = 0; i7 < msg.length; i7++)
          res[i7] = msg[i7] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i7 = 0; i7 < msg.length; i7 += 2)
          res.push(parseInt(msg[i7] + msg[i7 + 1], 16));
      } else {
        for (var i7 = 0; i7 < msg.length; i7++) {
          var c9 = msg.charCodeAt(i7);
          var hi = c9 >> 8;
          var lo = c9 & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex2(msg) {
      var res = "";
      for (var i7 = 0; i7 < msg.length; i7++)
        res += zero2(msg[i7].toString(16));
      return res;
    }
    utils.toHex = toHex2;
    utils.encode = function encode(arr, enc) {
      if (enc === "hex")
        return toHex2(arr);
      else
        return arr;
    };
  }
});

// node_modules/elliptic/lib/elliptic/utils.js
var require_utils3 = __commonJS({
  "node_modules/elliptic/lib/elliptic/utils.js"(exports) {
    "use strict";
    var utils = exports;
    var BN2 = require_bn2();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils2();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w8, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      naf.fill(0);
      var ws = 1 << w8 + 1;
      var k5 = num.clone();
      for (var i7 = 0; i7 < naf.length; i7++) {
        var z4;
        var mod = k5.andln(ws - 1);
        if (k5.isOdd()) {
          if (mod > (ws >> 1) - 1)
            z4 = (ws >> 1) - mod;
          else
            z4 = mod;
          k5.isubn(z4);
        } else {
          z4 = 0;
        }
        naf[i7] = z4;
        k5.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k22) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k22 = k22.clone();
      var d1 = 0;
      var d22 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k22.andln(3) + d22 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u22;
        if ((m24 & 1) === 0) {
          u22 = 0;
        } else {
          m8 = k22.andln(7) + d22 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u22 = -m24;
          else
            u22 = m24;
        }
        jsf[1].push(u22);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d22 === u22 + 1)
          d22 = 1 - d22;
        k1.iushrn(1);
        k22.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN2(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_6, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/brorand/index.js
var require_brorand = __commonJS({
  "node_modules/brorand/index.js"(exports, module) {
    var r2;
    module.exports = function rand(len) {
      if (!r2)
        r2 = new Rand(null);
      return r2.generate(len);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module.exports.Rand = Rand;
    Rand.prototype.generate = function generate(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n3) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n3);
      var res = new Uint8Array(n3);
      for (var i7 = 0; i7 < res.length; i7++)
        res[i7] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n3) {
          var arr = new Uint8Array(n3);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n3) {
          var arr = new Uint8Array(n3);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto = require_crypto();
        if (typeof crypto.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n3) {
          return crypto.randomBytes(n3);
        };
      } catch (e2) {
      }
    }
    var crypto;
  }
});

// node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module) {
    "use strict";
    var BN2 = require_bn2();
    var utils = require_utils3();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN2(conf.p, 16);
      this.red = conf.prime ? BN2.red(conf.prime) : BN2.mont(this.p);
      this.zero = new BN2(0).toRed(this.red);
      this.one = new BN2(1).toRed(this.red);
      this.two = new BN2(2).toRed(this.red);
      this.n = conf.n && new BN2(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate2() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p6, k5) {
      assert(p6.precomputed);
      var doubles = p6._getDoubles();
      var naf = getNAF(k5, 1, this._bitLength);
      var I5 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I5 /= 3;
      var repr = [];
      var j5;
      var nafW;
      for (j5 = 0; j5 < naf.length; j5 += doubles.step) {
        nafW = 0;
        for (var l7 = j5 + doubles.step - 1; l7 >= j5; l7--)
          nafW = (nafW << 1) + naf[l7];
        repr.push(nafW);
      }
      var a6 = this.jpoint(null, null, null);
      var b9 = this.jpoint(null, null, null);
      for (var i7 = I5; i7 > 0; i7--) {
        for (j5 = 0; j5 < repr.length; j5++) {
          nafW = repr[j5];
          if (nafW === i7)
            b9 = b9.mixedAdd(doubles.points[j5]);
          else if (nafW === -i7)
            b9 = b9.mixedAdd(doubles.points[j5].neg());
        }
        a6 = a6.add(b9);
      }
      return a6.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p6, k5) {
      var w8 = 4;
      var nafPoints = p6._getNAFPoints(w8);
      w8 = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k5, w8, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i7 = naf.length - 1; i7 >= 0; i7--) {
        for (var l7 = 0; i7 >= 0 && naf[i7] === 0; i7--)
          l7++;
        if (i7 >= 0)
          l7++;
        acc = acc.dblp(l7);
        if (i7 < 0)
          break;
        var z4 = naf[i7];
        assert(z4 !== 0);
        if (p6.type === "affine") {
          if (z4 > 0)
            acc = acc.mixedAdd(wnd[z4 - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z4 - 1 >> 1].neg());
        } else {
          if (z4 > 0)
            acc = acc.add(wnd[z4 - 1 >> 1]);
          else
            acc = acc.add(wnd[-z4 - 1 >> 1].neg());
        }
      }
      return p6.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i7;
      var j5;
      var p6;
      for (i7 = 0; i7 < len; i7++) {
        p6 = points[i7];
        var nafPoints = p6._getNAFPoints(defW);
        wndWidth[i7] = nafPoints.wnd;
        wnd[i7] = nafPoints.points;
      }
      for (i7 = len - 1; i7 >= 1; i7 -= 2) {
        var a6 = i7 - 1;
        var b9 = i7;
        if (wndWidth[a6] !== 1 || wndWidth[b9] !== 1) {
          naf[a6] = getNAF(coeffs[a6], wndWidth[a6], this._bitLength);
          naf[b9] = getNAF(coeffs[b9], wndWidth[b9], this._bitLength);
          max = Math.max(naf[a6].length, max);
          max = Math.max(naf[b9].length, max);
          continue;
        }
        var comb = [
          points[a6],
          null,
          null,
          points[b9]
        ];
        if (points[a6].y.cmp(points[b9].y) === 0) {
          comb[1] = points[a6].add(points[b9]);
          comb[2] = points[a6].toJ().mixedAdd(points[b9].neg());
        } else if (points[a6].y.cmp(points[b9].y.redNeg()) === 0) {
          comb[1] = points[a6].toJ().mixedAdd(points[b9]);
          comb[2] = points[a6].add(points[b9].neg());
        } else {
          comb[1] = points[a6].toJ().mixedAdd(points[b9]);
          comb[2] = points[a6].toJ().mixedAdd(points[b9].neg());
        }
        var index = [
          -3,
          -1,
          -5,
          -7,
          0,
          7,
          5,
          1,
          3
        ];
        var jsf = getJSF(coeffs[a6], coeffs[b9]);
        max = Math.max(jsf[0].length, max);
        naf[a6] = new Array(max);
        naf[b9] = new Array(max);
        for (j5 = 0; j5 < max; j5++) {
          var ja = jsf[0][j5] | 0;
          var jb = jsf[1][j5] | 0;
          naf[a6][j5] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b9][j5] = 0;
          wnd[a6] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i7 = max; i7 >= 0; i7--) {
        var k5 = 0;
        while (i7 >= 0) {
          var zero = true;
          for (j5 = 0; j5 < len; j5++) {
            tmp[j5] = naf[j5][i7] | 0;
            if (tmp[j5] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k5++;
          i7--;
        }
        if (i7 >= 0)
          k5++;
        acc = acc.dblp(k5);
        if (i7 < 0)
          break;
        for (j5 = 0; j5 < len; j5++) {
          var z4 = tmp[j5];
          p6;
          if (z4 === 0)
            continue;
          else if (z4 > 0)
            p6 = wnd[j5][z4 - 1 >> 1];
          else if (z4 < 0)
            p6 = wnd[j5][-z4 - 1 >> 1].neg();
          if (p6.type === "affine")
            acc = acc.mixedAdd(p6);
          else
            acc = acc.add(p6);
        }
      }
      for (i7 = 0; i7 < len; i7++)
        wnd[i7] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate2() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x6 = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x6);
      return [4].concat(x6, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k5) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k5.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i7 = 0; i7 < power; i7 += step) {
        for (var j5 = 0; j5 < step; j5++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i7 = 1; i7 < max; i7++)
        res[i7] = res[i7 - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k5) {
      var r2 = this;
      for (var i7 = 0; i7 < k5; i7++)
        r2 = r2.dbl();
      return r2;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var BN2 = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN2(conf.a, 16).toRed(this.red);
      this.b = new BN2(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN2(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN2(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN2(vec.a, 16),
            b: new BN2(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN2.mont(num);
      var tinv = new BN2(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s4 = new BN2(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s4).fromRed();
      var l22 = ntinv.redSub(s4).fromRed();
      return [l1, l22];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u4 = lambda;
      var v9 = this.n.clone();
      var x1 = new BN2(1);
      var y1 = new BN2(0);
      var x22 = new BN2(0);
      var y22 = new BN2(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a22;
      var b22;
      var prevR;
      var i7 = 0;
      var r2;
      var x6;
      while (u4.cmpn(0) !== 0) {
        var q5 = v9.div(u4);
        r2 = v9.sub(q5.mul(u4));
        x6 = x22.sub(q5.mul(x1));
        var y4 = y22.sub(q5.mul(y1));
        if (!a1 && r2.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r2.neg();
          b1 = x6;
        } else if (a1 && ++i7 === 2) {
          break;
        }
        prevR = r2;
        v9 = u4;
        u4 = r2;
        x22 = x1;
        x1 = x6;
        y22 = y1;
        y1 = y4;
      }
      a22 = r2.neg();
      b22 = x6;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a22.sqr().add(b22.sqr());
      if (len2.cmp(len1) >= 0) {
        a22 = a0;
        b22 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a22.negative) {
        a22 = a22.neg();
        b22 = b22.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a22, b: b22 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k5) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v22 = basis[1];
      var c1 = v22.b.mul(k5).divRound(this.n);
      var c22 = v1.b.neg().mul(k5).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p22 = c22.mul(v22.a);
      var q1 = c1.mul(v1.b);
      var q22 = c22.mul(v22.b);
      var k1 = k5.sub(p1).sub(p22);
      var k22 = q1.add(q22).neg();
      return { k1, k2: k22 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x6, odd) {
      x6 = new BN2(x6, 16);
      if (!x6.red)
        x6 = x6.toRed(this.red);
      var y22 = x6.redSqr().redMul(x6).redIAdd(x6.redMul(this.a)).redIAdd(this.b);
      var y4 = y22.redSqrt();
      if (y4.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y4.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y4 = y4.redNeg();
      return this.point(x6, y4);
    };
    ShortCurve.prototype.validate = function validate2(point) {
      if (point.inf)
        return true;
      var x6 = point.x;
      var y4 = point.y;
      var ax = this.a.redMul(x6);
      var rhs = x6.redSqr().redMul(x6).redIAdd(ax).redIAdd(this.b);
      return y4.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i7 = 0; i7 < points.length; i7++) {
        var split = this._endoSplit(coeffs[i7]);
        var p6 = points[i7];
        var beta = p6._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p6 = p6.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i7 * 2] = p6;
        npoints[i7 * 2 + 1] = beta;
        ncoeffs[i7 * 2] = split.k1;
        ncoeffs[i7 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i7 * 2, jacobianResult);
      for (var j5 = 0; j5 < i7 * 2; j5++) {
        npoints[j5] = null;
        ncoeffs[j5] = null;
      }
      return res;
    };
    function Point(curve, x6, y4, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x6 === null && y4 === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN2(x6, 16);
        this.y = new BN2(y4, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x6, y4, isRed) {
      return new Point(this, x6, y4, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p6) {
          return curve.point(p6.x.redMul(curve.endo.beta), p6.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect2() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p6) {
      if (this.inf)
        return p6;
      if (p6.inf)
        return this;
      if (this.eq(p6))
        return this.dbl();
      if (this.neg().eq(p6))
        return this.curve.point(null, null);
      if (this.x.cmp(p6.x) === 0)
        return this.curve.point(null, null);
      var c9 = this.y.redSub(p6.y);
      if (c9.cmpn(0) !== 0)
        c9 = c9.redMul(this.x.redSub(p6.x).redInvm());
      var nx = c9.redSqr().redISub(this.x).redISub(p6.x);
      var ny = c9.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a6 = this.curve.a;
      var x22 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c9 = x22.redAdd(x22).redIAdd(x22).redIAdd(a6).redMul(dyinv);
      var nx = c9.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c9.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k5) {
      k5 = new BN2(k5, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k5))
        return this.curve._fixedNafMul(this, k5);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k5]);
      else
        return this.curve._wnafMul(this, k5);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p6) {
      return this === p6 || this.inf === p6.inf && (this.inf || this.x.cmp(p6.x) === 0 && this.y.cmp(p6.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p6) {
          return p6.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x6, y4, z4) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x6 === null && y4 === null && z4 === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN2(0);
      } else {
        this.x = new BN2(x6, 16);
        this.y = new BN2(y4, 16);
        this.z = new BN2(z4, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x6, y4, z4) {
      return new JPoint(this, x6, y4, z4);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p6) {
      if (this.isInfinity())
        return p6;
      if (p6.isInfinity())
        return this;
      var pz2 = p6.z.redSqr();
      var z22 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u22 = p6.x.redMul(z22);
      var s1 = this.y.redMul(pz2.redMul(p6.z));
      var s22 = p6.y.redMul(z22.redMul(this.z));
      var h5 = u1.redSub(u22);
      var r2 = s1.redSub(s22);
      if (h5.cmpn(0) === 0) {
        if (r2.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h5.redSqr();
      var h32 = h22.redMul(h5);
      var v9 = u1.redMul(h22);
      var nx = r2.redSqr().redIAdd(h32).redISub(v9).redISub(v9);
      var ny = r2.redMul(v9.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(p6.z).redMul(h5);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p6) {
      if (this.isInfinity())
        return p6.toJ();
      if (p6.isInfinity())
        return this;
      var z22 = this.z.redSqr();
      var u1 = this.x;
      var u22 = p6.x.redMul(z22);
      var s1 = this.y;
      var s22 = p6.y.redMul(z22).redMul(this.z);
      var h5 = u1.redSub(u22);
      var r2 = s1.redSub(s22);
      if (h5.cmpn(0) === 0) {
        if (r2.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h5.redSqr();
      var h32 = h22.redMul(h5);
      var v9 = u1.redMul(h22);
      var nx = r2.redSqr().redIAdd(h32).redISub(v9).redISub(v9);
      var ny = r2.redMul(v9.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(h5);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i7;
      if (this.curve.zeroA || this.curve.threeA) {
        var r2 = this;
        for (i7 = 0; i7 < pow; i7++)
          r2 = r2.dbl();
        return r2;
      }
      var a6 = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i7 = 0; i7 < pow; i7++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c9 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a6.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c9.redSqr().redISub(t1.redAdd(t1));
        var t22 = t1.redISub(nx);
        var dny = c9.redMul(t22);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i7 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s4 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s4 = s4.redIAdd(s4);
        var m4 = xx.redAdd(xx).redIAdd(xx);
        var t5 = m4.redSqr().redISub(s4).redISub(s4);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t5;
        ny = m4.redMul(s4.redISub(t5)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a6 = this.x.redSqr();
        var b9 = this.y.redSqr();
        var c9 = b9.redSqr();
        var d3 = this.x.redAdd(b9).redSqr().redISub(a6).redISub(c9);
        d3 = d3.redIAdd(d3);
        var e2 = a6.redAdd(a6).redIAdd(a6);
        var f6 = e2.redSqr();
        var c82 = c9.redIAdd(c9);
        c82 = c82.redIAdd(c82);
        c82 = c82.redIAdd(c82);
        nx = f6.redISub(d3).redISub(d3);
        ny = e2.redMul(d3.redISub(nx)).redISub(c82);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s4 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s4 = s4.redIAdd(s4);
        var m4 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t5 = m4.redSqr().redISub(s4).redISub(s4);
        nx = t5;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m4.redMul(s4.redISub(t5)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a6 = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c9 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a6.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c9.redSqr().redISub(t1.redAdd(t1));
      var t22 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c9.redMul(t22).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m4 = xx.redAdd(xx).redIAdd(xx);
      var mm = m4.redSqr();
      var e2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e2 = e2.redIAdd(e2);
      e2 = e2.redAdd(e2).redIAdd(e2);
      e2 = e2.redISub(mm);
      var ee3 = e2.redSqr();
      var t5 = yyyy.redIAdd(yyyy);
      t5 = t5.redIAdd(t5);
      t5 = t5.redIAdd(t5);
      t5 = t5.redIAdd(t5);
      var u4 = m4.redIAdd(e2).redSqr().redISub(mm).redISub(ee3).redISub(t5);
      var yyu4 = yy.redMul(u4);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee3).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u4.redMul(t5.redISub(u4)).redISub(e2.redMul(ee3)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e2).redSqr().redISub(zz).redISub(ee3);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k5, kbase) {
      k5 = new BN2(k5, kbase);
      return this.curve._wnafMul(this, k5);
    };
    JPoint.prototype.eq = function eq(p6) {
      if (p6.type === "affine")
        return this.eq(p6.toJ());
      if (this === p6)
        return true;
      var z22 = this.z.redSqr();
      var pz2 = p6.z.redSqr();
      if (this.x.redMul(pz2).redISub(p6.x.redMul(z22)).cmpn(0) !== 0)
        return false;
      var z32 = z22.redMul(this.z);
      var pz3 = pz2.redMul(p6.z);
      return this.y.redMul(pz3).redISub(p6.y.redMul(z32)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x6) {
      var zs = this.z.redSqr();
      var rx = x6.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x6.clone();
      var t5 = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t5);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect2() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module) {
    "use strict";
    var BN2 = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var utils = require_utils3();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN2(conf.a, 16).toRed(this.red);
      this.b = new BN2(conf.b, 16).toRed(this.red);
      this.i4 = new BN2(4).toRed(this.red).redInvm();
      this.two = new BN2(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate = function validate2(point) {
      var x6 = point.normalize().x;
      var x22 = x6.redSqr();
      var rhs = x22.redMul(x6).redAdd(x22.redMul(this.a)).redAdd(x6);
      var y4 = rhs.redSqrt();
      return y4.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x6, z4) {
      Base.BasePoint.call(this, curve, "projective");
      if (x6 === null && z4 === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN2(x6, 16);
        this.z = new BN2(z4, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x6, z4) {
      return new Point(this, x6, z4);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect2() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a6 = this.x.redAdd(this.z);
      var aa = a6.redSqr();
      var b9 = this.x.redSub(this.z);
      var bb = b9.redSqr();
      var c9 = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c9.redMul(bb.redAdd(this.curve.a24.redMul(c9)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p6, diff) {
      var a6 = this.x.redAdd(this.z);
      var b9 = this.x.redSub(this.z);
      var c9 = p6.x.redAdd(p6.z);
      var d3 = p6.x.redSub(p6.z);
      var da = d3.redMul(a6);
      var cb = c9.redMul(b9);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k5) {
      var t5 = k5.clone();
      var a6 = this;
      var b9 = this.curve.point(null, null);
      var c9 = this;
      for (var bits = []; t5.cmpn(0) !== 0; t5.iushrn(1))
        bits.push(t5.andln(1));
      for (var i7 = bits.length - 1; i7 >= 0; i7--) {
        if (bits[i7] === 0) {
          a6 = a6.diffAdd(b9, c9);
          b9 = b9.dbl();
        } else {
          b9 = a6.diffAdd(b9, c9);
          a6 = a6.dbl();
        }
      }
      return b9;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize2() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var BN2 = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN2(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN2(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN2(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x6, y4, z4, t5) {
      return this.point(x6, y4, z4, t5);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x6, odd) {
      x6 = new BN2(x6, 16);
      if (!x6.red)
        x6 = x6.toRed(this.red);
      var x22 = x6.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x22));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
      var y22 = rhs.redMul(lhs.redInvm());
      var y4 = y22.redSqrt();
      if (y4.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y4.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y4 = y4.redNeg();
      return this.point(x6, y4);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y4, odd) {
      y4 = new BN2(y4, 16);
      if (!y4.red)
        y4 = y4.toRed(this.red);
      var y22 = y4.redSqr();
      var lhs = y22.redSub(this.c2);
      var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x22 = lhs.redMul(rhs.redInvm());
      if (x22.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y4);
      }
      var x6 = x22.redSqrt();
      if (x6.redSqr().redSub(x22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x6.fromRed().isOdd() !== odd)
        x6 = x6.redNeg();
      return this.point(x6, y4);
    };
    EdwardsCurve.prototype.validate = function validate2(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x22 = point.x.redSqr();
      var y22 = point.y.redSqr();
      var lhs = x22.redMul(this.a).redAdd(y22);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x22).redMul(y22)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x6, y4, z4, t5) {
      Base.BasePoint.call(this, curve, "projective");
      if (x6 === null && y4 === null && z4 === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN2(x6, 16);
        this.y = new BN2(y4, 16);
        this.z = z4 ? new BN2(z4, 16) : this.curve.one;
        this.t = t5 && new BN2(t5, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x6, y4, z4, t5) {
      return new Point(this, x6, y4, z4, t5);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect2() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a6 = this.x.redSqr();
      var b9 = this.y.redSqr();
      var c9 = this.z.redSqr();
      c9 = c9.redIAdd(c9);
      var d3 = this.curve._mulA(a6);
      var e2 = this.x.redAdd(this.y).redSqr().redISub(a6).redISub(b9);
      var g4 = d3.redAdd(b9);
      var f6 = g4.redSub(c9);
      var h5 = d3.redSub(b9);
      var nx = e2.redMul(f6);
      var ny = g4.redMul(h5);
      var nt = e2.redMul(h5);
      var nz = f6.redMul(g4);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b9 = this.x.redAdd(this.y).redSqr();
      var c9 = this.x.redSqr();
      var d3 = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e2;
      var h5;
      var j5;
      if (this.curve.twisted) {
        e2 = this.curve._mulA(c9);
        var f6 = e2.redAdd(d3);
        if (this.zOne) {
          nx = b9.redSub(c9).redSub(d3).redMul(f6.redSub(this.curve.two));
          ny = f6.redMul(e2.redSub(d3));
          nz = f6.redSqr().redSub(f6).redSub(f6);
        } else {
          h5 = this.z.redSqr();
          j5 = f6.redSub(h5).redISub(h5);
          nx = b9.redSub(c9).redISub(d3).redMul(j5);
          ny = f6.redMul(e2.redSub(d3));
          nz = f6.redMul(j5);
        }
      } else {
        e2 = c9.redAdd(d3);
        h5 = this.curve._mulC(this.z).redSqr();
        j5 = e2.redSub(h5).redSub(h5);
        nx = this.curve._mulC(b9.redISub(e2)).redMul(j5);
        ny = this.curve._mulC(e2).redMul(c9.redISub(d3));
        nz = e2.redMul(j5);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p6) {
      var a6 = this.y.redSub(this.x).redMul(p6.y.redSub(p6.x));
      var b9 = this.y.redAdd(this.x).redMul(p6.y.redAdd(p6.x));
      var c9 = this.t.redMul(this.curve.dd).redMul(p6.t);
      var d3 = this.z.redMul(p6.z.redAdd(p6.z));
      var e2 = b9.redSub(a6);
      var f6 = d3.redSub(c9);
      var g4 = d3.redAdd(c9);
      var h5 = b9.redAdd(a6);
      var nx = e2.redMul(f6);
      var ny = g4.redMul(h5);
      var nt = e2.redMul(h5);
      var nz = f6.redMul(g4);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projAdd = function _projAdd(p6) {
      var a6 = this.z.redMul(p6.z);
      var b9 = a6.redSqr();
      var c9 = this.x.redMul(p6.x);
      var d3 = this.y.redMul(p6.y);
      var e2 = this.curve.d.redMul(c9).redMul(d3);
      var f6 = b9.redSub(e2);
      var g4 = b9.redAdd(e2);
      var tmp = this.x.redAdd(this.y).redMul(p6.x.redAdd(p6.y)).redISub(c9).redISub(d3);
      var nx = a6.redMul(f6).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a6.redMul(g4).redMul(d3.redSub(this.curve._mulA(c9)));
        nz = f6.redMul(g4);
      } else {
        ny = a6.redMul(g4).redMul(d3.redSub(c9));
        nz = this.curve._mulC(f6).redMul(g4);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p6) {
      if (this.isInfinity())
        return p6;
      if (p6.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p6);
      else
        return this._projAdd(p6);
    };
    Point.prototype.mul = function mul(k5) {
      if (this._hasDoubles(k5))
        return this.curve._fixedNafMul(this, k5);
      else
        return this.curve._wnafMul(this, k5);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p6, k22) {
      return this.curve._wnafMulAdd(1, [this, p6], [k1, k22], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p6, k22) {
      return this.curve._wnafMulAdd(1, [this, p6], [k1, k22], 2, true);
    };
    Point.prototype.normalize = function normalize2() {
      if (this.zOne)
        return this;
      var zi = this.z.redInvm();
      this.x = this.x.redMul(zi);
      this.y = this.y.redMul(zi);
      if (this.t)
        this.t = this.t.redMul(zi);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x6) {
      var rx = x6.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x6.clone();
      var t5 = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t5);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
    "use strict";
    var curve = exports;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module) {
    module.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "node_modules/elliptic/lib/elliptic/curves.js"(exports) {
    "use strict";
    var curves = exports;
    var hash2 = require_hash();
    var curve = require_curve();
    var utils = require_utils3();
    var assert = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert(this.g.validate(), "Invalid curve");
      assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash2.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash2.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e2) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash2.sha256,
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "node_modules/hmac-drbg/lib/hmac-drbg.js"(exports, module) {
    "use strict";
    var hash2 = require_hash();
    var utils = require_utils2();
    var assert = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._init(entropy, nonce, pers);
    }
    module.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i7 = 0; i7 < this.V.length; i7++) {
        this.K[i7] = 0;
        this.V[i7] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
      return new hash2.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils.toArray(entropy, entropyEnc);
      add = utils.toArray(add, addEnc);
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
      }
      if (add) {
        add = utils.toArray(add, addEnc || "hex");
        this._update(add);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add);
      this._reseed++;
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module) {
    "use strict";
    var BN2 = require_bn2();
    var utils = require_utils3();
    var assert = utils.assert;
    function KeyPair(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate2() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN2(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature) {
      return this.ec.verify(msg, signature, this);
    };
    KeyPair.prototype.inspect = function inspect2() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module) {
    "use strict";
    var BN2 = require_bn2();
    var utils = require_utils3();
    var assert = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert(options.r && options.s, "Signature without r or s");
      this.r = new BN2(options.r, 16);
      this.s = new BN2(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p6) {
      var initial = buf[p6.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      var val = 0;
      for (var i7 = 0, off = p6.place; i7 < octetLen; i7++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p6.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i7 = 0;
      var len = buf.length - 1;
      while (!buf[i7] && !(buf[i7 + 1] & 128) && i7 < len) {
        i7++;
      }
      if (i7 === 0) {
        return buf;
      }
      return buf.slice(i7);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p6 = new Position();
      if (data[p6.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p6);
      if (len === false) {
        return false;
      }
      if (len + p6.place !== data.length) {
        return false;
      }
      if (data[p6.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p6);
      if (rlen === false) {
        return false;
      }
      var r2 = data.slice(p6.place, rlen + p6.place);
      p6.place += rlen;
      if (data[p6.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p6);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p6.place) {
        return false;
      }
      var s4 = data.slice(p6.place, slen + p6.place);
      if (r2[0] === 0) {
        if (r2[1] & 128) {
          r2 = r2.slice(1);
        } else {
          return false;
        }
      }
      if (s4[0] === 0) {
        if (s4[1] & 128) {
          s4 = s4.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN2(r2);
      this.s = new BN2(s4);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r2 = this.r.toArray();
      var s4 = this.s.toArray();
      if (r2[0] & 128)
        r2 = [0].concat(r2);
      if (s4[0] & 128)
        s4 = [0].concat(s4);
      r2 = rmPadding(r2);
      s4 = rmPadding(s4);
      while (!s4[0] && !(s4[1] & 128)) {
        s4 = s4.slice(1);
      }
      var arr = [2];
      constructLength(arr, r2.length);
      arr = arr.concat(r2);
      arr.push(2);
      constructLength(arr, s4.length);
      var backHalf = arr.concat(s4);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module) {
    "use strict";
    var BN2 = require_bn2();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils3();
    var curves = require_curves();
    var rand = require_brorand();
    var assert = utils.assert;
    var KeyPair = require_key();
    var Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN2(2));
      for (; ; ) {
        var priv = new BN2(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(new BN2(msg, 16));
      var bytes = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN2(1));
      for (var iter = 0; ; iter++) {
        var k5 = options.k ? options.k(iter) : new BN2(drbg.generate(this.n.byteLength()));
        k5 = this._truncateToN(k5, true);
        if (k5.cmpn(1) <= 0 || k5.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k5);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r2 = kpX.umod(this.n);
        if (r2.cmpn(0) === 0)
          continue;
        var s4 = k5.invm(this.n).mul(r2.mul(key.getPrivate()).iadd(msg));
        s4 = s4.umod(this.n);
        if (s4.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
        if (options.canonical && s4.cmp(this.nh) > 0) {
          s4 = this.n.sub(s4);
          recoveryParam ^= 1;
        }
        return new Signature({ r: r2, s: s4, recoveryParam });
      }
    };
    EC.prototype.verify = function verify(msg, signature, key, enc) {
      msg = this._truncateToN(new BN2(msg, 16));
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r2 = signature.r;
      var s4 = signature.s;
      if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
        return false;
      if (s4.cmpn(1) < 0 || s4.cmp(this.n) >= 0)
        return false;
      var sinv = s4.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u22 = sinv.mul(r2).umod(this.n);
      var p6;
      if (!this.curve._maxwellTrick) {
        p6 = this.g.mulAdd(u1, key.getPublic(), u22);
        if (p6.isInfinity())
          return false;
        return p6.getX().umod(this.n).cmp(r2) === 0;
      }
      p6 = this.g.jmulAdd(u1, key.getPublic(), u22);
      if (p6.isInfinity())
        return false;
      return p6.eqXToP(r2);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j5, enc) {
      assert((3 & j5) === j5, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n3 = this.n;
      var e2 = new BN2(msg);
      var r2 = signature.r;
      var s4 = signature.s;
      var isYOdd = j5 & 1;
      var isSecondKey = j5 >> 1;
      if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
      else
        r2 = this.curve.pointFromX(r2, isYOdd);
      var rInv = signature.r.invm(n3);
      var s1 = n3.sub(e2).mul(rInv).umod(n3);
      var s22 = s4.mul(rInv).umod(n3);
      return this.g.mulAdd(s1, r2, s22);
    };
    EC.prototype.getKeyRecoveryParam = function(e2, signature, Q5, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i7 = 0; i7 < 4; i7++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e2, signature, i7);
        } catch (e3) {
          continue;
        }
        if (Qprime.eq(Q5))
          return i7;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash2 = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a6 = hash2.slice(0, eddsa.encodingLength);
      a6[0] &= 248;
      a6[lastIx] &= 127;
      a6[lastIx] |= 64;
      return a6;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash2() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign(message) {
      assert(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module.exports = KeyPair;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module) {
    "use strict";
    var BN2 = require_bn2();
    var utils = require_utils3();
    var assert = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN2)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S9() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R5() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex2() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module.exports = Signature;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module) {
    "use strict";
    var hash2 = require_hash();
    var curves = require_curves();
    var utils = require_utils3();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash2.sha512;
    }
    module.exports = EDDSA;
    EDDSA.prototype.sign = function sign(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r2 = this.hashInt(key.messagePrefix(), message);
      var R5 = this.g.mul(r2);
      var Rencoded = this.encodePoint(R5);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S9 = r2.add(s_).umod(this.curve.n);
      return this.makeSignature({ R: R5, S: S9, Rencoded });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      var key = this.keyFromPublic(pub);
      var h5 = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h5));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash3 = this.hash();
      for (var i7 = 0; i7 < arguments.length; i7++)
        hash3.update(arguments[i7]);
      return utils.intFromLE(hash3.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y4 = utils.intFromLE(normed);
      return this.curve.pointFromY(y4, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "node_modules/elliptic/lib/elliptic.js"(exports) {
    "use strict";
    var elliptic = exports;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils3();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// node_modules/@ethersproject/logger/lib.esm/_version.js
var version = "logger/5.7.0";

// node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors = false;
var _censorErrors = false;
var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel = LogLevels["default"];
var _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel2) {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
var HEX = "0123456789abcdef";
var Logger = class {
  constructor(version8) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version8,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key) => {
      const value = params[key];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i7 = 0; i7 < value.length; i7++) {
            hex += HEX[value[i7] >> 4];
            hex += HEX[value[i7] & 15];
          }
          messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key) {
      error[key] = params[key];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name, value) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(version);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version8) {
    return new Logger(version8);
  }
};
Logger.errors = ErrorCode;
Logger.levels = LogLevel;

// node_modules/@ethersproject/bytes/lib.esm/_version.js
var version2 = "bytes/5.7.0";

// node_modules/@ethersproject/bytes/lib.esm/index.js
var logger = new Logger(version2);
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes(value);
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i7 = 0; i7 < value.length; i7++) {
    const v9 = value[i7];
    if (!isInteger(v9) || v9 < 0 || v9 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i7 = 0; i7 < hex.length; i7 += 2) {
      result.push(parseInt(hex.substring(i7, i7 + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
  const objects = items.map((item) => arrayify(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice(result);
}
function stripZeros(value) {
  let result = arrayify(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad(value, length) {
  value = arrayify(value);
  if (value.length > length) {
    logger.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice(result);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes(value)) {
    let result = "0x";
    for (let i7 = 0; i7 < value.length; i7++) {
      let v9 = value[i7];
      result += HexCharacters[(v9 & 240) >> 4] + HexCharacters[v9 & 15];
    }
    return result;
  }
  return logger.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    logger.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify(item).substring(2);
  });
  return result;
}
function hexValue(value) {
  const trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify(value);
  }
  if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset = 0;
  while (offset < value.length && value[offset] === "0") {
    offset++;
  }
  return "0x" + value.substring(offset);
}
function hexZeroPad(value, length) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature(signature) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature)) {
    let bytes = arrayify(signature);
    if (bytes.length === 64) {
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 127;
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger.throwArgumentError("invalid signature string", "signature", signature);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger.throwArgumentError("signature invalid v byte", "signature", signature);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify(bytes.slice(32, 64));
  } else {
    result.r = signature.r;
    result.s = signature.s;
    result.v = signature.v;
    result.recoveryParam = signature.recoveryParam;
    result._vs = signature._vs;
    if (result._vs != null) {
      const vs2 = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature);
      }
      vs2[0] &= 127;
      const s4 = hexlify(vs2);
      if (result.s == null) {
        result.s = s4;
      } else if (result.s !== s4) {
        logger.throwArgumentError("signature v mismatch _vs", "signature", signature);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature);
        }
      }
    }
    if (result.r == null || !isHexString(result.r)) {
      logger.throwArgumentError("signature missing or invalid r", "signature", signature);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString(result.s)) {
      logger.throwArgumentError("signature missing or invalid s", "signature", signature);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs = arrayify(result.s);
    if (vs[0] >= 128) {
      logger.throwArgumentError("signature s out of range", "signature", signature);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify(vs);
    if (result._vs) {
      if (!isHexString(result._vs)) {
        logger.throwArgumentError("signature invalid _vs", "signature", signature);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}
function joinSignature(signature) {
  signature = splitSignature(signature);
  return hexlify(concat([
    signature.r,
    signature.s,
    signature.recoveryParam ? "0x1c" : "0x1b"
  ]));
}

// node_modules/@fuel-ts/math/dist/index.mjs
var import_bn = __toESM(require_bn(), 1);
var c = 3;
var B = 1;
var f = 9;
function I(o4, t5) {
  let { precision: r2 = 3, minPrecision: e2 = 1 } = t5 || {}, [s4 = "0", u4 = "0"] = String(o4 || "0.0").split("."), p6 = /(\d)(?=(\d{3})+\b)/g, m4 = s4.replace(p6, "$1,"), a6 = u4.slice(0, r2);
  if (e2 < r2) {
    let d3 = a6.match(/.*[1-9]{1}/), h5 = (d3 == null ? void 0 : d3[0].length) || 0, y4 = Math.max(e2, h5);
    a6 = a6.slice(0, y4);
  }
  let b9 = a6 ? `.${a6}` : "";
  return `${m4}${b9}`;
}
var n = class extends import_bn.default {
  constructor(t5, r2, e2) {
    if (n.isBN(t5)) {
      super(t5.toArray(), r2, e2);
      return;
    }
    if (typeof t5 == "string" && t5.slice(0, 2) === "0x") {
      super(t5.substring(2), r2 || "hex", e2);
      return;
    }
    let s4 = t5 == null ? 0 : t5;
    super(s4, r2, e2);
  }
  toString(t5, r2) {
    let e2 = super.toString(t5, r2);
    return t5 === 16 || t5 === "hex" ? `0x${e2}` : e2;
  }
  toHex(t5) {
    let e2 = (t5 || 0) * 2;
    if (this.isNeg())
      throw new Error("cannot convert negative value to hex");
    if (t5 && this.byteLength() > t5)
      throw new Error(`value ${this} exceeds bytes ${t5}`);
    return this.toString(16, e2);
  }
  toBytes(t5) {
    if (this.isNeg())
      throw new Error("cannot convert negative value to Bytes");
    return Uint8Array.from(this.toArray(void 0, t5));
  }
  toJSON() {
    return this.toString(16);
  }
  valueOf() {
    return this.toString();
  }
  format(t5) {
    let { units: r2 = 9, precision: e2 = 3, minPrecision: s4 = 1 } = t5 || {}, u4 = this.formatUnits(r2), p6 = I(u4, { precision: e2, minPrecision: s4 });
    if (!parseFloat(p6)) {
      let [, m4 = "0"] = u4.split("."), a6 = m4.match(/[1-9]/);
      if (a6 && a6.index && a6.index + 1 > e2) {
        let [b9 = "0"] = p6.split(".");
        return `${b9}.${m4.slice(0, a6.index + 1)}`;
      }
    }
    return p6;
  }
  formatUnits(t5 = 9) {
    let r2 = this.toString().slice(0, t5 * -1), e2 = this.toString().slice(t5 * -1), s4 = e2.length, u4 = Array.from({ length: t5 - s4 }).fill("0").join("");
    return `${r2 ? `${r2}.` : "0."}${u4}${e2}`;
  }
  add(t5) {
    return this.caller(t5, "add");
  }
  pow(t5) {
    return this.caller(t5, "pow");
  }
  sub(t5) {
    return this.caller(t5, "sub");
  }
  div(t5) {
    return this.caller(t5, "div");
  }
  mul(t5) {
    return this.caller(t5, "mul");
  }
  mod(t5) {
    return this.caller(t5, "mod");
  }
  divRound(t5) {
    return this.caller(t5, "divRound");
  }
  lt(t5) {
    return this.caller(t5, "lt");
  }
  lte(t5) {
    return this.caller(t5, "lte");
  }
  gt(t5) {
    return this.caller(t5, "gt");
  }
  gte(t5) {
    return this.caller(t5, "gte");
  }
  eq(t5) {
    return this.caller(t5, "eq");
  }
  cmp(t5) {
    return this.caller(t5, "cmp");
  }
  sqr() {
    return new n(super.sqr().toArray());
  }
  neg() {
    return new n(super.neg().toArray());
  }
  abs() {
    return new n(super.abs().toArray());
  }
  toTwos(t5) {
    return new n(super.toTwos(t5).toArray());
  }
  fromTwos(t5) {
    return new n(super.fromTwos(t5).toArray());
  }
  caller(t5, r2) {
    let e2 = super[r2](new n(t5));
    return n.isBN(e2) ? new n(e2.toArray()) : e2;
  }
  clone() {
    return new n(this.toArray());
  }
  mulTo(t5, r2) {
    let e2 = new import_bn.default(this.toArray()).mulTo(t5, r2);
    return new n(e2.toArray());
  }
  egcd(t5) {
    let { a: r2, b: e2, gcd: s4 } = new import_bn.default(this.toArray()).egcd(t5);
    return { a: new n(r2.toArray()), b: new n(e2.toArray()), gcd: new n(s4.toArray()) };
  }
  divmod(t5, r2, e2) {
    let { div: s4, mod: u4 } = new import_bn.default(this.toArray()).divmod(new n(t5), r2, e2);
    return { div: new n(s4 == null ? void 0 : s4.toArray()), mod: new n(u4 == null ? void 0 : u4.toArray()) };
  }
};
var i = (o4, t5, r2) => new n(o4, t5, r2);
i.parseUnits = (o4, t5 = 9) => {
  let r2 = o4 === "." ? "0." : o4, [e2 = "0", s4 = "0"] = r2.split("."), u4 = s4.length;
  if (u4 > t5)
    throw new Error("Decimal can't be bigger than the units");
  let p6 = Array.from({ length: t5 }).fill("0");
  p6.splice(0, u4, s4);
  let m4 = `${e2.replace(",", "")}${p6.join("")}`;
  return i(m4);
};
function F(o4) {
  return i(o4).toNumber();
}
function S(o4, t5) {
  return i(o4).toHex(t5);
}
function R(o4, t5) {
  return i(o4).toBytes(t5);
}
function O(o4, t5) {
  return i(o4).formatUnits(t5);
}
function $(o4, t5) {
  return i(o4).format(t5);
}
function L(...o4) {
  return o4.reduce((t5, r2) => i(r2).gt(t5) ? i(r2) : t5, i(0));
}
function H(...o4) {
  return i(Math.ceil(o4.reduce((t5, r2) => i(t5).mul(r2), i(1)).toNumber()));
}

// node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var import_bn2 = __toESM(require_bn());

// node_modules/@ethersproject/bignumber/lib.esm/_version.js
var version3 = "bignumber/5.7.0";

// node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN = import_bn2.default.BN;
var logger2 = new Logger(version3);
var _constructorGuard = {};
var MAX_SAFE = 9007199254740991;
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes(value));
}
var _warnedToStringRadix = false;
var BigNumber = class {
  constructor(constructorGuard, hex) {
    if (constructorGuard !== _constructorGuard) {
      logger2.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber(toBN(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber(toBN(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }
  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }
  div(other) {
    const o4 = BigNumber.from(other);
    if (o4.isZero()) {
      throwFault("division-by-zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  }
  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }
  mod(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("division-by-zero", "mod");
    }
    return toBigNumber(toBN(this).umod(value));
  }
  pow(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("negative-power", "pow");
    }
    return toBigNumber(toBN(this).pow(value));
  }
  and(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "and");
    }
    return toBigNumber(toBN(this).and(value));
  }
  or(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "or");
    }
    return toBigNumber(toBN(this).or(value));
  }
  xor(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "xor");
    }
    return toBigNumber(toBN(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "mask");
    }
    return toBigNumber(toBN(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "shl");
    }
    return toBigNumber(toBN(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "shr");
    }
    return toBigNumber(toBN(this).shrn(value));
  }
  eq(other) {
    return toBN(this).eq(toBN(other));
  }
  lt(other) {
    return toBN(this).lt(toBN(other));
  }
  lte(other) {
    return toBN(this).lte(toBN(other));
  }
  gt(other) {
    return toBN(this).gt(toBN(other));
  }
  gte(other) {
    return toBN(this).gte(toBN(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error) {
      throwFault("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e2) {
    }
    return logger2.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger2.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger2.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger2.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber(_constructorGuard, toHex(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber(_constructorGuard, toHex(new BN(value)));
      }
      return logger2.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault("overflow", "BigNumber.from", value);
      }
      return BigNumber.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber.from(anyValue.toString());
    }
    if (isBytes(anyValue)) {
      return BigNumber.from(hexlify(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString(hex) || hex[0] === "-" && isHexString(hex.substring(1))) {
            return BigNumber.from(hex);
          }
        }
      }
    }
    return logger2.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex(value) {
  if (typeof value !== "string") {
    return toHex(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger2.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex(value));
}
function toBN(value) {
  const hex = BigNumber.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN("-" + hex.substring(3), 16);
  }
  return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger2.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}

// node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
var logger3 = new Logger(version3);
var _constructorGuard2 = {};
var Zero = BigNumber.from(0);
var NegativeOne = BigNumber.from(-1);
function throwFault2(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger3.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
var zeros = "0";
while (zeros.length < 256) {
  zeros += zeros;
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e2) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger3.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber.from(value);
  const negative = value.lt(Zero);
  if (negative) {
    value = value.mul(NegativeOne);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger3.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger3.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger3.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault2("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne);
  }
  return wei;
}
var FixedFormat = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard2) {
      logger3.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger3.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key, type, defaultValue) => {
        if (value[key] == null) {
          return defaultValue;
        }
        if (typeof value[key] !== type) {
          logger3.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
        }
        return value[key];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger3.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger3.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat(_constructorGuard2, signed, width, decimals);
  }
};
var FixedNumber = class {
  constructor(constructorGuard, hex, value, format) {
    if (constructorGuard !== _constructorGuard2) {
      logger3.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger3.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a6 = parseFixed(this._value, this.format.decimals);
    const b9 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a6.add(b9), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a6 = parseFixed(this._value, this.format.decimals);
    const b9 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a6.sub(b9), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a6 = parseFixed(this._value, this.format.decimals);
    const b9 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a6.mul(b9).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a6 = parseFixed(this._value, this.format.decimals);
    const b9 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a6.mul(this.format._multiplier).div(b9), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger3.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
    const bump = BUMP.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger3.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    const numeric = parseFixed(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero)) {
      throwFault2("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    if (arrayify(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber.fromString(value, format);
    }
    if (isBytes(value)) {
      return FixedNumber.fromBytes(value, format);
    }
    try {
      return FixedNumber.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger3.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE = FixedNumber.from(1);
var BUMP = FixedNumber.from("0.5");

// node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var NegativeOne2 = BigNumber.from(-1);
var Zero2 = BigNumber.from(0);
var One = BigNumber.from(1);
var Two = BigNumber.from(2);
var WeiPerEther = BigNumber.from("1000000000000000000");
var MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt256 = BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt256 = BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/@ethersproject/strings/lib.esm/_version.js
var version4 = "strings/5.7.0";

// node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger4 = new Logger(version4);
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm2) {
  UnicodeNormalizationForm2["current"] = "";
  UnicodeNormalizationForm2["NFC"] = "NFC";
  UnicodeNormalizationForm2["NFD"] = "NFD";
  UnicodeNormalizationForm2["NFKC"] = "NFKC";
  UnicodeNormalizationForm2["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason2) {
  Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason2["OVERRUN"] = "string overrun";
  Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason2["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes, output, badCodepoint) {
  return logger4.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i7 = 0;
    for (let o4 = offset + 1; o4 < bytes.length; o4++) {
      if (bytes[o4] >> 6 !== 2) {
        break;
      }
      i7++;
    }
    return i7;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
var Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes = arrayify(bytes);
  const result = [];
  let i7 = 0;
  while (i7 < bytes.length) {
    const c9 = bytes[i7++];
    if (c9 >> 7 === 0) {
      result.push(c9);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c9 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c9 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c9 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c9 & 192) === 128) {
        i7 += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i7 - 1, bytes, result);
      } else {
        i7 += onError(Utf8ErrorReason.BAD_PREFIX, i7 - 1, bytes, result);
      }
      continue;
    }
    if (i7 - 1 + extraLength >= bytes.length) {
      i7 += onError(Utf8ErrorReason.OVERRUN, i7 - 1, bytes, result);
      continue;
    }
    let res = c9 & (1 << 8 - extraLength - 1) - 1;
    for (let j5 = 0; j5 < extraLength; j5++) {
      let nextChar = bytes[i7];
      if ((nextChar & 192) != 128) {
        i7 += onError(Utf8ErrorReason.MISSING_CONTINUE, i7, bytes, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i7++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i7 += onError(Utf8ErrorReason.OUT_OF_RANGE, i7 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i7 += onError(Utf8ErrorReason.UTF16_SURROGATE, i7 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i7 += onError(Utf8ErrorReason.OVERLONG, i7 - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger4.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i7 = 0; i7 < str.length; i7++) {
    const c9 = str.charCodeAt(i7);
    if (c9 < 128) {
      result.push(c9);
    } else if (c9 < 2048) {
      result.push(c9 >> 6 | 192);
      result.push(c9 & 63 | 128);
    } else if ((c9 & 64512) == 55296) {
      i7++;
      const c22 = str.charCodeAt(i7);
      if (i7 >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c9 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c9 >> 12 | 224);
      result.push(c9 >> 6 & 63 | 128);
      result.push(c9 & 63 | 128);
    }
  }
  return arrayify(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes, onError));
}

// node_modules/@ethersproject/strings/lib.esm/idna.js
function bytes2(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i7 = 0; i7 < data.length; i7 += 4) {
    result.push(parseInt(data.substring(i7, i7 + 4), 16));
  }
  return result;
}
function createTable(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable(data) {
  let hi = 0;
  return data.split(",").map((v9) => {
    let comps = v9.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
var Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v9) => parseInt(v9, 16));
var Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
var Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

// node_modules/@ethersproject/properties/lib.esm/_version.js
var version5 = "properties/5.7.0";

// node_modules/@ethersproject/properties/lib.esm/index.js
var logger5 = new Logger(version5);
function defineReadOnly(object, name, value) {
  Object.defineProperty(object, name, {
    enumerable: true,
    value,
    writable: false
  });
}

// node_modules/@ethersproject/sha2/lib.esm/sha2.js
var import_hash = __toESM(require_hash());

// node_modules/@ethersproject/sha2/lib.esm/types.js
var SupportedAlgorithm;
(function(SupportedAlgorithm2) {
  SupportedAlgorithm2["sha256"] = "sha256";
  SupportedAlgorithm2["sha512"] = "sha512";
})(SupportedAlgorithm || (SupportedAlgorithm = {}));

// node_modules/@ethersproject/sha2/lib.esm/_version.js
var version6 = "sha2/5.7.0";

// node_modules/@ethersproject/sha2/lib.esm/sha2.js
var logger6 = new Logger(version6);
function ripemd160(data) {
  return "0x" + import_hash.default.ripemd160().update(arrayify(data)).digest("hex");
}
function sha256(data) {
  return "0x" + import_hash.default.sha256().update(arrayify(data)).digest("hex");
}
function computeHmac(algorithm, key, data) {
  if (!SupportedAlgorithm[algorithm]) {
    logger6.throwError("unsupported algorithm " + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "hmac",
      algorithm
    });
  }
  return "0x" + import_hash.default.hmac(import_hash.default[algorithm], arrayify(key)).update(arrayify(data)).digest("hex");
}

// node_modules/@fuel-ts/abi-coder/dist/index.mjs
var re = (a6, e2, t5) => {
  if (!e2.has(a6))
    throw TypeError("Cannot " + t5);
};
var w = (a6, e2, t5) => (re(a6, e2, "read from private field"), t5 ? t5.call(a6) : e2.get(a6));
var _ = (a6, e2, t5) => {
  if (e2.has(a6))
    throw TypeError("Cannot add the same private member more than once");
  e2 instanceof WeakSet ? e2.add(a6) : e2.set(a6, t5);
};
var $2 = (a6, e2, t5, r2) => (re(a6, e2, "write to private field"), r2 ? r2.call(a6, t5) : e2.set(a6, t5), t5);
var Ae = new Logger("0.21.0");
var i2 = class {
  constructor(e2, t5, r2) {
    this.name = e2, this.type = t5, this.encodedLength = r2;
  }
  throwError(e2, t5) {
    throw Ae.throwArgumentError(e2, this.name, t5), new Error("unreachable");
  }
  setOffset(e2) {
    this.offset = e2;
  }
};
var P = class extends i2 {
  constructor(t5, r2) {
    super("array", `[${t5.type}; ${r2}]`, r2 * t5.encodedLength);
    this.coder = t5, this.length = r2;
  }
  encode(t5) {
    return Array.isArray(t5) || this.throwError("expected array value", t5), this.length !== t5.length && this.throwError("Types/values length mismatch", t5), concat(Array.from(t5).map((r2) => this.coder.encode(r2)));
  }
  decode(t5, r2) {
    let n3 = r2;
    return [Array(this.length).fill(0).map(() => {
      let s4;
      return [s4, n3] = this.coder.decode(t5, n3), s4;
    }), n3];
  }
};
var D = class extends i2 {
  constructor() {
    super("b256", "b256", 32);
  }
  encode(e2) {
    let t5;
    try {
      t5 = arrayify(e2);
    } catch {
      this.throwError(`Invalid ${this.type}`, e2);
    }
    return t5.length !== 32 && this.throwError(`Invalid ${this.type}`, e2), t5;
  }
  decode(e2, t5) {
    let r2 = e2.slice(t5, t5 + 32);
    return i(r2).isZero() && (r2 = new Uint8Array(32)), r2.length !== 32 && this.throwError("Invalid size for b256", r2), [S(r2, 32), t5 + 32];
  }
};
var b = class extends i2 {
  constructor() {
    super("boolean", "boolean", 8);
  }
  encode(e2) {
    let t5;
    try {
      t5 = R(e2 ? 1 : 0);
    } catch {
      this.throwError("Invalid bool", e2);
    }
    return t5.length > 1 && this.throwError("Invalid bool", e2), R(t5, 8);
  }
  decode(e2, t5) {
    let r2 = i(e2.slice(t5, t5 + 8));
    return r2.isZero() ? [false, t5 + 8] : (r2.eq(i(1)) || this.throwError("Invalid boolean value", r2), [true, t5 + 8]);
  }
};
var J = class extends i2 {
  constructor() {
    super("byte", "byte", 8);
  }
  encode(e2) {
    let t5;
    try {
      t5 = R(e2, 1);
    } catch {
      this.throwError("Invalid Byte", e2);
    }
    return R(t5, 8);
  }
  decode(e2, t5) {
    let r2 = e2.slice(t5, t5 + 8), n3 = i(r2);
    return n3.gt(i(255)) && this.throwError("Invalid Byte", n3), [Number(n3), t5 + 8];
  }
};
var l = class extends i2 {
  constructor() {
    super("u64", "u64", 8);
  }
  encode(e2) {
    let t5;
    try {
      t5 = R(e2, 8);
    } catch {
      this.throwError(`Invalid ${this.type}`, e2);
    }
    return t5;
  }
  decode(e2, t5) {
    let r2 = e2.slice(t5, t5 + 8);
    return r2 = r2.slice(0, 8), [i(r2), t5 + 8];
  }
};
var N;
var L2;
var A = class extends i2 {
  constructor(t5, r2) {
    let n3 = new l(), o4 = Object.values(r2).reduce((s4, d3) => Math.max(s4, d3.encodedLength), 0);
    super("enum", `enum ${t5}`, n3.encodedLength + o4);
    _(this, N, void 0);
    _(this, L2, void 0);
    this.name = t5, this.coders = r2, $2(this, N, n3), $2(this, L2, o4);
  }
  encode(t5) {
    let [r2, ...n3] = Object.keys(t5);
    if (!r2)
      throw new Error("A field for the case must be provided");
    if (n3.length !== 0)
      throw new Error("Only one field must be provided");
    let o4 = this.coders[r2], s4 = Object.keys(this.coders).indexOf(r2), d3 = o4.encode(t5[r2]), c9 = new Uint8Array(w(this, L2) - o4.encodedLength);
    return concat([w(this, N).encode(s4), c9, d3]);
  }
  decode(t5, r2) {
    let n3 = r2, o4;
    [o4, n3] = new l().decode(t5, n3);
    let s4 = F(o4), d3 = Object.keys(this.coders)[s4];
    if (!d3)
      throw new Error(`Invalid caseIndex "${s4}". Valid cases: ${Object.keys(this.coders)}`);
    let c9 = this.coders[d3];
    return n3 += w(this, L2) - c9.encodedLength, [o4, n3] = c9.decode(t5, n3), [{ [d3]: o4 }, n3];
  }
};
N = /* @__PURE__ */ new WeakMap(), L2 = /* @__PURE__ */ new WeakMap();
var S2 = class extends i2 {
  constructor(t5) {
    super("number", t5, 8);
    switch (this.baseType = t5, t5) {
      case "u8":
        this.length = 1;
        break;
      case "u16":
        this.length = 2;
        break;
      case "u32":
      default:
        this.length = 4;
        break;
    }
  }
  encode(t5) {
    let r2;
    try {
      r2 = R(t5);
    } catch {
      this.throwError(`Invalid ${this.baseType}`, t5);
    }
    return r2.length > this.length && this.throwError(`Invalid ${this.baseType}. Too many bytes.`, t5), R(r2, 8);
  }
  decode(t5, r2) {
    let n3 = t5.slice(r2, r2 + 8);
    return n3 = n3.slice(8 - this.length, 8), [F(n3), r2 + 8];
  }
};
var U;
var B2 = class extends i2 {
  constructor(t5) {
    let r2 = (8 - t5) % 8;
    r2 = r2 < 0 ? r2 + 8 : r2;
    super("string", `str[${t5}]`, t5 + r2);
    _(this, U, void 0);
    this.length = t5, $2(this, U, r2);
  }
  encode(t5) {
    let r2 = toUtf8Bytes(t5.slice(0, this.length)), n3 = new Uint8Array(w(this, U));
    return concat([r2, n3]);
  }
  decode(t5, r2) {
    let n3 = t5.slice(r2, r2 + this.length), o4 = toUtf8String(n3), s4 = w(this, U);
    return [o4, r2 + this.length + s4];
  }
};
U = /* @__PURE__ */ new WeakMap();
var I2 = class extends A {
  encode(e2) {
    return super.encode(this.toSwayOption(e2));
  }
  toSwayOption(e2) {
    return e2 !== void 0 ? { Some: e2 } : { None: [] };
  }
  decode(e2, t5) {
    let [r2, n3] = super.decode(e2, t5);
    return [this.toOption(r2), n3];
  }
  toOption(e2) {
    if (e2 && "Some" in e2)
      return e2.Some;
  }
};
var k = class extends i2 {
  constructor(t5, r2) {
    let n3 = Object.values(r2).reduce((o4, s4) => o4 + s4.encodedLength, 0);
    super("struct", `struct ${t5}`, n3);
    this.name = t5, this.coders = r2;
  }
  encode(t5) {
    let r2 = Object.keys(this.coders).map((n3) => {
      let o4 = this.coders[n3], s4 = t5[n3];
      return !(o4 instanceof I2) && s4 == null && this.throwError(`Invalid ${this.type}. Field "${n3}" not present.`, t5), o4.encode(s4);
    });
    return concat(r2);
  }
  decode(t5, r2) {
    let n3 = r2;
    return [Object.keys(this.coders).reduce((s4, d3) => {
      let c9 = this.coders[d3], y4;
      return [y4, n3] = c9.decode(t5, n3), s4[d3] = y4, s4;
    }, {}), n3];
  }
};
var C = class extends i2 {
  constructor(t5) {
    let r2 = t5.reduce((n3, o4) => n3 + o4.encodedLength, 0);
    super("tuple", `(${t5.map((n3) => n3.type).join(", ")})`, r2);
    this.coders = t5;
  }
  encode(t5) {
    return this.coders.length !== t5.length && this.throwError("Types/values length mismatch", { value: t5 }), concat(this.coders.map((r2, n3) => r2.encode(t5[n3])));
  }
  decode(t5, r2) {
    let n3 = r2;
    return [this.coders.map((s4) => {
      let d3;
      return [d3, n3] = s4.decode(t5, n3), d3;
    }), n3];
  }
};
var v = "enum Option";
var ie = "struct Vec";
var Z = /str\[(?<length>[0-9]+)\]/;
var M = /\[(?<item>[\w\s\\[\]]+);\s*(?<length>[0-9]+)\]/;
var W = /^struct (?<name>\w+)$/;
var Y = /^enum (?<name>\w+)$/;
var ce = /^\((?<items>.*)\)$/;
var pe = /^generic (?<name>\w+)$/;
var ue = 8;
var Vt = 32;
var Rt = 255;
var Pt = 32;
var Dt = 32;
var Jt = 10240;
var Lt = 104;
var Ue = 3;
var T = class extends i2 {
  constructor(t5) {
    super("struct", "struct Vec", 0);
    this.coder = t5;
  }
  static getBaseOffset() {
    return Ue * 8;
  }
  getEncodedVectorData(t5) {
    Array.isArray(t5) || this.throwError("expected array value", t5);
    let r2 = Array.from(t5).map((n3) => this.coder.encode(n3));
    return concat(r2);
  }
  encode(t5) {
    Array.isArray(t5) || this.throwError("expected array value", t5);
    let r2 = [], n3 = this.offset || 0;
    return r2.push(new l().encode(n3)), r2.push(new l().encode(t5.length)), r2.push(new l().encode(t5.length)), concat(r2);
  }
  decode(t5, r2) {
    return this.throwError("unexpected Vec decode", "not implemented"), [void 0, r2];
  }
};
function j(a6) {
  return a6.filter((e2) => (e2 == null ? void 0 : e2.type) !== "()" && e2 !== "()");
}
function me(a6) {
  return a6.some((e2) => (e2 == null ? void 0 : e2.type) === v);
}
function le(a6, e2, t5 = 0) {
  let r2 = [], n3 = a6.map((d3, c9) => {
    if (!(d3 instanceof T))
      return { byteLength: d3.encodedLength };
    let y4 = d3.getEncodedVectorData(e2[c9]);
    return r2.push(y4), { vecByteLength: y4.byteLength };
  }), o4 = r2.length * T.getBaseOffset() + t5, s4 = a6.map((d3, c9) => d3 instanceof T ? n3.reduce((y4, g4, R5) => "byteLength" in g4 ? y4 + g4.byteLength : R5 === 0 && R5 === c9 ? o4 : R5 < c9 ? y4 + g4.vecByteLength + o4 : y4, 0) : 0);
  return a6.forEach((d3, c9) => d3.setOffset(s4[c9])), r2;
}
var q = class {
  constructor(e2) {
    this.inputs = [];
    this.outputs = [];
    this.type = e2.type, this.name = e2.name, this.inputs = e2.inputs, this.outputs = e2.outputs;
  }
};
function ke(a6, e2) {
  Object.keys(e2).forEach((t5) => {
    let r2 = t5, n3 = e2[r2];
    defineReadOnly(a6, r2, n3);
  });
}
var f2 = class {
  constructor(e2) {
    ke(this, e2), this.isParamType = true, Object.freeze(this);
  }
  getSignaturePrefix() {
    if (this.type) {
      if (W.test(this.type))
        return "s";
      if (M.test(this.type))
        return "a";
      if (Y.test(this.type))
        return "e";
    }
    return "";
  }
  getSignatureContent() {
    var n3, o4;
    let e2 = this.type || "";
    if (e2 === "raw untyped ptr")
      return "rawptr";
    let t5 = (n3 = M.exec(e2)) == null ? void 0 : n3.groups;
    if (t5)
      return `[${this.components ? this.components[0].getSighash() : t5.item};${t5.length}]`;
    let r2 = (o4 = Z.exec(e2)) == null ? void 0 : o4.groups;
    if (r2)
      return `str[${r2.length}]`;
    if (Array.isArray(this.components)) {
      let s4 = Array.isArray(this.typeArguments) ? `<${this.typeArguments.map((c9) => c9.getSighash()).join(",")}>` : "", d3 = `(${this.components.map((c9) => c9.getSighash()).join(",")})`;
      return `${s4}${d3}`;
    }
    return e2;
  }
  getSighash() {
    let e2 = this.getSignaturePrefix(), t5 = this.getSignatureContent();
    return `${e2}${t5}`;
  }
  static fromObject(e2) {
    return f2.isParamType(e2) ? e2 : new f2({ name: e2.name, type: e2.type, components: e2.components ? e2.components.map(f2.fromObject) : void 0, typeArguments: e2.typeArguments ? e2.typeArguments.map(f2.fromObject) : void 0 });
  }
  static isParamType(e2) {
    return Boolean(e2 == null ? void 0 : e2.isParamType);
  }
};
var x = class extends q {
  static fromObject(e2) {
    let { inputs: t5 = [], outputs: r2 = [] } = e2, n3 = { type: "function", name: e2.name, inputs: t5.map(f2.fromObject), outputs: r2.map(f2.fromObject) };
    return new x(n3);
  }
  getInputsSighash() {
    let e2 = this.inputs.map((t5) => t5.getSighash());
    return `${this.name}(${e2.join(",")})`;
  }
};
var z = new Logger("0.21.0");
var O2 = class {
  constructor() {
    z.checkNew(new.target, O2);
  }
  getCoder(e2) {
    var d3, c9, y4, g4, R5, ee3;
    switch (e2.type) {
      case "u8":
      case "u16":
      case "u32":
        return new S2(e2.type);
      case "u64":
      case "raw untyped ptr":
        return new l();
      case "bool":
        return new b();
      case "byte":
        return new J();
      case "b256":
        return new D();
      default:
    }
    let t5 = (d3 = M.exec(e2.type)) == null ? void 0 : d3.groups;
    if (t5) {
      let m4 = parseInt(t5.length, 10), h5 = (c9 = e2.components) == null ? void 0 : c9[0];
      if (!h5)
        throw new Error("Expected array type to have an item component");
      let F4 = this.getCoder(h5);
      return new P(F4, m4);
    }
    let r2 = (y4 = Z.exec(e2.type)) == null ? void 0 : y4.groups;
    if (r2) {
      let m4 = parseInt(r2.length, 10);
      return new B2(m4);
    }
    if (e2.type === ie && Array.isArray(e2.typeArguments)) {
      let m4 = e2.typeArguments[0];
      if (!m4)
        throw new Error("Expected Vec type to have a type argument");
      let h5 = this.getCoder(m4);
      return new T(h5);
    }
    let n3 = (g4 = W.exec(e2.type)) == null ? void 0 : g4.groups;
    if (n3 && Array.isArray(e2.components)) {
      let m4 = e2.components.reduce((h5, F4) => (h5[F4.name] = this.getCoder(F4), h5), {});
      return new k(n3.name, m4);
    }
    let o4 = (R5 = Y.exec(e2.type)) == null ? void 0 : R5.groups;
    if (o4 && Array.isArray(e2.components)) {
      let m4 = e2.components.reduce((F4, te3) => (F4[te3.name] = this.getCoder(te3), F4), {});
      return e2.type === v ? new I2(o4.name, m4) : new A(o4.name, m4);
    }
    if (((ee3 = ce.exec(e2.type)) == null ? void 0 : ee3.groups) && Array.isArray(e2.components)) {
      let m4 = e2.components.map((h5) => this.getCoder(h5));
      return new C(m4);
    }
    return z.throwArgumentError("Invalid type", "type", e2.type);
  }
  encode(e2, t5, r2 = 0) {
    let n3 = j(e2), o4 = t5.slice();
    Array.isArray(t5) && n3.length !== t5.length && (me(e2) ? (o4.length = e2.length, o4.fill(void 0, t5.length)) : z.throwError("Types/values length mismatch", Logger.errors.INVALID_ARGUMENT, { count: { types: n3.length, values: t5.length }, value: { types: e2, values: t5 } }));
    let s4 = n3.map((g4) => this.getCoder(g4)), d3 = le(s4, o4, r2), y4 = new C(s4).encode(o4);
    return concat([y4, concat(d3)]);
  }
  decode(e2, t5) {
    let r2 = arrayify(t5), n3 = j(e2), o4 = (g4) => {
      g4 !== r2.length && z.throwError("Types/values length mismatch", Logger.errors.INVALID_ARGUMENT, { count: { types: n3.length, values: r2.length }, value: { types: n3, bytes: r2 } });
    };
    if (e2.length === 0 || n3.length === 0) {
      o4(r2.length ? 8 : 0);
      return;
    }
    let s4 = n3.map((g4) => this.getCoder(g4)), d3 = new C(s4), [c9, y4] = d3.decode(r2, 0);
    return o4(y4), c9;
  }
};
var G = (a6) => !Array.isArray(a6);
var V = class {
  constructor(e2) {
    this.types = e2.types, this.functions = e2.functions, this.loggedTypes = e2.loggedTypes;
  }
  parseLoggedType(e2) {
    return f2.fromObject(this.parseInput(e2.loggedType));
  }
  parseInput(e2, t5 = /* @__PURE__ */ new Map()) {
    let r2 = this.types[e2.type], n3, o4;
    if (!r2)
      throw new Error(`${e2.type} not found`);
    if (Array.isArray(e2.typeArguments) && (o4 = e2.typeArguments.map((s4) => this.parseInput(s4, t5))), Array.isArray(r2.typeParameters) && Array.isArray(o4) && r2.typeParameters.forEach((s4, d3) => {
      o4 != null && o4[d3] && t5.set(s4, o4[d3]);
    }), Array.isArray(r2.components) && (n3 = r2.components.map((s4) => this.parseInput(s4, t5))), pe.test(r2.type)) {
      let s4 = t5.get(r2.typeId);
      if (s4)
        return { ...s4, name: e2.name };
    }
    return { type: r2.type, name: e2.name, typeArguments: o4, components: n3 };
  }
  static unflatten(e2) {
    return G(e2) ? new V(e2).unflatten() : e2;
  }
  unflattenLoggedTypes() {
    return this.loggedTypes.map((e2) => ({ ...e2, abiFragmentType: [this.parseLoggedType(e2)] }));
  }
  unflatten() {
    return this.functions.map((e2) => ({ type: "function", name: e2.name, inputs: (e2.inputs || []).map((t5) => this.parseInput(t5)), outputs: e2.output ? [this.parseInput(e2.output)] : [] }));
  }
};
var fe = (a6) => {
  switch (a6) {
    case "u8":
    case "u16":
    case "u32":
    case "u64":
    case "bool":
      return false;
    default:
      return true;
  }
};
var Q = new Logger("0.21.0");
var Me = (a6) => {
  let e2 = [];
  return a6.forEach((t5) => {
    t5.type === "function" && e2.push(x.fromObject(t5));
  }), e2;
};
var E = class {
  constructor(e2) {
    this.abi = G(e2) ? new V(e2) : null, this.fragments = Me(V.unflatten(e2)), this.types = this.abi ? this.abi.types : [], this.loggedTypes = this.abi ? this.abi.unflattenLoggedTypes() : [], this.abiCoder = new O2(), this.functions = {}, this.fragments.forEach((t5) => {
      let r2 = {};
      switch (t5.type) {
        case "function":
          r2 = this.functions;
          break;
        default:
          return;
      }
      let n3 = t5.getInputsSighash();
      if (r2[n3]) {
        Q.warn(`duplicate definition - ${n3}`);
        return;
      }
      r2[n3] = t5;
    });
  }
  static getSighash(e2) {
    let t5 = typeof e2 == "string" ? toUtf8Bytes(e2) : toUtf8Bytes(e2.getInputsSighash());
    return concat([new Uint8Array(4), arrayify(sha256(t5)).slice(0, 4)]);
  }
  getFunction(e2) {
    if (this.functions[e2])
      return this.functions[e2];
    let t5 = Object.values(this.functions).find((r2) => hexlify(E.getSighash(r2)) === e2 || r2.name === e2);
    return t5 || Q.throwArgumentError(`function ${e2} not found.`, "data", t5);
  }
  decodeFunctionData(e2, t5) {
    let r2 = typeof e2 == "string" ? this.getFunction(e2) : e2, n3 = arrayify(t5);
    return hexlify(n3.slice(0, 8)) !== hexlify(E.getSighash(r2)) && Q.throwArgumentError(`data signature does not match function ${r2.name}.`, "data", hexlify(n3)), this.abiCoder.decode(r2.inputs, n3.slice(16));
  }
  encodeFunctionData(e2, t5, r2 = 0) {
    let n3 = typeof e2 == "string" ? this.getFunction(e2) : e2;
    if (!n3)
      throw new Error("Fragment not found");
    let o4 = E.getSighash(n3), s4 = j(n3.inputs);
    if (s4.length === 0)
      return o4;
    let d3 = s4.length > 1 || fe(s4[0].type), c9 = this.abiCoder.encode(s4, t5, r2);
    return concat([o4, new b().encode(d3), c9]);
  }
  decodeFunctionResult(e2, t5) {
    let r2 = typeof e2 == "string" ? this.getFunction(e2) : e2, n3 = arrayify(t5);
    return this.abiCoder.decode(r2.outputs, n3);
  }
  decodeLog(e2, t5) {
    let r2 = this.loggedTypes.find((n3) => n3.logId === t5);
    if (!(r2 != null && r2.abiFragmentType))
      throw new Error(`Log ID - ${t5} unknown`);
    return this.abiCoder.decode(r2.abiFragmentType, e2);
  }
  encodeFunctionResult(e2, t5) {
    let r2 = typeof e2 == "string" ? this.getFunction(e2) : e2;
    if (!r2)
      throw new Error("Fragment not found");
    return this.abiCoder.encode(r2.outputs, t5);
  }
};

// node_modules/@fuel-ts/constants/dist/index.mjs
var t = "0x0000000000000000000000000000000000000000000000000000000000000000";
var c2 = t;
var b2 = "0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";

// node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js
function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {
  password = arrayify(password);
  salt = arrayify(salt);
  let hLen;
  let l7 = 1;
  const DK = new Uint8Array(keylen);
  const block1 = new Uint8Array(salt.length + 4);
  block1.set(salt);
  let r2;
  let T6;
  for (let i7 = 1; i7 <= l7; i7++) {
    block1[salt.length] = i7 >> 24 & 255;
    block1[salt.length + 1] = i7 >> 16 & 255;
    block1[salt.length + 2] = i7 >> 8 & 255;
    block1[salt.length + 3] = i7 & 255;
    let U3 = arrayify(computeHmac(hashAlgorithm, password, block1));
    if (!hLen) {
      hLen = U3.length;
      T6 = new Uint8Array(hLen);
      l7 = Math.ceil(keylen / hLen);
      r2 = keylen - (l7 - 1) * hLen;
    }
    T6.set(U3);
    for (let j5 = 1; j5 < iterations; j5++) {
      U3 = arrayify(computeHmac(hashAlgorithm, password, U3));
      for (let k5 = 0; k5 < hLen; k5++)
        T6[k5] ^= U3[k5];
    }
    const destPos = (i7 - 1) * hLen;
    const len = i7 === l7 ? r2 : hLen;
    DK.set(arrayify(T6).slice(0, len), destPos);
  }
  return hexlify(DK);
}

// node_modules/@fuel-ts/keystore/dist/index.mjs
var h = ((r2) => typeof __require != "undefined" ? __require : typeof Proxy != "undefined" ? new Proxy(r2, { get: (t5, e2) => (typeof __require != "undefined" ? __require : t5)[e2] }) : r2)(function(r2) {
  if (typeof __require != "undefined")
    return __require.apply(this, arguments);
  throw new Error('Dynamic require of "' + r2 + '" is not supported');
});
var b3;
var v2 = "Node";
typeof globalThis < "u" && globalThis.crypto && (b3 = globalThis.crypto, v2 = "Web");
if (!b3 && typeof h == "function")
  try {
    b3 = h("crypto"), v2 = "Node";
  } catch (r2) {
    console.error("keystore expects a standard Web browser or Node environment.", r2);
  }
var s = b3;
var i3 = v2;
function c3(r2, t5 = "base64") {
  return i3 === "Node" ? Buffer.from(r2, t5) : t5 === "utf-8" ? new TextEncoder().encode(r2) : new Uint8Array(atob(r2).split("").map((e2) => e2.charCodeAt(0)));
}
function f3(r2, t5 = "base64") {
  return i3 === "Node" ? Buffer.from(r2).toString(t5) : btoa(String.fromCharCode.apply(null, new Uint8Array(r2)));
}
function m(r2, t5) {
  let e2 = c3(String(r2).normalize("NFKC"), "utf-8"), o4 = pbkdf2(e2, t5, 1e5, 32, "sha256");
  return arrayify(o4);
}
var u = (r2) => i3 === "Node" ? s.randomBytes(r2) : s.getRandomValues(new Uint8Array(r2));
var x2 = "aes-256-ctr";
async function B3(r2, t5) {
  let e2 = u(16), o4 = u(32), p6 = m(r2, o4), y4 = Uint8Array.from(Buffer.from(JSON.stringify(t5), "utf-8")), n3 = s.createCipheriv(x2, p6, e2), a6 = n3.update(y4);
  return a6 = Buffer.concat([a6, n3.final()]), { data: f3(a6), iv: f3(e2), salt: f3(o4) };
}
async function w2(r2, t5) {
  let e2 = c3(t5.iv), o4 = c3(t5.salt), p6 = m(r2, o4), y4 = c3(t5.data), n3 = s.createDecipheriv(x2, p6, e2), a6 = n3.update(y4), g4 = Buffer.concat([a6, n3.final()]), T6 = Buffer.from(g4).toString("utf-8");
  try {
    return JSON.parse(T6);
  } catch {
    throw new Error("Invalid credentials");
  }
}
var N2 = "AES-CTR";
async function A2(r2, t5) {
  let e2 = u(16), o4 = u(32), p6 = m(r2, o4), y4 = Uint8Array.from(Buffer.from(JSON.stringify(t5), "utf-8")), n3 = { name: N2, counter: e2, length: 64 }, a6 = await s.subtle.importKey("raw", p6, n3, false, ["encrypt"]), g4 = await s.subtle.encrypt(n3, a6, y4);
  return { data: f3(g4), iv: f3(e2), salt: f3(o4) };
}
async function K(r2, t5) {
  let e2 = c3(t5.iv), o4 = c3(t5.salt), p6 = m(r2, o4), y4 = c3(t5.data), n3 = { name: N2, counter: e2, length: 64 }, a6 = await s.subtle.importKey("raw", p6, n3, false, ["decrypt"]), g4 = await s.subtle.decrypt(n3, a6, y4), T6 = new TextDecoder().decode(g4);
  try {
    return JSON.parse(T6);
  } catch {
    throw new Error("Invalid credentials");
  }
}
async function Q2(r2, t5) {
  return i3 === "Node" ? B3(r2, t5) : A2(r2, t5);
}
async function X(r2, t5) {
  return i3 === "Node" ? w2(r2, t5) : K(r2, t5);
}

// node_modules/tslib/tslib.es6.js
var __assign = function() {
  __assign = Object.assign || function __assign2(t5) {
    for (var s4, i7 = 1, n3 = arguments.length; i7 < n3; i7++) {
      s4 = arguments[i7];
      for (var p6 in s4)
        if (Object.prototype.hasOwnProperty.call(s4, p6))
          t5[p6] = s4[p6];
    }
    return t5;
  };
  return __assign.apply(this, arguments);
};

// node_modules/graphql/version.mjs
var versionInfo = Object.freeze({
  major: 16,
  minor: 6,
  patch: 0,
  preReleaseTag: null
});

// node_modules/graphql/graphql.mjs
init_devAssert();
init_parser();

// node_modules/graphql/type/validate.mjs
init_inspect();
init_GraphQLError();
init_ast();

// node_modules/graphql/type/definition.mjs
init_devAssert();

// node_modules/graphql/jsutils/didYouMean.mjs
var MAX_SUGGESTIONS = 5;
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x6) => `"${x6}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}

// node_modules/graphql/jsutils/identityFunc.mjs
function identityFunc(x6) {
  return x6;
}

// node_modules/graphql/type/definition.mjs
init_inspect();
init_instanceOf();
init_isObjectLike();

// node_modules/graphql/jsutils/keyMap.mjs
function keyMap(list, keyFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = item;
  }
  return result;
}

// node_modules/graphql/jsutils/keyValMap.mjs
function keyValMap(list, keyFn, valFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}

// node_modules/graphql/jsutils/mapValue.mjs
function mapValue(map, fn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map)) {
    result[key] = fn(map[key], key);
  }
  return result;
}

// node_modules/graphql/jsutils/naturalCompare.mjs
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
var DIGIT_0 = 48;
var DIGIT_9 = 57;
function isDigit2(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
}

// node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  const optionsByDistance = /* @__PURE__ */ Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== void 0) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a6, b9) => {
    const distanceDiff = optionsByDistance[a6] - optionsByDistance[b9];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a6, b9);
  });
}
var LexicalDistance = class {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option, threshold) {
    if (this._input === option) {
      return 0;
    }
    const optionLowerCase = option.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a6 = stringToArray(optionLowerCase);
    let b9 = this._inputArray;
    if (a6.length < b9.length) {
      const tmp = a6;
      a6 = b9;
      b9 = tmp;
    }
    const aLength = a6.length;
    const bLength = b9.length;
    if (aLength - bLength > threshold) {
      return void 0;
    }
    const rows = this._rows;
    for (let j5 = 0; j5 <= bLength; j5++) {
      rows[0][j5] = j5;
    }
    for (let i7 = 1; i7 <= aLength; i7++) {
      const upRow = rows[(i7 - 1) % 3];
      const currentRow = rows[i7 % 3];
      let smallestCell = currentRow[0] = i7;
      for (let j5 = 1; j5 <= bLength; j5++) {
        const cost = a6[i7 - 1] === b9[j5 - 1] ? 0 : 1;
        let currentCell = Math.min(
          upRow[j5] + 1,
          currentRow[j5 - 1] + 1,
          upRow[j5 - 1] + cost
        );
        if (i7 > 1 && j5 > 1 && a6[i7 - 1] === b9[j5 - 2] && a6[i7 - 2] === b9[j5 - 1]) {
          const doubleDiagonalCell = rows[(i7 - 2) % 3][j5 - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j5] = currentCell;
      }
      if (smallestCell > threshold) {
        return void 0;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : void 0;
  }
};
function stringToArray(str) {
  const strLength = str.length;
  const array = new Array(strLength);
  for (let i7 = 0; i7 < strLength; ++i7) {
    array[i7] = str.charCodeAt(i7);
  }
  return array;
}

// node_modules/graphql/jsutils/toObjMap.mjs
function toObjMap(obj) {
  if (obj == null) {
    return /* @__PURE__ */ Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    map[key] = value;
  }
  return map;
}

// node_modules/graphql/type/definition.mjs
init_GraphQLError();
init_kinds();
init_printer();

// node_modules/graphql/utilities/valueFromASTUntyped.mjs
init_kinds();
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map(
        (node) => valueFromASTUntyped(node, variables)
      );
    case Kind.OBJECT:
      return keyValMap(
        valueNode.fields,
        (field) => field.name.value,
        (field) => valueFromASTUntyped(field.value, variables)
      );
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
}

// node_modules/graphql/type/assertName.mjs
init_devAssert();
init_GraphQLError();
init_characterClasses();
function assertName(name) {
  name != null || devAssert(false, "Must provide name.");
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i7 = 1; i7 < name.length; ++i7) {
    if (!isNameContinue(name.charCodeAt(i7))) {
      throw new GraphQLError(
        `Names must only contain [_a-zA-Z0-9] but "${name}" does not.`
      );
    }
  }
  if (!isNameStart(name.charCodeAt(0))) {
    throw new GraphQLError(
      `Names must start with [_a-zA-Z] but "${name}" does not.`
    );
  }
  return name;
}
function assertEnumValueName(name) {
  if (name === "true" || name === "false" || name === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name}`);
  }
  return assertName(name);
}

// node_modules/graphql/type/definition.mjs
function isType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
}
function isScalarType(type) {
  return instanceOf(type, GraphQLScalarType);
}
function isObjectType(type) {
  return instanceOf(type, GraphQLObjectType);
}
function isInterfaceType(type) {
  return instanceOf(type, GraphQLInterfaceType);
}
function isUnionType(type) {
  return instanceOf(type, GraphQLUnionType);
}
function isEnumType(type) {
  return instanceOf(type, GraphQLEnumType);
}
function isInputObjectType(type) {
  return instanceOf(type, GraphQLInputObjectType);
}
function isListType(type) {
  return instanceOf(type, GraphQLList);
}
function isNonNullType(type) {
  return instanceOf(type, GraphQLNonNull);
}
function isInputType(type) {
  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
}
function isOutputType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
}
function isLeafType(type) {
  return isScalarType(type) || isEnumType(type);
}
function isCompositeType(type) {
  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
}
function isAbstractType(type) {
  return isInterfaceType(type) || isUnionType(type);
}
var GraphQLList = class {
  constructor(ofType) {
    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLNonNull = class {
  constructor(ofType) {
    isNullableType(ofType) || devAssert(
      false,
      `Expected ${inspect(ofType)} to be a GraphQL nullable type.`
    );
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
};
function isWrappingType(type) {
  return isListType(type) || isNonNullType(type);
}
function isNullableType(type) {
  return isType(type) && !isNonNullType(type);
}
function getNullableType(type) {
  if (type) {
    return isNonNullType(type) ? type.ofType : type;
  }
}
function getNamedType(type) {
  if (type) {
    let unwrappedType = type;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
var GraphQLScalarType = class {
  constructor(config) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue2 = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
    this.name = assertName(config.name);
    this.description = config.description;
    this.specifiedByURL = config.specifiedByURL;
    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
    this.parseValue = parseValue2;
    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue2(valueFromASTUntyped(node, variables));
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(
      false,
      `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config.specifiedByURL)}.`
    );
    config.serialize == null || typeof config.serialize === "function" || devAssert(
      false,
      `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
    );
    if (config.parseLiteral) {
      typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(
        false,
        `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
      );
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLObjectType = class {
  constructor(config) {
    var _config$extensionASTN2;
    this.name = assertName(config.name);
    this.description = config.description;
    this.isTypeOf = config.isTypeOf;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config);
    this._interfaces = () => defineInterfaces(config);
    config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(
      false,
      `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config.isTypeOf)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInterfaces(config) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk(
    (_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
  );
  Array.isArray(interfaces) || devAssert(
    false,
    `${config.name} interfaces must be an Array or a function which returns an Array.`
  );
  return interfaces;
}
function defineFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field config must be an object.`
    );
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(
      false,
      `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`
    );
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(
      false,
      `${config.name}.${fieldName} args must be an object with argument names as keys.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
}
function argsToArgsConfig(args) {
  return keyValMap(
    args,
    (arg) => arg.name,
    (arg) => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    })
  );
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
var GraphQLInterfaceType = class {
  constructor(config) {
    var _config$extensionASTN3;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(void 0, config);
    this._interfaces = defineInterfaces.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLUnionType = class {
  constructor(config) {
    var _config$extensionASTN4;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineTypes(config) {
  const types = resolveReadonlyArrayThunk(config.types);
  Array.isArray(types) || devAssert(
    false,
    `Must provide Array of types or a function which returns such an array for Union ${config.name}.`
  );
  return types;
}
var GraphQLEnumType = class {
  constructor(config) {
    var _config$extensionASTN5;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
    this._values = defineEnumValues(this.name, config.values);
    this._valueLookup = new Map(
      this._values.map((enumValue) => [enumValue.value, enumValue])
    );
    this._nameLookup = keyMap(this._values, (value) => value.name);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    return this._values;
  }
  getValue(name) {
    return this._nameLookup[name];
  }
  serialize(outputValue) {
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === void 0) {
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`
      );
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect(inputValue);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
      );
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(
        `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
      );
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    return enumValue.value;
  }
  toConfig() {
    const values = keyValMap(
      this.getValues(),
      (value) => value.name,
      (value) => ({
        description: value.description,
        value: value.value,
        deprecationReason: value.deprecationReason,
        extensions: value.extensions,
        astNode: value.astNode
      })
    );
    return {
      name: this.name,
      description: this.description,
      values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function didYouMeanEnumValue(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value) => value.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(
    false,
    `${typeName} values must be an object with value names as keys.`
  );
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(
      false,
      `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`
    );
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
var GraphQLInputObjectType = class {
  constructor(config) {
    var _config$extensionASTN6;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
    this._fields = defineInputFieldMap.bind(void 0, config);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field) => ({
      description: field.description,
      type: field.type,
      defaultValue: field.defaultValue,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInputFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === void 0;
}

// node_modules/graphql/utilities/typeComparators.mjs
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}

// node_modules/graphql/type/directives.mjs
init_devAssert();
init_inspect();
init_instanceOf();
init_isObjectLike();
init_directiveLocation();

// node_modules/graphql/type/scalars.mjs
init_inspect();
init_isObjectLike();
init_GraphQLError();
init_kinds();
init_printer();
var GRAPHQL_MAX_INT = 2147483647;
var GRAPHQL_MIN_INT = -2147483648;
var GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isInteger(num)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(coercedValue)}`
      );
    }
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        "Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue)
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(inputValue)}`
      );
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${inputValue}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    const num = parseInt(valueNode.value, 10);
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
        {
          nodes: valueNode
        }
      );
    }
    return num;
  }
});
var GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isFinite(num)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(coercedValue)}`
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${print(valueNode)}`,
        valueNode
      );
    }
    return parseFloat(valueNode.value);
  }
});
var GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(
      `String cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(
        `String cannot represent a non string value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING) {
      throw new GraphQLError(
        `String cannot represent a non string value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(
      `Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.BOOLEAN) {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(
      `ID cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        "ID cannot represent a non-string and non-integer value: " + print(valueNode),
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var specifiedScalarTypes = Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}

// node_modules/graphql/type/directives.mjs
function isDirective(directive) {
  return instanceOf(directive, GraphQLDirective);
}
var GraphQLDirective = class {
  constructor(config) {
    var _config$isRepeatable, _config$args;
    this.name = assertName(config.name);
    this.description = config.description;
    this.locations = config.locations;
    this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
    const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
    isObjectLike(args) && !Array.isArray(args) || devAssert(
      false,
      `@${config.name} args must be an object with argument names as keys.`
    );
    this.args = defineArguments(args);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
var GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
var DEFAULT_DEPRECATION_REASON = "No longer supported";
var GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    DirectiveLocation.FIELD_DEFINITION,
    DirectiveLocation.ARGUMENT_DEFINITION,
    DirectiveLocation.INPUT_FIELD_DEFINITION,
    DirectiveLocation.ENUM_VALUE
  ],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
var GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});
var specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective
]);

// node_modules/graphql/type/introspection.mjs
init_inspect();
init_invariant();
init_directiveLocation();
init_printer();

// node_modules/graphql/utilities/astFromValue.mjs
init_inspect();
init_invariant();

// node_modules/graphql/jsutils/isIterableObject.mjs
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}

// node_modules/graphql/utilities/astFromValue.mjs
init_isObjectLike();
init_kinds();
function astFromValue(value, type) {
  if (isNonNullType(type)) {
    const astValue = astFromValue(value, type.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value === void 0) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value, itemType);
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type.getFields())) {
      const fieldValue = astFromValue(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type)) {
    const serialized = type.serialize(value);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// node_modules/graphql/type/introspection.mjs
var __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema) => schema.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema) {
        return Object.values(schema.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema) => schema.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__Directive))
      ),
      resolve: (schema) => schema.getDirectives()
    }
  })
});
var __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive) => directive.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive) => directive.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive) => directive.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__DirectiveLocation))
      ),
      resolve: (directive) => directive.locations
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
var __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
var __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type) {
        if (isScalarType(type)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type)) {
          return TypeKind.NON_NULL;
        }
        invariant(false, `Unexpected type: "${inspect(type)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type) => "name" in type ? type.name : void 0
    },
    description: {
      type: GraphQLString,
      resolve: (type) => "description" in type ? type.description : void 0
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isObjectType(type) || isInterfaceType(type)) {
          const fields = Object.values(type.getFields());
          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type) {
        if (isObjectType(type) || isInterfaceType(type)) {
          return type.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type, _args, _context, { schema }) {
        if (isAbstractType(type)) {
          return schema.getPossibleTypes(type);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isEnumType(type)) {
          const values = type.getValues();
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isInputObjectType(type)) {
          const values = Object.values(type.getFields());
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type) => "ofType" in type ? type.ofType : void 0
    }
  })
});
var __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field) => field.name
    },
    description: {
      type: GraphQLString,
      resolve: (field) => field.description
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field) => field.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field) => field.deprecationReason
    }
  })
});
var __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type, defaultValue } = inputValue;
        const valueAST = astFromValue(defaultValue, type);
        return valueAST ? print(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
var __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
var TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
var __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
var SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema }) => schema,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: void 0,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: void 0,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    }
  ],
  resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var introspectionTypes = Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);

// node_modules/graphql/type/schema.mjs
init_devAssert();
init_inspect();
init_instanceOf();
init_isObjectLike();
init_ast();
var GraphQLSchema = class {
  constructor(config) {
    var _config$extensionASTN, _config$directives;
    this.__validationErrors = config.assumeValid === true ? [] : void 0;
    isObjectLike(config) || devAssert(false, "Must provide configuration object.");
    !config.types || Array.isArray(config.types) || devAssert(
      false,
      `"types" must be Array if provided but got: ${inspect(config.types)}.`
    );
    !config.directives || Array.isArray(config.directives) || devAssert(
      false,
      `"directives" must be Array if provided but got: ${inspect(config.directives)}.`
    );
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    this._queryType = config.query;
    this._mutationType = config.mutation;
    this._subscriptionType = config.subscription;
    this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives;
    const allReferencedTypes = new Set(config.types);
    if (config.types != null) {
      for (const type of config.types) {
        allReferencedTypes.delete(type);
        collectReferencedTypes(type, allReferencedTypes);
      }
    }
    if (this._queryType != null) {
      collectReferencedTypes(this._queryType, allReferencedTypes);
    }
    if (this._mutationType != null) {
      collectReferencedTypes(this._mutationType, allReferencedTypes);
    }
    if (this._subscriptionType != null) {
      collectReferencedTypes(this._subscriptionType, allReferencedTypes);
    }
    for (const directive of this._directives) {
      if (isDirective(directive)) {
        for (const arg of directive.args) {
          collectReferencedTypes(arg.type, allReferencedTypes);
        }
      }
    }
    collectReferencedTypes(__Schema, allReferencedTypes);
    this._typeMap = /* @__PURE__ */ Object.create(null);
    this._subTypeMap = /* @__PURE__ */ Object.create(null);
    this._implementationsMap = /* @__PURE__ */ Object.create(null);
    for (const namedType of allReferencedTypes) {
      if (namedType == null) {
        continue;
      }
      const typeName = namedType.name;
      typeName || devAssert(
        false,
        "One of the provided types for building the Schema is missing a name."
      );
      if (this._typeMap[typeName] !== void 0) {
        throw new Error(
          `Schema must contain uniquely named types but contains multiple types named "${typeName}".`
        );
      }
      this._typeMap[typeName] = namedType;
      if (isInterfaceType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === void 0) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.interfaces.push(namedType);
          }
        }
      } else if (isObjectType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === void 0) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.objects.push(namedType);
          }
        }
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLSchema";
  }
  getQueryType() {
    return this._queryType;
  }
  getMutationType() {
    return this._mutationType;
  }
  getSubscriptionType() {
    return this._subscriptionType;
  }
  getRootType(operation) {
    switch (operation) {
      case OperationTypeNode.QUERY:
        return this.getQueryType();
      case OperationTypeNode.MUTATION:
        return this.getMutationType();
      case OperationTypeNode.SUBSCRIPTION:
        return this.getSubscriptionType();
    }
  }
  getTypeMap() {
    return this._typeMap;
  }
  getType(name) {
    return this.getTypeMap()[name];
  }
  getPossibleTypes(abstractType) {
    return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
  }
  getImplementations(interfaceType) {
    const implementations = this._implementationsMap[interfaceType.name];
    return implementations !== null && implementations !== void 0 ? implementations : {
      objects: [],
      interfaces: []
    };
  }
  isSubType(abstractType, maybeSubType) {
    let map = this._subTypeMap[abstractType.name];
    if (map === void 0) {
      map = /* @__PURE__ */ Object.create(null);
      if (isUnionType(abstractType)) {
        for (const type of abstractType.getTypes()) {
          map[type.name] = true;
        }
      } else {
        const implementations = this.getImplementations(abstractType);
        for (const type of implementations.objects) {
          map[type.name] = true;
        }
        for (const type of implementations.interfaces) {
          map[type.name] = true;
        }
      }
      this._subTypeMap[abstractType.name] = map;
    }
    return map[maybeSubType.name] !== void 0;
  }
  getDirectives() {
    return this._directives;
  }
  getDirective(name) {
    return this.getDirectives().find((directive) => directive.name === name);
  }
  toConfig() {
    return {
      description: this.description,
      query: this.getQueryType(),
      mutation: this.getMutationType(),
      subscription: this.getSubscriptionType(),
      types: Object.values(this.getTypeMap()),
      directives: this.getDirectives(),
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      assumeValid: this.__validationErrors !== void 0
    };
  }
};
function collectReferencedTypes(type, typeSet) {
  const namedType = getNamedType(type);
  if (!typeSet.has(namedType)) {
    typeSet.add(namedType);
    if (isUnionType(namedType)) {
      for (const memberType of namedType.getTypes()) {
        collectReferencedTypes(memberType, typeSet);
      }
    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {
      for (const interfaceType of namedType.getInterfaces()) {
        collectReferencedTypes(interfaceType, typeSet);
      }
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
        for (const arg of field.args) {
          collectReferencedTypes(arg.type, typeSet);
        }
      }
    } else if (isInputObjectType(namedType)) {
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
      }
    }
  }
  return typeSet;
}

// node_modules/graphql/validation/validate.mjs
init_devAssert();
init_GraphQLError();
init_visitor();

// node_modules/graphql/utilities/TypeInfo.mjs
init_ast();
init_kinds();
init_visitor();

// node_modules/graphql/utilities/typeFromAST.mjs
init_kinds();
function typeFromAST(schema, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema.getType(typeNode.name.value);
  }
}

// node_modules/graphql/utilities/TypeInfo.mjs
var TypeInfo = class {
  constructor(schema, initialType, getFieldDefFn) {
    this._schema = schema;
    this._typeStack = [];
    this._parentTypeStack = [];
    this._inputTypeStack = [];
    this._fieldDefStack = [];
    this._defaultValueStack = [];
    this._directive = null;
    this._argument = null;
    this._enumValue = null;
    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
    if (initialType) {
      if (isInputType(initialType)) {
        this._inputTypeStack.push(initialType);
      }
      if (isCompositeType(initialType)) {
        this._parentTypeStack.push(initialType);
      }
      if (isOutputType(initialType)) {
        this._typeStack.push(initialType);
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "TypeInfo";
  }
  getType() {
    if (this._typeStack.length > 0) {
      return this._typeStack[this._typeStack.length - 1];
    }
  }
  getParentType() {
    if (this._parentTypeStack.length > 0) {
      return this._parentTypeStack[this._parentTypeStack.length - 1];
    }
  }
  getInputType() {
    if (this._inputTypeStack.length > 0) {
      return this._inputTypeStack[this._inputTypeStack.length - 1];
    }
  }
  getParentInputType() {
    if (this._inputTypeStack.length > 1) {
      return this._inputTypeStack[this._inputTypeStack.length - 2];
    }
  }
  getFieldDef() {
    if (this._fieldDefStack.length > 0) {
      return this._fieldDefStack[this._fieldDefStack.length - 1];
    }
  }
  getDefaultValue() {
    if (this._defaultValueStack.length > 0) {
      return this._defaultValueStack[this._defaultValueStack.length - 1];
    }
  }
  getDirective() {
    return this._directive;
  }
  getArgument() {
    return this._argument;
  }
  getEnumValue() {
    return this._enumValue;
  }
  enter(node) {
    const schema = this._schema;
    switch (node.kind) {
      case Kind.SELECTION_SET: {
        const namedType = getNamedType(this.getType());
        this._parentTypeStack.push(
          isCompositeType(namedType) ? namedType : void 0
        );
        break;
      }
      case Kind.FIELD: {
        const parentType = this.getParentType();
        let fieldDef;
        let fieldType;
        if (parentType) {
          fieldDef = this._getFieldDef(schema, parentType, node);
          if (fieldDef) {
            fieldType = fieldDef.type;
          }
        }
        this._fieldDefStack.push(fieldDef);
        this._typeStack.push(isOutputType(fieldType) ? fieldType : void 0);
        break;
      }
      case Kind.DIRECTIVE:
        this._directive = schema.getDirective(node.name.value);
        break;
      case Kind.OPERATION_DEFINITION: {
        const rootType = schema.getRootType(node.operation);
        this._typeStack.push(isObjectType(rootType) ? rootType : void 0);
        break;
      }
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION: {
        const typeConditionAST = node.typeCondition;
        const outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());
        this._typeStack.push(isOutputType(outputType) ? outputType : void 0);
        break;
      }
      case Kind.VARIABLE_DEFINITION: {
        const inputType = typeFromAST(schema, node.type);
        this._inputTypeStack.push(
          isInputType(inputType) ? inputType : void 0
        );
        break;
      }
      case Kind.ARGUMENT: {
        var _this$getDirective;
        let argDef;
        let argType;
        const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
        if (fieldOrDirective) {
          argDef = fieldOrDirective.args.find(
            (arg) => arg.name === node.name.value
          );
          if (argDef) {
            argType = argDef.type;
          }
        }
        this._argument = argDef;
        this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
        this._inputTypeStack.push(isInputType(argType) ? argType : void 0);
        break;
      }
      case Kind.LIST: {
        const listType = getNullableType(this.getInputType());
        const itemType = isListType(listType) ? listType.ofType : listType;
        this._defaultValueStack.push(void 0);
        this._inputTypeStack.push(isInputType(itemType) ? itemType : void 0);
        break;
      }
      case Kind.OBJECT_FIELD: {
        const objectType = getNamedType(this.getInputType());
        let inputFieldType;
        let inputField;
        if (isInputObjectType(objectType)) {
          inputField = objectType.getFields()[node.name.value];
          if (inputField) {
            inputFieldType = inputField.type;
          }
        }
        this._defaultValueStack.push(
          inputField ? inputField.defaultValue : void 0
        );
        this._inputTypeStack.push(
          isInputType(inputFieldType) ? inputFieldType : void 0
        );
        break;
      }
      case Kind.ENUM: {
        const enumType = getNamedType(this.getInputType());
        let enumValue;
        if (isEnumType(enumType)) {
          enumValue = enumType.getValue(node.value);
        }
        this._enumValue = enumValue;
        break;
      }
      default:
    }
  }
  leave(node) {
    switch (node.kind) {
      case Kind.SELECTION_SET:
        this._parentTypeStack.pop();
        break;
      case Kind.FIELD:
        this._fieldDefStack.pop();
        this._typeStack.pop();
        break;
      case Kind.DIRECTIVE:
        this._directive = null;
        break;
      case Kind.OPERATION_DEFINITION:
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION:
        this._typeStack.pop();
        break;
      case Kind.VARIABLE_DEFINITION:
        this._inputTypeStack.pop();
        break;
      case Kind.ARGUMENT:
        this._argument = null;
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind.LIST:
      case Kind.OBJECT_FIELD:
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind.ENUM:
        this._enumValue = null;
        break;
      default:
    }
  }
};
function getFieldDef(schema, parentType, fieldNode) {
  const name = fieldNode.name.value;
  if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  }
  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  }
  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {
    return TypeNameMetaFieldDef;
  }
  if (isObjectType(parentType) || isInterfaceType(parentType)) {
    return parentType.getFields()[name];
  }
}
function visitWithTypeInfo(typeInfo, visitor) {
  return {
    enter(...args) {
      const node = args[0];
      typeInfo.enter(node);
      const fn = getEnterLeaveForKind(visitor, node.kind).enter;
      if (fn) {
        const result = fn.apply(visitor, args);
        if (result !== void 0) {
          typeInfo.leave(node);
          if (isNode(result)) {
            typeInfo.enter(result);
          }
        }
        return result;
      }
    },
    leave(...args) {
      const node = args[0];
      const fn = getEnterLeaveForKind(visitor, node.kind).leave;
      let result;
      if (fn) {
        result = fn.apply(visitor, args);
      }
      typeInfo.leave(node);
      return result;
    }
  };
}

// node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
init_GraphQLError();
init_kinds();

// node_modules/graphql/language/predicates.mjs
init_kinds();
function isExecutableDefinitionNode(node) {
  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}

// node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document(node) {
      for (const definition of node.definitions) {
        if (!isExecutableDefinitionNode(definition)) {
          const defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
          context.reportError(
            new GraphQLError(`The ${defName} definition is not executable.`, {
              nodes: definition
            })
          );
        }
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
init_GraphQLError();
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node) {
      const type = context.getParentType();
      if (type) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema = context.getSchema();
          const fieldName = node.name.value;
          let suggestion = didYouMean(
            "to use an inline fragment on",
            getSuggestedTypeNames(schema, type, fieldName)
          );
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));
          }
          context.reportError(
            new GraphQLError(
              `Cannot query field "${fieldName}" on type "${type.name}".` + suggestion,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema, type, fieldName) {
  if (!isAbstractType(type)) {
    return [];
  }
  const suggestedTypes = /* @__PURE__ */ new Set();
  const usageCount = /* @__PURE__ */ Object.create(null);
  for (const possibleType of schema.getPossibleTypes(type)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x6) => x6.name);
}
function getSuggestedFieldNames(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type)) {
    const possibleFieldNames = Object.keys(type.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}

// node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
init_GraphQLError();
init_printer();
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;
      if (typeCondition) {
        const type = typeFromAST(context.getSchema(), typeCondition);
        if (type && !isCompositeType(type)) {
          const typeStr = print(typeCondition);
          context.reportError(
            new GraphQLError(
              `Fragment cannot condition on non composite type "${typeStr}".`,
              {
                nodes: typeCondition
              }
            )
          );
        }
      }
    },
    FragmentDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.typeCondition);
      if (type && !isCompositeType(type)) {
        const typeStr = print(node.typeCondition);
        context.reportError(
          new GraphQLError(
            `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
            {
              nodes: node.typeCondition
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
init_GraphQLError();
init_kinds();
function KnownArgumentNamesRule(context) {
  return {
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(
          new GraphQLError(
            `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
            {
              nodes: argNode
            }
          )
        );
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(
              new GraphQLError(
                `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
init_inspect();
init_invariant();
init_GraphQLError();
init_ast();
init_directiveLocation();
init_kinds();
function KnownDirectivesRule(context) {
  const locationsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name) => name.value);
    }
  }
  return {
    Directive(node, _key, _parent, _path, ancestors) {
      const name = node.name.value;
      const locations = locationsMap[name];
      if (!locations) {
        context.reportError(
          new GraphQLError(`Unknown directive "@${name}".`, {
            nodes: node
          })
        );
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${name}" may not be used on ${candidateLocation}.`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
}

// node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
init_GraphQLError();
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node) {
      const fragmentName = node.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(
          new GraphQLError(`Unknown fragment "${fragmentName}".`, {
            nodes: node.name
          })
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
init_GraphQLError();
function KnownTypeNamesRule(context) {
  const schema = context.getSchema();
  const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node, _1, parent, _22, ancestors) {
      const typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(
          typeName,
          isSDL ? standardTypeNames.concat(typeNames) : typeNames
        );
        context.reportError(
          new GraphQLError(
            `Unknown type "${typeName}".` + didYouMean(suggestedTypes),
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
var standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(
  (type) => type.name
);
function isSDLNode(value) {
  return "kind" in value && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));
}

// node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
init_GraphQLError();
init_kinds();
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node) {
      operationCount = node.definitions.filter(
        (definition) => definition.kind === Kind.OPERATION_DEFINITION
      ).length;
    },
    OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(
          new GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
init_GraphQLError();
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(
          new GraphQLError(
            "Cannot define a new schema within a schema extension.",
            {
              nodes: node
            }
          )
        );
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(
          new GraphQLError("Must provide only one schema definition.", {
            nodes: node
          })
        );
      }
      ++schemaDefinitionsCount;
    }
  };
}

// node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
init_GraphQLError();
function NoFragmentCyclesRule(context) {
  const visitedFrags = /* @__PURE__ */ Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s4) => '"' + s4.name.value + '"').join(", ");
        context.reportError(
          new GraphQLError(
            `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
            {
              nodes: cyclePath
            }
          )
        );
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}

// node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
init_GraphQLError();
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          const varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                {
                  nodes: [node, operation]
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}

// node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
init_GraphQLError();
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(
            operation
          )) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(
              new GraphQLError(`Fragment "${fragName}" is never used.`, {
                nodes: fragmentDef
              })
            );
          }
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
init_GraphQLError();
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = /* @__PURE__ */ Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          variableNameUsed[node.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                {
                  nodes: variableDef
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}

// node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
init_inspect();
init_GraphQLError();
init_kinds();
init_printer();

// node_modules/graphql/utilities/sortValueNode.mjs
init_kinds();
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
function sortFields(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort(
    (fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value)
  );
}

// node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(
      ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
    ).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFragmentPairs = new PairSet();
  const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
  return {
    SelectionSet(selectionSet) {
      const conflicts = findConflictsWithinSelectionSet(
        context,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        context.getParentType(),
        selectionSet
      );
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(
          new GraphQLError(
            `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
            {
              nodes: fields1.concat(fields2)
            }
          )
        );
      }
    }
  };
}
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType,
    selectionSet
  );
  collectConflictsWithin(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    fieldMap
  );
  if (fragmentNames.length !== 0) {
    for (let i7 = 0; i7 < fragmentNames.length; i7++) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        false,
        fieldMap,
        fragmentNames[i7]
      );
      for (let j5 = i7 + 1; j5 < fragmentNames.length; j5++) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          false,
          fragmentNames[i7],
          fragmentNames[j5]
        );
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment
  );
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap,
    fieldMap2
  );
  for (const referencedFragmentName of referencedFragmentNames) {
    if (comparedFragmentPairs.has(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    )) {
      continue;
    }
    comparedFragmentPairs.add(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    );
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      referencedFragmentName
    );
  }
}
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(
    fragmentName1,
    fragmentName2,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment1
  );
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fragmentName1,
      referencedFragmentName2
    );
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      referencedFragmentName1,
      fragmentName2
    );
  }
}
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType1,
    selectionSet1
  );
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType2,
    selectionSet2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fragmentName2
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap2,
      fragmentName1
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        fragmentName2
      );
    }
  }
  return conflicts;
}
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i7 = 0; i7 < fields.length; i7++) {
        for (let j5 = i7 + 1; j5 < fields.length; j5++) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            false,
            responseName,
            fields[i7],
            fields[j5]
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            parentFieldsAreMutuallyExclusive,
            responseName,
            field1,
            field2
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (stringifyArguments(node1) !== stringifyArguments(node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(
          type2
        )}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(
      context,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      getNamedType(type1),
      selectionSet1,
      getNamedType(type2),
      selectionSet2
    );
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
}
function stringifyArguments(fieldNode) {
  var _fieldNode$arguments;
  const args = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];
  const inputObjectWithArgs = {
    kind: Kind.OBJECT,
    fields: args.map((argNode) => ({
      kind: Kind.OBJECT_FIELD,
      name: argNode.name,
      value: argNode.value
    }))
  };
  return print(sortValueNode(inputObjectWithArgs));
}
function doTypesConflict(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
}
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = /* @__PURE__ */ Object.create(null);
  const fragmentNames = /* @__PURE__ */ Object.create(null);
  _collectFieldsAndFragmentNames(
    context,
    parentType,
    selectionSet,
    nodeAndDefs,
    fragmentNames
  );
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet, result);
  return result;
}
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragmentType,
    fragment.selectionSet
  );
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(
          context,
          inlineFragmentType,
          selection.selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
}
var PairSet = class {
  constructor() {
    this._data = /* @__PURE__ */ new Map();
  }
  has(a6, b9, areMutuallyExclusive) {
    var _this$_data$get;
    const [key1, key2] = a6 < b9 ? [a6, b9] : [b9, a6];
    const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
    if (result === void 0) {
      return false;
    }
    return areMutuallyExclusive ? true : areMutuallyExclusive === result;
  }
  add(a6, b9, areMutuallyExclusive) {
    const [key1, key2] = a6 < b9 ? [a6, b9] : [b9, a6];
    const map = this._data.get(key1);
    if (map === void 0) {
      this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
    } else {
      map.set(key2, areMutuallyExclusive);
    }
  }
};

// node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
init_inspect();
init_GraphQLError();
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    },
    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getFragmentType(context, name) {
  const frag = context.getFragment(name);
  if (frag) {
    const type = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type)) {
      return type;
    }
  }
}

// node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
init_inspect();
init_invariant();
init_GraphQLError();
init_kinds();
function PossibleTypeExtensionsRule(context) {
  const schema = context.getSchema();
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context.reportError(
          new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node] : node
          })
        );
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(
        new GraphQLError(
          `Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes),
          {
            nodes: node.name
          }
        )
      );
    }
  }
}
var defKindToExtKind = {
  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
};
function typeToExtKind(type) {
  if (isScalarType(type)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type));
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
}

// node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
init_inspect();
init_GraphQLError();
init_kinds();
init_printer();
function ProvidedRequiredArgumentsRule(context) {
  return {
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set(
          (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
        );
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                {
                  nodes: fieldNode
                }
              )
            );
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(
      directive.args.filter(isRequiredArgument),
      (arg) => arg.name
    );
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(
        argNodes.filter(isRequiredArgumentNode),
        (arg) => arg.name.value
      );
    }
  }
  return {
    Directive: {
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
              context.reportError(
                new GraphQLError(
                  `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                  {
                    nodes: directiveNode
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
}

// node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
init_inspect();
init_GraphQLError();
function ScalarLeafsRule(context) {
  return {
    Field(node) {
      const type = context.getType();
      const selectionSet = node.selectionSet;
      if (type) {
        if (isLeafType(getNamedType(type))) {
          if (selectionSet) {
            const fieldName = node.name.value;
            const typeStr = inspect(type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                {
                  nodes: selectionSet
                }
              )
            );
          }
        } else if (!selectionSet) {
          const fieldName = node.name.value;
          const typeStr = inspect(type);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
init_GraphQLError();
init_kinds();

// node_modules/graphql/execution/collectFields.mjs
init_kinds();

// node_modules/graphql/execution/values.mjs
init_inspect();
init_GraphQLError();
init_kinds();
init_printer();

// node_modules/graphql/utilities/coerceInputValue.mjs
init_inspect();
init_invariant();
init_isObjectLike();
init_GraphQLError();

// node_modules/graphql/utilities/valueFromAST.mjs
init_inspect();
init_invariant();
init_kinds();
function valueFromAST(valueNode, type, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = /* @__PURE__ */ Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== void 0) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    return coercedObj;
  }
  if (isLeafType(type)) {
    let result;
    try {
      result = type.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === void 0) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}

// node_modules/graphql/execution/values.mjs
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(
          `Argument "${name}" of required type "${inspect(argType)}" was not provided.`,
          {
            nodes: node
          }
        );
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
            {
              nodes: valueNode
            }
          );
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError(
        `Argument "${name}" of non-null type "${inspect(argType)}" must not be null.`,
        {
          nodes: valueNode
        }
      );
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError(
        `Argument "${name}" has invalid value ${print(valueNode)}.`,
        {
          nodes: valueNode
        }
      );
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
    (directive) => directive.name.value === directiveDef.name
  );
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// node_modules/graphql/execution/collectFields.mjs
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
  const fields = /* @__PURE__ */ new Map();
  collectFieldsImpl(
    schema,
    fragments,
    variableValues,
    runtimeType,
    selectionSet,
    fields,
    /* @__PURE__ */ new Set()
  );
  return fields;
}
function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = /* @__PURE__ */ new Map();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(
        schema,
        fragments,
        variableValues,
        returnType,
        node.selectionSet,
        subFieldNodes,
        visitedFragmentNames
      );
    }
  }
  return subFieldNodes;
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name = getFieldEntryKey(selection);
        const fieldList = fields.get(name);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selection.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          fragment.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
    }
  }
}
function shouldIncludeNode(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(
    GraphQLIncludeDirective,
    node,
    variableValues
  );
  if ((include === null || include === void 0 ? void 0 : include.if) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema.isSubType(conditionalType, type);
  }
  return false;
}
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}

// node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node) {
      if (node.operation === "subscription") {
        const schema = context.getSchema();
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node.name ? node.name.value : null;
          const variableValues = /* @__PURE__ */ Object.create(null);
          const document = context.getDocument();
          const fragments = /* @__PURE__ */ Object.create(null);
          for (const definition of document.definitions) {
            if (definition.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition.name.value] = definition;
            }
          }
          const fields = collectFields(
            schema,
            fragments,
            variableValues,
            subscriptionType,
            node.selectionSet
          );
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(
              new GraphQLError(
                operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                {
                  nodes: extraFieldSelections
                }
              )
            );
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(
                new GraphQLError(
                  operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: fieldNodes
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}

// node_modules/graphql/jsutils/groupBy.mjs
function groupBy(list, keyFn) {
  const result = /* @__PURE__ */ new Map();
  for (const item of list) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group === void 0) {
      result.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result;
}

// node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
init_GraphQLError();
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `Argument "${parentName}(${argName}:)" can only be defined once.`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
init_GraphQLError();
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `There can be only one argument named "${argName}".`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
  }
}

// node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
init_GraphQLError();
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    DirectiveDefinition(node) {
      const directiveName = node.name.value;
      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
            {
              nodes: node.name
            }
          )
        );
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one directive named "@${directiveName}".`,
            {
              nodes: [knownDirectiveNames[directiveName], node.name]
            }
          )
        );
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
init_GraphQLError();
init_kinds();
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = /* @__PURE__ */ Object.create(null);
  const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
  return {
    enter(node) {
      if (!("directives" in node) || !node.directives) {
        return;
      }
      let seenDirectives;
      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        const typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
        }
      } else {
        seenDirectives = /* @__PURE__ */ Object.create(null);
      }
      for (const directive of node.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(
              new GraphQLError(
                `The directive "@${directiveName}" can only be used once at this location.`,
                {
                  nodes: [seenDirectives[directiveName], directive]
                }
              )
            );
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
init_GraphQLError();
function UniqueEnumValueNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownValueNames = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    const typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: valueDef.name
            }
          )
        );
      } else if (valueNames[valueName]) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" can only be defined once.`,
            {
              nodes: [valueNames[valueName], valueDef.name]
            }
          )
        );
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
init_GraphQLError();
function UniqueFieldDefinitionNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownFieldNames = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    const typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: fieldDef.name
            }
          )
        );
      } else if (fieldNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" can only be defined once.`,
            {
              nodes: [fieldNames[fieldName], fieldDef.name]
            }
          )
        );
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {
    return type.getFields()[fieldName] != null;
  }
  return false;
}

// node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
init_GraphQLError();
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      const fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one fragment named "${fragmentName}".`,
            {
              nodes: [knownFragmentNames[fragmentName], node.name]
            }
          )
        );
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
init_invariant();
init_GraphQLError();
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = /* @__PURE__ */ Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node) {
      const fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one input field named "${fieldName}".`,
            {
              nodes: [knownNames[fieldName], node.name]
            }
          )
        );
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}

// node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
init_GraphQLError();
function UniqueOperationNamesRule(context) {
  const knownOperationNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition(node) {
      const operationName = node.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(
            new GraphQLError(
              `There can be only one operation named "${operationName.value}".`,
              {
                nodes: [
                  knownOperationNames[operationName.value],
                  operationName
                ]
              }
            )
          );
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}

// node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
init_GraphQLError();
function UniqueOperationTypesRule(context) {
  const schema = context.getSchema();
  const definedOperationTypes = /* @__PURE__ */ Object.create(null);
  const existingOperationTypes = schema ? {
    query: schema.getQueryType(),
    mutation: schema.getMutationType(),
    subscription: schema.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(
          new GraphQLError(
            `Type for ${operation} already defined in the schema. It cannot be redefined.`,
            {
              nodes: operationType
            }
          )
        );
      } else if (alreadyDefinedOperationType) {
        context.reportError(
          new GraphQLError(
            `There can be only one ${operation} type in schema.`,
            {
              nodes: [alreadyDefinedOperationType, operationType]
            }
          )
        );
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
init_GraphQLError();
function UniqueTypeNamesRule(context) {
  const knownTypeNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    const typeName = node.name.value;
    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
      context.reportError(
        new GraphQLError(
          `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
          {
            nodes: node.name
          }
        )
      );
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(
        new GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node.name]
        })
      );
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
init_GraphQLError();
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(
        variableDefinitions,
        (node) => node.variable.name.value
      );
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `There can be only one variable named "$${variableName}".`,
              {
                nodes: variableNodes.map((node) => node.variable.name)
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
init_inspect();
init_GraphQLError();
init_printer();
function ValuesOfCorrectTypeRule(context) {
  return {
    ListValue(node) {
      const type = getNullableType(context.getParentInputType());
      if (!isListType(type)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue(node) {
      const type = getNamedType(context.getInputType());
      if (!isInputObjectType(type)) {
        isValidValueNode(context, node);
        return false;
      }
      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(
            new GraphQLError(
              `Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
              {
                nodes: node
              }
            )
          );
        }
      }
    },
    ObjectField(node) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(
          node.name.value,
          Object.keys(parentType.getFields())
        );
        context.reportError(
          new GraphQLError(
            `Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
            {
              nodes: node
            }
          )
        );
      }
    },
    NullValue(node) {
      const type = context.getInputType();
      if (isNonNullType(type)) {
        context.reportError(
          new GraphQLError(
            `Expected value of type "${inspect(type)}", found ${print(node)}.`,
            {
              nodes: node
            }
          )
        );
      }
    },
    EnumValue: (node) => isValidValueNode(context, node),
    IntValue: (node) => isValidValueNode(context, node),
    FloatValue: (node) => isValidValueNode(context, node),
    StringValue: (node) => isValidValueNode(context, node),
    BooleanValue: (node) => isValidValueNode(context, node)
  };
}
function isValidValueNode(context, node) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type = getNamedType(locationType);
  if (!isLeafType(type)) {
    const typeStr = inspect(locationType);
    context.reportError(
      new GraphQLError(
        `Expected value of type "${typeStr}", found ${print(node)}.`,
        {
          nodes: node
        }
      )
    );
    return;
  }
  try {
    const parseResult = type.parseLiteral(
      node,
      void 0
    );
    if (parseResult === void 0) {
      const typeStr = inspect(locationType);
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}.`,
          {
            nodes: node
          }
        )
      );
    }
  } catch (error) {
    const typeStr = inspect(locationType);
    if (error instanceof GraphQLError) {
      context.reportError(error);
    } else {
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}; ` + error.message,
          {
            nodes: node,
            originalError: error
          }
        )
      );
    }
  }
}

// node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
init_GraphQLError();
init_printer();
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.type);
      if (type !== void 0 && !isInputType(type)) {
        const variableName = node.variable.name.value;
        const typeName = print(node.type);
        context.reportError(
          new GraphQLError(
            `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
            {
              nodes: node.type
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
init_inspect();
init_GraphQLError();
init_kinds();
function VariablesInAllowedPositionRule(context) {
  let varDefMap = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node, type, defaultValue } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type) {
            const schema = context.getSchema();
            const varType = typeFromAST(schema, varDef.type);
            if (varType && !allowedVariableUsage(
              schema,
              varType,
              varDef.defaultValue,
              type,
              defaultValue
            )) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type);
              context.reportError(
                new GraphQLError(
                  `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                  {
                    nodes: [varDef, node]
                  }
                )
              );
            }
          }
        }
      }
    },
    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema, varType, locationType);
}

// node_modules/graphql/validation/specifiedRules.mjs
var specifiedRules = Object.freeze([
  ExecutableDefinitionsRule,
  UniqueOperationNamesRule,
  LoneAnonymousOperationRule,
  SingleFieldSubscriptionsRule,
  KnownTypeNamesRule,
  FragmentsOnCompositeTypesRule,
  VariablesAreInputTypesRule,
  ScalarLeafsRule,
  FieldsOnCorrectTypeRule,
  UniqueFragmentNamesRule,
  KnownFragmentNamesRule,
  NoUnusedFragmentsRule,
  PossibleFragmentSpreadsRule,
  NoFragmentCyclesRule,
  UniqueVariableNamesRule,
  NoUndefinedVariablesRule,
  NoUnusedVariablesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  KnownArgumentNamesRule,
  UniqueArgumentNamesRule,
  ValuesOfCorrectTypeRule,
  ProvidedRequiredArgumentsRule,
  VariablesInAllowedPositionRule,
  OverlappingFieldsCanBeMergedRule,
  UniqueInputFieldNamesRule
]);
var specifiedSDLRules = Object.freeze([
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  KnownArgumentNamesOnDirectivesRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule,
  ProvidedRequiredArgumentsOnDirectivesRule
]);

// node_modules/graphql/validation/ValidationContext.mjs
init_kinds();
init_visitor();
var ASTValidationContext = class {
  constructor(ast, onError) {
    this._ast = ast;
    this._fragments = void 0;
    this._fragmentSpreads = /* @__PURE__ */ new Map();
    this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
    this._onError = onError;
  }
  get [Symbol.toStringTag]() {
    return "ASTValidationContext";
  }
  reportError(error) {
    this._onError(error);
  }
  getDocument() {
    return this._ast;
  }
  getFragment(name) {
    let fragments;
    if (this._fragments) {
      fragments = this._fragments;
    } else {
      fragments = /* @__PURE__ */ Object.create(null);
      for (const defNode of this.getDocument().definitions) {
        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {
          fragments[defNode.name.value] = defNode;
        }
      }
      this._fragments = fragments;
    }
    return fragments[name];
  }
  getFragmentSpreads(node) {
    let spreads = this._fragmentSpreads.get(node);
    if (!spreads) {
      spreads = [];
      const setsToVisit = [node];
      let set;
      while (set = setsToVisit.pop()) {
        for (const selection of set.selections) {
          if (selection.kind === Kind.FRAGMENT_SPREAD) {
            spreads.push(selection);
          } else if (selection.selectionSet) {
            setsToVisit.push(selection.selectionSet);
          }
        }
      }
      this._fragmentSpreads.set(node, spreads);
    }
    return spreads;
  }
  getRecursivelyReferencedFragments(operation) {
    let fragments = this._recursivelyReferencedFragments.get(operation);
    if (!fragments) {
      fragments = [];
      const collectedNames = /* @__PURE__ */ Object.create(null);
      const nodesToVisit = [operation.selectionSet];
      let node;
      while (node = nodesToVisit.pop()) {
        for (const spread of this.getFragmentSpreads(node)) {
          const fragName = spread.name.value;
          if (collectedNames[fragName] !== true) {
            collectedNames[fragName] = true;
            const fragment = this.getFragment(fragName);
            if (fragment) {
              fragments.push(fragment);
              nodesToVisit.push(fragment.selectionSet);
            }
          }
        }
      }
      this._recursivelyReferencedFragments.set(operation, fragments);
    }
    return fragments;
  }
};
var SDLValidationContext = class extends ASTValidationContext {
  constructor(ast, schema, onError) {
    super(ast, onError);
    this._schema = schema;
  }
  get [Symbol.toStringTag]() {
    return "SDLValidationContext";
  }
  getSchema() {
    return this._schema;
  }
};
var ValidationContext = class extends ASTValidationContext {
  constructor(schema, ast, typeInfo, onError) {
    super(ast, onError);
    this._schema = schema;
    this._typeInfo = typeInfo;
    this._variableUsages = /* @__PURE__ */ new Map();
    this._recursiveVariableUsages = /* @__PURE__ */ new Map();
  }
  get [Symbol.toStringTag]() {
    return "ValidationContext";
  }
  getSchema() {
    return this._schema;
  }
  getVariableUsages(node) {
    let usages = this._variableUsages.get(node);
    if (!usages) {
      const newUsages = [];
      const typeInfo = new TypeInfo(this._schema);
      visit(
        node,
        visitWithTypeInfo(typeInfo, {
          VariableDefinition: () => false,
          Variable(variable) {
            newUsages.push({
              node: variable,
              type: typeInfo.getInputType(),
              defaultValue: typeInfo.getDefaultValue()
            });
          }
        })
      );
      usages = newUsages;
      this._variableUsages.set(node, usages);
    }
    return usages;
  }
  getRecursiveVariableUsages(operation) {
    let usages = this._recursiveVariableUsages.get(operation);
    if (!usages) {
      usages = this.getVariableUsages(operation);
      for (const frag of this.getRecursivelyReferencedFragments(operation)) {
        usages = usages.concat(this.getVariableUsages(frag));
      }
      this._recursiveVariableUsages.set(operation, usages);
    }
    return usages;
  }
  getType() {
    return this._typeInfo.getType();
  }
  getParentType() {
    return this._typeInfo.getParentType();
  }
  getInputType() {
    return this._typeInfo.getInputType();
  }
  getParentInputType() {
    return this._typeInfo.getParentInputType();
  }
  getFieldDef() {
    return this._typeInfo.getFieldDef();
  }
  getDirective() {
    return this._typeInfo.getDirective();
  }
  getArgument() {
    return this._typeInfo.getArgument();
  }
  getEnumValue() {
    return this._typeInfo.getEnumValue();
  }
};

// node_modules/graphql/execution/execute.mjs
init_devAssert();
init_inspect();
init_invariant();
init_isObjectLike();

// node_modules/graphql/jsutils/memoize3.mjs
function memoize3(fn) {
  let cache0;
  return function memoized(a1, a22, a32) {
    if (cache0 === void 0) {
      cache0 = /* @__PURE__ */ new WeakMap();
    }
    let cache1 = cache0.get(a1);
    if (cache1 === void 0) {
      cache1 = /* @__PURE__ */ new WeakMap();
      cache0.set(a1, cache1);
    }
    let cache2 = cache1.get(a22);
    if (cache2 === void 0) {
      cache2 = /* @__PURE__ */ new WeakMap();
      cache1.set(a22, cache2);
    }
    let fnResult = cache2.get(a32);
    if (fnResult === void 0) {
      fnResult = fn(a1, a22, a32);
      cache2.set(a32, fnResult);
    }
    return fnResult;
  };
}

// node_modules/graphql/execution/execute.mjs
init_GraphQLError();

// node_modules/graphql/jsutils/toError.mjs
init_inspect();

// node_modules/graphql/error/locatedError.mjs
init_GraphQLError();

// node_modules/graphql/execution/execute.mjs
init_ast();
init_kinds();
var collectSubfields2 = memoize3(
  (exeContext, returnType, fieldNodes) => collectSubfields(
    exeContext.schema,
    exeContext.fragments,
    exeContext.variableValues,
    returnType,
    fieldNodes
  )
);

// node_modules/graphql/language/index.mjs
init_source();
init_location();
init_printLocation();
init_kinds();
init_tokenKind();
init_lexer();
init_parser();
init_printer();
init_visitor();
init_ast();
init_directiveLocation();

// node_modules/graphql/execution/subscribe.mjs
init_devAssert();
init_inspect();
init_GraphQLError();

// node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs
init_invariant();
init_GraphQLError();

// node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs
init_GraphQLError();

// node_modules/graphql/error/index.mjs
init_GraphQLError();
init_syntaxError();

// node_modules/graphql/utilities/getOperationAST.mjs
init_kinds();

// node_modules/graphql/utilities/getOperationRootType.mjs
init_GraphQLError();

// node_modules/graphql/utilities/introspectionFromSchema.mjs
init_invariant();
init_parser();

// node_modules/graphql/utilities/buildClientSchema.mjs
init_devAssert();
init_inspect();
init_isObjectLike();
init_parser();

// node_modules/graphql/utilities/buildASTSchema.mjs
init_devAssert();
init_kinds();
init_parser();

// node_modules/graphql/utilities/extendSchema.mjs
init_devAssert();
init_inspect();
init_invariant();
init_kinds();
var stdTypeMap = keyMap(
  [...specifiedScalarTypes, ...introspectionTypes],
  (type) => type.name
);

// node_modules/graphql/utilities/lexicographicSortSchema.mjs
init_inspect();
init_invariant();

// node_modules/graphql/utilities/printSchema.mjs
init_inspect();
init_invariant();
init_blockString();
init_kinds();
init_printer();

// node_modules/graphql/utilities/concatAST.mjs
init_kinds();

// node_modules/graphql/utilities/separateOperations.mjs
init_kinds();
init_visitor();

// node_modules/graphql/utilities/stripIgnoredCharacters.mjs
init_blockString();
init_lexer();
init_source();
init_tokenKind();

// node_modules/graphql/utilities/assertValidName.mjs
init_devAssert();
init_GraphQLError();

// node_modules/graphql/utilities/findBreakingChanges.mjs
init_inspect();
init_invariant();
init_printer();
var BreakingChangeType;
(function(BreakingChangeType2) {
  BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
  BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
  BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
  BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
  BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
  BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
  BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
  BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
  BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
  BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
  BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
  BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
  BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
  BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
  BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
  BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
})(BreakingChangeType || (BreakingChangeType = {}));
var DangerousChangeType;
(function(DangerousChangeType2) {
  DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
  DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
  DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
  DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
  DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
  DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
})(DangerousChangeType || (DangerousChangeType = {}));

// node_modules/graphql-tag/lib/index.js
var docCache = /* @__PURE__ */ new Map();
var fragmentSourceMap = /* @__PURE__ */ new Map();
var printFragmentWarnings = true;
var experimentalFragmentVariables = false;
function normalize(string) {
  return string.replace(/[\s,]+/g, " ").trim();
}
function cacheKeyFromLoc(loc) {
  return normalize(loc.source.body.substring(loc.start, loc.end));
}
function processFragments(ast) {
  var seenKeys = /* @__PURE__ */ new Set();
  var definitions = [];
  ast.definitions.forEach(function(fragmentDefinition) {
    if (fragmentDefinition.kind === "FragmentDefinition") {
      var fragmentName = fragmentDefinition.name.value;
      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
      var sourceKeySet = fragmentSourceMap.get(fragmentName);
      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
        if (printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }
      } else if (!sourceKeySet) {
        fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
      }
      sourceKeySet.add(sourceKey);
      if (!seenKeys.has(sourceKey)) {
        seenKeys.add(sourceKey);
        definitions.push(fragmentDefinition);
      }
    } else {
      definitions.push(fragmentDefinition);
    }
  });
  return __assign(__assign({}, ast), { definitions });
}
function stripLoc(doc) {
  var workSet = new Set(doc.definitions);
  workSet.forEach(function(node) {
    if (node.loc)
      delete node.loc;
    Object.keys(node).forEach(function(key) {
      var value = node[key];
      if (value && typeof value === "object") {
        workSet.add(value);
      }
    });
  });
  var loc = doc.loc;
  if (loc) {
    delete loc.startToken;
    delete loc.endToken;
  }
  return doc;
}
function parseDocument(source) {
  var cacheKey = normalize(source);
  if (!docCache.has(cacheKey)) {
    var parsed = parse(source, {
      experimentalFragmentVariables,
      allowLegacyFragmentVariables: experimentalFragmentVariables
    });
    if (!parsed || parsed.kind !== "Document") {
      throw new Error("Not a valid GraphQL document.");
    }
    docCache.set(cacheKey, stripLoc(processFragments(parsed)));
  }
  return docCache.get(cacheKey);
}
function gql(literals) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (typeof literals === "string") {
    literals = [literals];
  }
  var result = literals[0];
  args.forEach(function(arg, i7) {
    if (arg && arg.kind === "Document") {
      result += arg.loc.source.body;
    } else {
      result += arg;
    }
    result += literals[i7 + 1];
  });
  return parseDocument(result);
}
function resetCaches() {
  docCache.clear();
  fragmentSourceMap.clear();
}
function disableFragmentWarnings() {
  printFragmentWarnings = false;
}
function enableExperimentalFragmentVariables() {
  experimentalFragmentVariables = true;
}
function disableExperimentalFragmentVariables() {
  experimentalFragmentVariables = false;
}
var extras = {
  gql,
  resetCaches,
  disableFragmentWarnings,
  enableExperimentalFragmentVariables,
  disableExperimentalFragmentVariables
};
(function(gql_1) {
  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
})(gql || (gql = {}));
gql["default"] = gql;
var lib_default = gql;

// node_modules/@fuel-ts/interfaces/dist/index.mjs
var s2 = class {
};
var r = class {
};
var a = class {
};
var e = class {
};
var c4 = class {
};

// node_modules/@fuel-ts/address/dist/index.mjs
var import_bech32 = __toESM(require_dist(), 1);
var S3 = new Logger(process.env.BUILD_VERSION || "~");
var o = "fuel";
function c5(r2) {
  return import_bech32.bech32m.decode(r2);
}
function i4(r2) {
  return import_bech32.bech32m.encode(o, import_bech32.bech32m.toWords(arrayify(hexlify(r2))));
}
function n2(r2) {
  return typeof r2 == "string" && r2.indexOf(o + 1) === 0 && c5(r2).prefix === o;
}
function h2(r2) {
  return new Uint8Array(import_bech32.bech32m.fromWords(c5(r2).words));
}
function m2(r2) {
  return n2(r2) || S3.throwArgumentError("Invalid Bech32 Address", "address", r2), hexlify(h2(r2));
}
function u2(r2) {
  let { words: A6 } = c5(r2);
  return import_bech32.bech32m.encode(o, A6);
}
var D2 = (r2) => r2 instanceof e ? r2.address : r2 instanceof a ? r2.id : r2;
var a2 = () => hexlify(u(32));
var p = new Logger(process.env.BUILD_VERSION || "~");
var t2 = class extends r {
  constructor(e2) {
    super();
    p.checkNew(new.target, t2), this.bech32Address = u2(e2), n2(this.bech32Address) || p.throwArgumentError("Invalid Bech32 Address", "address", e2);
  }
  toAddress() {
    return this.bech32Address;
  }
  toB256() {
    return m2(this.bech32Address);
  }
  toBytes() {
    return h2(this.bech32Address);
  }
  toHexString() {
    return this.toB256();
  }
  toString() {
    return this.bech32Address;
  }
  toJSON() {
    return this.toString();
  }
  valueOf() {
    return this.toString();
  }
  equals(e2) {
    return this.bech32Address === e2.bech32Address;
  }
  static fromPublicKey(e2) {
    let g4 = sha256(e2);
    return new t2(i4(g4));
  }
  static fromB256(e2) {
    return new t2(i4(e2));
  }
  static fromRandom() {
    return this.fromB256(a2());
  }
  static fromString(e2) {
    return n2(e2) ? new t2(e2) : this.fromB256(e2);
  }
  static fromAddressOrString(e2) {
    return typeof e2 == "string" ? this.fromString(e2) : e2;
  }
};

// node_modules/@fuel-ts/transactions/dist/index.mjs
var Ce = (d3, e2, o4) => {
  if (!e2.has(d3))
    throw TypeError("Cannot " + o4);
};
var X2 = (d3, e2, o4) => (Ce(d3, e2, "read from private field"), o4 ? o4.call(d3) : e2.get(d3));
var be = (d3, e2, o4) => {
  if (e2.has(d3))
    throw TypeError("Cannot add the same private member more than once");
  e2 instanceof WeakSet ? e2.add(d3) : e2.set(d3, o4);
};
var Ie = (d3, e2, o4, n3) => (Ce(d3, e2, "write to private field"), n3 ? n3.call(d3, o4) : e2.set(d3, o4), o4);
var O3;
var a3 = class extends i2 {
  constructor(o4) {
    let n3 = (8 - o4 % 8) % 8, t5 = o4 + n3;
    super("ByteArray", `[u64; ${t5 / 4}]`, t5);
    be(this, O3, void 0);
    this.length = o4, Ie(this, O3, n3);
  }
  encode(o4) {
    let n3 = [], t5 = arrayify(o4);
    return n3.push(t5), X2(this, O3) && n3.push(new Uint8Array(X2(this, O3))), concat(n3);
  }
  decode(o4, n3) {
    let t5, s4 = n3;
    [t5, s4] = [hexlify(o4.slice(s4, s4 + this.length)), s4 + this.length];
    let c9 = t5;
    return X2(this, O3) && ([t5, s4] = [null, s4 + X2(this, O3)]), [c9, s4];
  }
};
O3 = /* @__PURE__ */ new WeakMap();
var l2 = class extends k {
  constructor() {
    super("TxPointer", { blockHeight: new S2("u32"), txIndex: new S2("u16") });
  }
};
var S4 = class extends k {
  constructor() {
    super("UtxoId", { transactionId: new D(), outputIndex: new S2("u8") });
  }
};
var We = ((n3) => (n3[n3.Coin = 0] = "Coin", n3[n3.Contract = 1] = "Contract", n3[n3.Message = 2] = "Message", n3))(We || {});
var F2 = class extends i2 {
  constructor() {
    super("InputCoin", "struct InputCoin", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new S4().encode(e2.utxoID)), o4.push(new D().encode(e2.owner)), o4.push(new l().encode(e2.amount)), o4.push(new D().encode(e2.assetId)), o4.push(new l2().encode(e2.txPointer)), o4.push(new S2("u8").encode(e2.witnessIndex)), o4.push(new S2("u32").encode(e2.maturity)), o4.push(new S2("u16").encode(e2.predicateLength)), o4.push(new S2("u16").encode(e2.predicateDataLength)), o4.push(new a3(e2.predicateLength).encode(e2.predicate)), o4.push(new a3(e2.predicateDataLength).encode(e2.predicateData)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new S4().decode(e2, t5);
    let s4 = n3;
    [n3, t5] = new D().decode(e2, t5);
    let c9 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let i7 = n3;
    [n3, t5] = new D().decode(e2, t5);
    let w8 = n3;
    [n3, t5] = new l2().decode(e2, t5);
    let h5 = n3;
    [n3, t5] = new S2("u8").decode(e2, t5);
    let g4 = Number(n3);
    [n3, t5] = new S2("u32").decode(e2, t5);
    let u4 = n3;
    [n3, t5] = new S2("u16").decode(e2, t5);
    let x6 = n3;
    [n3, t5] = new S2("u16").decode(e2, t5);
    let A6 = n3;
    [n3, t5] = new a3(x6).decode(e2, t5);
    let D7 = n3;
    return [n3, t5] = new a3(A6).decode(e2, t5), [{ type: 0, utxoID: s4, owner: c9, amount: i7, assetId: w8, txPointer: h5, witnessIndex: g4, maturity: u4, predicateLength: x6, predicateDataLength: A6, predicate: D7, predicateData: n3 }, t5];
  }
};
var j2 = class extends i2 {
  constructor() {
    super("InputContract", "struct InputContract", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new S4().encode(e2.utxoID)), o4.push(new D().encode(e2.balanceRoot)), o4.push(new D().encode(e2.stateRoot)), o4.push(new l2().encode(e2.txPointer)), o4.push(new D().encode(e2.contractID)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new S4().decode(e2, t5);
    let s4 = n3;
    [n3, t5] = new D().decode(e2, t5);
    let c9 = n3;
    [n3, t5] = new D().decode(e2, t5);
    let i7 = n3;
    [n3, t5] = new l2().decode(e2, t5);
    let w8 = n3;
    return [n3, t5] = new D().decode(e2, t5), [{ type: 1, utxoID: s4, balanceRoot: c9, stateRoot: i7, txPointer: w8, contractID: n3 }, t5];
  }
};
var W2 = class extends i2 {
  constructor() {
    super("InputMessage", "struct InputMessage", 0);
  }
  static getMessageId(e2) {
    let o4 = [];
    return o4.push(new a3(32).encode(e2.sender)), o4.push(new a3(32).encode(e2.recipient)), o4.push(new l().encode(e2.nonce)), o4.push(new l().encode(e2.amount)), o4.push(new a3(e2.dataLength).encode(e2.data)), sha256(concat(o4));
  }
  encode(e2) {
    let o4 = [], n3 = new a3(e2.dataLength).encode(e2.data), t5 = W2.getMessageId(e2);
    return o4.push(new a3(32).encode(t5)), o4.push(new a3(32).encode(e2.sender)), o4.push(new a3(32).encode(e2.recipient)), o4.push(new l().encode(e2.amount)), o4.push(new l().encode(e2.nonce)), o4.push(new S2("u8").encode(e2.witnessIndex)), o4.push(new S2("u16").encode(n3.length)), o4.push(new S2("u16").encode(e2.predicateLength)), o4.push(new S2("u16").encode(e2.predicateDataLength)), o4.push(n3), o4.push(new a3(e2.predicateLength).encode(e2.predicate)), o4.push(new a3(e2.predicateDataLength).encode(e2.predicateData)), concat(o4);
  }
  static decodeData(e2) {
    let o4 = arrayify(e2), n3 = o4.length, [t5] = new a3(n3).decode(o4, 0);
    return arrayify(t5);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new D().decode(e2, t5);
    let s4 = n3;
    [n3, t5] = new D().decode(e2, t5);
    let c9 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let i7 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let w8 = n3;
    [n3, t5] = new S2("u8").decode(e2, t5);
    let h5 = Number(n3);
    [n3, t5] = new S2("u16").decode(e2, t5);
    let g4 = n3;
    [n3, t5] = new S2("u16").decode(e2, t5);
    let u4 = n3;
    [n3, t5] = new S2("u16").decode(e2, t5);
    let x6 = n3;
    [n3, t5] = new a3(g4).decode(e2, t5);
    let A6 = n3;
    [n3, t5] = new a3(u4).decode(e2, t5);
    let D7 = n3;
    return [n3, t5] = new a3(x6).decode(e2, t5), [{ type: 2, sender: s4, recipient: c9, amount: i7, witnessIndex: h5, nonce: w8, data: A6, dataLength: g4, predicateLength: u4, predicateDataLength: x6, predicate: D7, predicateData: n3 }, t5];
  }
};
var M2 = class extends i2 {
  constructor() {
    super("Input", "struct Input", 0);
  }
  encode(e2) {
    let o4 = [];
    switch (o4.push(new S2("u8").encode(e2.type)), e2.type) {
      case 0: {
        o4.push(new F2().encode(e2));
        break;
      }
      case 1: {
        o4.push(new j2().encode(e2));
        break;
      }
      case 2: {
        o4.push(new W2().encode(e2));
        break;
      }
      default:
        throw new Error("Invalid Input type");
    }
    return concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    switch ([n3, t5] = new S2("u8").decode(e2, t5), n3) {
      case 0:
        return [n3, t5] = new F2().decode(e2, t5), [n3, t5];
      case 1:
        return [n3, t5] = new j2().decode(e2, t5), [n3, t5];
      case 2:
        return [n3, t5] = new W2().decode(e2, t5), [n3, t5];
      default:
        throw new Error("Invalid Input type");
    }
  }
};
var Ve = ((c9) => (c9[c9.Coin = 0] = "Coin", c9[c9.Contract = 1] = "Contract", c9[c9.Message = 2] = "Message", c9[c9.Change = 3] = "Change", c9[c9.Variable = 4] = "Variable", c9[c9.ContractCreated = 5] = "ContractCreated", c9))(Ve || {});
var $3 = class extends i2 {
  constructor() {
    super("OutputCoin", "struct OutputCoin", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new D().encode(e2.to)), o4.push(new l().encode(e2.amount)), o4.push(new D().encode(e2.assetId)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new D().decode(e2, t5);
    let s4 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let c9 = n3;
    return [n3, t5] = new D().decode(e2, t5), [{ type: 0, to: s4, amount: c9, assetId: n3 }, t5];
  }
};
var q2 = class extends i2 {
  constructor() {
    super("OutputContract", "struct OutputContract", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new S2("u8").encode(e2.inputIndex)), o4.push(new D().encode(e2.balanceRoot)), o4.push(new D().encode(e2.stateRoot)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new S2("u8").decode(e2, t5);
    let s4 = n3;
    [n3, t5] = new D().decode(e2, t5);
    let c9 = n3;
    return [n3, t5] = new D().decode(e2, t5), [{ type: 1, inputIndex: s4, balanceRoot: c9, stateRoot: n3 }, t5];
  }
};
var z2 = class extends i2 {
  constructor() {
    super("OutputMessage", "struct OutputMessage", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new D().encode(e2.recipient)), o4.push(new l().encode(e2.amount)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new D().decode(e2, t5);
    let s4 = n3;
    return [n3, t5] = new l().decode(e2, t5), [{ type: 2, recipient: s4, amount: n3 }, t5];
  }
};
var J2 = class extends i2 {
  constructor() {
    super("OutputChange", "struct OutputChange", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new D().encode(e2.to)), o4.push(new l().encode(e2.amount)), o4.push(new D().encode(e2.assetId)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new D().decode(e2, t5);
    let s4 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let c9 = n3;
    return [n3, t5] = new D().decode(e2, t5), [{ type: 3, to: s4, amount: c9, assetId: n3 }, t5];
  }
};
var K2 = class extends i2 {
  constructor() {
    super("OutputVariable", "struct OutputVariable", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new D().encode(e2.to)), o4.push(new l().encode(e2.amount)), o4.push(new D().encode(e2.assetId)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new D().decode(e2, t5);
    let s4 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let c9 = n3;
    return [n3, t5] = new D().decode(e2, t5), [{ type: 4, to: s4, amount: c9, assetId: n3 }, t5];
  }
};
var Q3 = class extends i2 {
  constructor() {
    super("OutputContractCreated", "struct OutputContractCreated", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new D().encode(e2.contractId)), o4.push(new D().encode(e2.stateRoot)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new D().decode(e2, t5);
    let s4 = n3;
    return [n3, t5] = new D().decode(e2, t5), [{ type: 5, contractId: s4, stateRoot: n3 }, t5];
  }
};
var P2 = class extends i2 {
  constructor() {
    super("Output", " struct Output", 0);
  }
  encode(e2) {
    let o4 = [];
    switch (o4.push(new S2("u8").encode(e2.type)), e2.type) {
      case 0: {
        o4.push(new $3().encode(e2));
        break;
      }
      case 1: {
        o4.push(new q2().encode(e2));
        break;
      }
      case 2: {
        o4.push(new z2().encode(e2));
        break;
      }
      case 3: {
        o4.push(new J2().encode(e2));
        break;
      }
      case 4: {
        o4.push(new K2().encode(e2));
        break;
      }
      case 5: {
        o4.push(new Q3().encode(e2));
        break;
      }
      default:
        throw new Error("Invalid Output type");
    }
    return concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    switch ([n3, t5] = new S2("u8").decode(e2, t5), n3) {
      case 0:
        return [n3, t5] = new $3().decode(e2, t5), [n3, t5];
      case 1:
        return [n3, t5] = new q2().decode(e2, t5), [n3, t5];
      case 2:
        return [n3, t5] = new z2().decode(e2, t5), [n3, t5];
      case 3:
        return [n3, t5] = new J2().decode(e2, t5), [n3, t5];
      case 4:
        return [n3, t5] = new K2().decode(e2, t5), [n3, t5];
      case 5:
        return [n3, t5] = new Q3().decode(e2, t5), [n3, t5];
      default:
        throw new Error("Invalid Output type");
    }
  }
};
var Ge = ((u4) => (u4[u4.Call = 0] = "Call", u4[u4.Return = 1] = "Return", u4[u4.ReturnData = 2] = "ReturnData", u4[u4.Panic = 3] = "Panic", u4[u4.Revert = 4] = "Revert", u4[u4.Log = 5] = "Log", u4[u4.LogData = 6] = "LogData", u4[u4.Transfer = 7] = "Transfer", u4[u4.TransferOut = 8] = "TransferOut", u4[u4.ScriptResult = 9] = "ScriptResult", u4[u4.MessageOut = 10] = "MessageOut", u4))(Ge || {});
var ee = class extends i2 {
  constructor() {
    super("ReceiptCall", "struct ReceiptCall", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new D().encode(e2.from)), o4.push(new D().encode(e2.to)), o4.push(new l().encode(e2.amount)), o4.push(new D().encode(e2.assetId)), o4.push(new l().encode(e2.gas)), o4.push(new l().encode(e2.param1)), o4.push(new l().encode(e2.param2)), o4.push(new l().encode(e2.pc)), o4.push(new l().encode(e2.is)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new D().decode(e2, t5);
    let s4 = n3;
    [n3, t5] = new D().decode(e2, t5);
    let c9 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let i7 = n3;
    [n3, t5] = new D().decode(e2, t5);
    let w8 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let h5 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let g4 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let u4 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let x6 = n3;
    return [n3, t5] = new l().decode(e2, t5), [{ type: 0, from: s4, to: c9, amount: i7, assetId: w8, gas: h5, param1: g4, param2: u4, pc: x6, is: n3 }, t5];
  }
};
var te = class extends i2 {
  constructor() {
    super("ReceiptReturn", "struct ReceiptReturn", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new D().encode(e2.id)), o4.push(new l().encode(e2.val)), o4.push(new l().encode(e2.pc)), o4.push(new l().encode(e2.is)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new D().decode(e2, t5);
    let s4 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let c9 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let i7 = n3;
    return [n3, t5] = new l().decode(e2, t5), [{ type: 1, id: s4, val: c9, pc: i7, is: n3 }, t5];
  }
};
var ne = class extends i2 {
  constructor() {
    super("ReceiptReturnData", "struct ReceiptReturnData", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new D().encode(e2.id)), o4.push(new l().encode(e2.ptr)), o4.push(new l().encode(e2.len)), o4.push(new D().encode(e2.digest)), o4.push(new l().encode(e2.pc)), o4.push(new l().encode(e2.is)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new D().decode(e2, t5);
    let s4 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let c9 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let i7 = n3;
    [n3, t5] = new D().decode(e2, t5);
    let w8 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let h5 = n3;
    return [n3, t5] = new l().decode(e2, t5), [{ type: 2, id: s4, ptr: c9, len: i7, digest: w8, pc: h5, is: n3 }, t5];
  }
};
var oe = class extends i2 {
  constructor() {
    super("ReceiptPanic", "struct ReceiptPanic", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new D().encode(e2.id)), o4.push(new l().encode(e2.reason)), o4.push(new l().encode(e2.pc)), o4.push(new l().encode(e2.is)), o4.push(new D().encode(e2.contractId)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new D().decode(e2, t5);
    let s4 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let c9 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let i7 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let w8 = n3;
    return [n3, t5] = new D().decode(e2, t5), [{ type: 3, id: s4, reason: c9, pc: i7, is: w8, contractId: n3 }, t5];
  }
};
var re2 = class extends i2 {
  constructor() {
    super("ReceiptRevert", "struct ReceiptRevert", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new D().encode(e2.id)), o4.push(new l().encode(e2.val)), o4.push(new l().encode(e2.pc)), o4.push(new l().encode(e2.is)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new D().decode(e2, t5);
    let s4 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let c9 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let i7 = n3;
    return [n3, t5] = new l().decode(e2, t5), [{ type: 4, id: s4, val: c9, pc: i7, is: n3 }, t5];
  }
};
var se = class extends i2 {
  constructor() {
    super("ReceiptLog", "struct ReceiptLog", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new D().encode(e2.id)), o4.push(new l().encode(e2.val0)), o4.push(new l().encode(e2.val1)), o4.push(new l().encode(e2.val2)), o4.push(new l().encode(e2.val3)), o4.push(new l().encode(e2.pc)), o4.push(new l().encode(e2.is)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new D().decode(e2, t5);
    let s4 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let c9 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let i7 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let w8 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let h5 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let g4 = n3;
    return [n3, t5] = new l().decode(e2, t5), [{ type: 5, id: s4, val0: c9, val1: i7, val2: w8, val3: h5, pc: g4, is: n3 }, t5];
  }
};
var ce2 = class extends i2 {
  constructor() {
    super("ReceiptLogData", "struct ReceiptLogData", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new D().encode(e2.id)), o4.push(new l().encode(e2.val0)), o4.push(new l().encode(e2.val1)), o4.push(new l().encode(e2.ptr)), o4.push(new l().encode(e2.len)), o4.push(new D().encode(e2.digest)), o4.push(new l().encode(e2.pc)), o4.push(new l().encode(e2.is)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new D().decode(e2, t5);
    let s4 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let c9 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let i7 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let w8 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let h5 = n3;
    [n3, t5] = new D().decode(e2, t5);
    let g4 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let u4 = n3;
    return [n3, t5] = new l().decode(e2, t5), [{ type: 6, id: s4, val0: c9, val1: i7, ptr: w8, len: h5, digest: g4, pc: u4, is: n3 }, t5];
  }
};
var pe2 = class extends i2 {
  constructor() {
    super("ReceiptTransfer", "struct ReceiptTransfer", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new D().encode(e2.from)), o4.push(new D().encode(e2.to)), o4.push(new l().encode(e2.amount)), o4.push(new D().encode(e2.assetId)), o4.push(new l().encode(e2.pc)), o4.push(new l().encode(e2.is)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new D().decode(e2, t5);
    let s4 = n3;
    [n3, t5] = new D().decode(e2, t5);
    let c9 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let i7 = n3;
    [n3, t5] = new D().decode(e2, t5);
    let w8 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let h5 = n3;
    return [n3, t5] = new l().decode(e2, t5), [{ type: 7, from: s4, to: c9, amount: i7, assetId: w8, pc: h5, is: n3 }, t5];
  }
};
var de = class extends i2 {
  constructor() {
    super("ReceiptTransferOut", "struct ReceiptTransferOut", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new D().encode(e2.from)), o4.push(new D().encode(e2.to)), o4.push(new l().encode(e2.amount)), o4.push(new D().encode(e2.assetId)), o4.push(new l().encode(e2.pc)), o4.push(new l().encode(e2.is)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new D().decode(e2, t5);
    let s4 = n3;
    [n3, t5] = new D().decode(e2, t5);
    let c9 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let i7 = n3;
    [n3, t5] = new D().decode(e2, t5);
    let w8 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let h5 = n3;
    return [n3, t5] = new l().decode(e2, t5), [{ type: 8, from: s4, to: c9, amount: i7, assetId: w8, pc: h5, is: n3 }, t5];
  }
};
var ue2 = class extends i2 {
  constructor() {
    super("ReceiptScriptResult", "struct ReceiptScriptResult", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new l().encode(e2.result)), o4.push(new l().encode(e2.gasUsed)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new l().decode(e2, t5);
    let s4 = n3;
    return [n3, t5] = new l().decode(e2, t5), [{ type: 9, result: s4, gasUsed: n3 }, t5];
  }
};
var ie2 = class extends i2 {
  constructor() {
    super("ReceiptMessageOut", "struct ReceiptMessageOut", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new D().encode(e2.messageID)), o4.push(new D().encode(e2.sender)), o4.push(new D().encode(e2.recipient)), o4.push(new l().encode(e2.amount)), o4.push(new D().encode(e2.nonce)), o4.push(new S2("u16").encode(e2.data.length)), o4.push(new D().encode(e2.digest)), o4.push(new a3(e2.data.length).encode(e2.data)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new D().decode(e2, t5);
    let s4 = n3;
    [n3, t5] = new D().decode(e2, t5);
    let c9 = n3;
    [n3, t5] = new D().decode(e2, t5);
    let i7 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let w8 = n3;
    [n3, t5] = new D().decode(e2, t5);
    let h5 = n3;
    [n3, t5] = new S2("u16").decode(e2, t5);
    let g4 = n3;
    [n3, t5] = new D().decode(e2, t5);
    let u4 = n3;
    [n3, t5] = new a3(g4).decode(e2, t5);
    let x6 = arrayify(n3);
    return [{ type: 10, messageID: s4, sender: c9, recipient: i7, amount: w8, nonce: h5, digest: u4, data: x6 }, t5];
  }
};
var fe2 = class extends i2 {
  constructor() {
    super("Receipt", "struct Receipt", 0);
  }
  encode(e2) {
    let o4 = [];
    switch (o4.push(new S2("u8").encode(e2.type)), e2.type) {
      case 0: {
        o4.push(new ee().encode(e2));
        break;
      }
      case 1: {
        o4.push(new te().encode(e2));
        break;
      }
      case 2: {
        o4.push(new ne().encode(e2));
        break;
      }
      case 3: {
        o4.push(new oe().encode(e2));
        break;
      }
      case 4: {
        o4.push(new re2().encode(e2));
        break;
      }
      case 5: {
        o4.push(new se().encode(e2));
        break;
      }
      case 6: {
        o4.push(new ce2().encode(e2));
        break;
      }
      case 7: {
        o4.push(new pe2().encode(e2));
        break;
      }
      case 8: {
        o4.push(new de().encode(e2));
        break;
      }
      case 9: {
        o4.push(new ue2().encode(e2));
        break;
      }
      case 10: {
        o4.push(new ie2().encode(e2));
        break;
      }
      default:
        throw new Error("Invalid Receipt type");
    }
    return concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    switch ([n3, t5] = new S2("u8").decode(e2, t5), n3) {
      case 0:
        return [n3, t5] = new ee().decode(e2, t5), [n3, t5];
      case 1:
        return [n3, t5] = new te().decode(e2, t5), [n3, t5];
      case 2:
        return [n3, t5] = new ne().decode(e2, t5), [n3, t5];
      case 3:
        return [n3, t5] = new oe().decode(e2, t5), [n3, t5];
      case 4:
        return [n3, t5] = new re2().decode(e2, t5), [n3, t5];
      case 5:
        return [n3, t5] = new se().decode(e2, t5), [n3, t5];
      case 6:
        return [n3, t5] = new ce2().decode(e2, t5), [n3, t5];
      case 7:
        return [n3, t5] = new pe2().decode(e2, t5), [n3, t5];
      case 8:
        return [n3, t5] = new de().decode(e2, t5), [n3, t5];
      case 9:
        return [n3, t5] = new ue2().decode(e2, t5), [n3, t5];
      case 10:
        return [n3, t5] = new ie2().decode(e2, t5), [n3, t5];
      default:
        throw new Error("Invalid Receipt type");
    }
  }
};
var H2 = class extends k {
  constructor() {
    super("StorageSlot", { key: new D(), value: new D() });
  }
};
var _2 = class extends i2 {
  constructor() {
    super("Witness", "unknown", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new S2("u32").encode(e2.dataLength)), o4.push(new a3(e2.dataLength).encode(e2.data)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new S2("u32").decode(e2, t5);
    let s4 = n3;
    return [n3, t5] = new a3(s4).decode(e2, t5), [{ dataLength: s4, data: n3 }, t5];
  }
};
var Ye = ((o4) => (o4[o4.Script = 0] = "Script", o4[o4.Create = 1] = "Create", o4))(Ye || {});
var we = class extends i2 {
  constructor() {
    super("TransactionScript", "struct TransactionScript", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new l().encode(e2.gasPrice)), o4.push(new l().encode(e2.gasLimit)), o4.push(new S2("u32").encode(e2.maturity)), o4.push(new S2("u16").encode(e2.scriptLength)), o4.push(new S2("u16").encode(e2.scriptDataLength)), o4.push(new S2("u8").encode(e2.inputsCount)), o4.push(new S2("u8").encode(e2.outputsCount)), o4.push(new S2("u8").encode(e2.witnessesCount)), o4.push(new D().encode(e2.receiptsRoot)), o4.push(new a3(e2.scriptLength).encode(e2.script)), o4.push(new a3(e2.scriptDataLength).encode(e2.scriptData)), o4.push(new P(new M2(), e2.inputsCount).encode(e2.inputs)), o4.push(new P(new P2(), e2.outputsCount).encode(e2.outputs)), o4.push(new P(new _2(), e2.witnessesCount).encode(e2.witnesses)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new l().decode(e2, t5);
    let s4 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let c9 = n3;
    [n3, t5] = new S2("u32").decode(e2, t5);
    let i7 = n3;
    [n3, t5] = new S2("u16").decode(e2, t5);
    let w8 = n3;
    [n3, t5] = new S2("u16").decode(e2, t5);
    let h5 = n3;
    [n3, t5] = new S2("u8").decode(e2, t5);
    let g4 = n3;
    [n3, t5] = new S2("u8").decode(e2, t5);
    let u4 = n3;
    [n3, t5] = new S2("u8").decode(e2, t5);
    let x6 = n3;
    [n3, t5] = new D().decode(e2, t5);
    let A6 = n3;
    [n3, t5] = new a3(w8).decode(e2, t5);
    let D7 = n3;
    [n3, t5] = new a3(h5).decode(e2, t5);
    let V4 = n3;
    [n3, t5] = new P(new M2(), g4).decode(e2, t5);
    let he = n3;
    [n3, t5] = new P(new P2(), u4).decode(e2, t5);
    let me2 = n3;
    return [n3, t5] = new P(new _2(), x6).decode(e2, t5), [{ type: 0, gasPrice: s4, gasLimit: c9, maturity: i7, scriptLength: w8, scriptDataLength: h5, inputsCount: g4, outputsCount: u4, witnessesCount: x6, receiptsRoot: A6, script: D7, scriptData: V4, inputs: he, outputs: me2, witnesses: n3 }, t5];
  }
};
var ye = class extends i2 {
  constructor() {
    super("TransactionCreate", "struct TransactionCreate", 0);
  }
  encode(e2) {
    let o4 = [];
    return o4.push(new l().encode(e2.gasPrice)), o4.push(new l().encode(e2.gasLimit)), o4.push(new S2("u32").encode(e2.maturity)), o4.push(new S2("u16").encode(e2.bytecodeLength)), o4.push(new S2("u8").encode(e2.bytecodeWitnessIndex)), o4.push(new S2("u16").encode(e2.storageSlotsCount)), o4.push(new S2("u8").encode(e2.inputsCount)), o4.push(new S2("u8").encode(e2.outputsCount)), o4.push(new S2("u8").encode(e2.witnessesCount)), o4.push(new D().encode(e2.salt)), o4.push(new P(new H2(), e2.storageSlotsCount).encode(e2.storageSlots)), o4.push(new P(new M2(), e2.inputsCount).encode(e2.inputs)), o4.push(new P(new P2(), e2.outputsCount).encode(e2.outputs)), o4.push(new P(new _2(), e2.witnessesCount).encode(e2.witnesses)), concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    [n3, t5] = new l().decode(e2, t5);
    let s4 = n3;
    [n3, t5] = new l().decode(e2, t5);
    let c9 = n3;
    [n3, t5] = new S2("u32").decode(e2, t5);
    let i7 = n3;
    [n3, t5] = new S2("u16").decode(e2, t5);
    let w8 = n3;
    [n3, t5] = new S2("u8").decode(e2, t5);
    let h5 = n3;
    [n3, t5] = new S2("u16").decode(e2, t5);
    let g4 = n3;
    [n3, t5] = new S2("u8").decode(e2, t5);
    let u4 = n3;
    [n3, t5] = new S2("u8").decode(e2, t5);
    let x6 = n3;
    [n3, t5] = new S2("u8").decode(e2, t5);
    let A6 = n3;
    [n3, t5] = new D().decode(e2, t5);
    let D7 = n3;
    [n3, t5] = new P(new H2(), g4).decode(e2, t5);
    let V4 = n3;
    [n3, t5] = new P(new M2(), u4).decode(e2, t5);
    let he = n3;
    [n3, t5] = new P(new P2(), x6).decode(e2, t5);
    let me2 = n3;
    return [n3, t5] = new P(new _2(), A6).decode(e2, t5), [{ type: 1, gasPrice: s4, gasLimit: c9, maturity: i7, bytecodeLength: w8, bytecodeWitnessIndex: h5, storageSlotsCount: g4, inputsCount: u4, outputsCount: x6, witnessesCount: A6, salt: D7, storageSlots: V4, inputs: he, outputs: me2, witnesses: n3 }, t5];
  }
};
var Le = class extends i2 {
  constructor() {
    super("Transaction", "struct Transaction", 0);
  }
  encode(e2) {
    let o4 = [];
    switch (o4.push(new S2("u8").encode(e2.type)), e2.type) {
      case 0: {
        o4.push(new we().encode(e2));
        break;
      }
      case 1: {
        o4.push(new ye().encode(e2));
        break;
      }
      default:
        throw new Error("Invalid Transaction type");
    }
    return concat(o4);
  }
  decode(e2, o4) {
    let n3, t5 = o4;
    switch ([n3, t5] = new S2("u8").decode(e2, t5), n3) {
      case 0:
        return [n3, t5] = new we().decode(e2, t5), [n3, t5];
      case 1:
        return [n3, t5] = new ye().decode(e2, t5), [n3, t5];
      default:
        throw new Error("Invalid Input type");
    }
  }
};
var Bt = 16 * 1024;
var Dt2 = 16;
var lt = i(1e8);
var St = i(1e6);
var Mt = i(4);
var Pt2 = 1024 * 1024 * 1024;
var kt = 1024 * 1024 * 1024;
var Et = 255;
var _t = 1024 * 1024;
var Wt = 1024 * 1024;
var Vt2 = "0xffffffffffff0001";

// node_modules/@fuel-ts/providers/dist/index.mjs
var import_graphql_request = __toESM(require_dist2(), 1);
var import_lodash = __toESM(require_lodash(), 1);
var Ft = (r2, t5, e2) => {
  if (!t5.has(r2))
    throw TypeError("Cannot " + e2);
};
var ut = (r2, t5, e2) => {
  if (t5.has(r2))
    throw TypeError("Cannot add the same private member more than once");
  t5 instanceof WeakSet ? t5.add(r2) : t5.set(r2, e2);
};
var pt = (r2, t5, e2) => (Ft(r2, t5, "access private method"), e2);
var O4 = (r2) => {
  var s4, n3, o4, p6;
  let t5, e2, a6;
  return Array.isArray(r2) ? (e2 = r2[0], t5 = (s4 = r2[1]) != null ? s4 : c2, a6 = (n3 = r2[2]) != null ? n3 : void 0) : (e2 = r2.amount, t5 = (o4 = r2.assetId) != null ? o4 : c2, a6 = (p6 = r2.max) != null ? p6 : void 0), { assetId: hexlify(t5), amount: i(e2), max: a6 ? i(a6) : void 0 };
};
var dt = ((e2) => (e2.Spent = "SPENT", e2.Unspent = "UNSPENT", e2))(dt || {});
var B4 = lib_default`
  fragment transactionFragment on Transaction {
    id
    rawPayload
    gasPrice
    status {
      type: __typename
      ... on SubmittedStatus {
        time
      }
      ... on SuccessStatus {
        block {
          id
        }
        time
        programState {
          returnType
          data
        }
      }
      ... on FailureStatus {
        block {
          id
        }
        time
        reason
      }
    }
  }
`;
var gt = lib_default`
  fragment receiptFragment on Receipt {
    data
    rawPayload
  }
`;
var j3 = lib_default`
  fragment coinFragment on Coin {
    utxoId
    owner
    amount
    assetId
    maturity
    status
    blockCreated
  }
`;
var mt = lib_default`
  fragment messageFragment on Message {
    amount
    sender
    recipient
    data
    nonce
    daHeight
    fuelBlockSpend
  }
`;
var Ut = lib_default`
  fragment messageProofFragment on MessageProof {
    proofSet
    proofIndex
    sender
    recipient
    nonce
    amount
    data
    signature
    header {
      id
      daHeight
      transactionsCount
      outputMessagesCount
      transactionsRoot
      outputMessagesRoot
      height
      prevRoot
      time
      applicationHash
    }
  }
`;
var St2 = lib_default`
  fragment balanceFragment on Balance {
    owner
    amount
    assetId
  }
`;
var Q4 = lib_default`
  fragment blockFragment on Block {
    id
    header {
      height
      time
    }
    transactions {
      id
    }
  }
`;
var Et2 = lib_default`
  fragment chainInfoFragment on ChainInfo {
    name
    baseChainHeight
    peerCount
    consensusParameters {
      gasPriceFactor
      maxGasPerTx
      maxGasPerTx
      maxScriptLength
    }
    latestBlock {
      ...blockFragment
    }
  }
  ${Q4}
`;
var Nt = lib_default`
  query getVersion {
    nodeInfo {
      nodeVersion
    }
  }
`;
var Vt3 = lib_default`
  query getInfo {
    nodeInfo {
      nodeVersion
      minGasPrice
    }
  }
`;
var Ht = lib_default`
  query getChain {
    chain {
      ...chainInfoFragment
    }
  }
  ${Et2}
`;
var Wt2 = lib_default`
  query getTransaction($transactionId: TransactionId!) {
    transaction(id: $transactionId) {
      ...transactionFragment
    }
  }
  ${B4}
`;
var vt = lib_default`
  query getTransactionWithReceipts($transactionId: TransactionId!) {
    transaction(id: $transactionId) {
      ...transactionFragment
      receipts {
        ...receiptFragment
      }
    }
  }
  ${B4}
  ${gt}
`;
var Kt = lib_default`
  query getTransactions($after: String, $before: String, $first: Int, $last: Int) {
    transactions(after: $after, before: $before, first: $first, last: $last) {
      edges {
        node {
          ...transactionFragment
        }
      }
    }
  }
  ${B4}
`;
var zt = lib_default`
  query getTransactionsByOwner(
    $owner: Address!
    $after: String
    $before: String
    $first: Int
    $last: Int
  ) {
    transactionsByOwner(owner: $owner, after: $after, before: $before, first: $first, last: $last) {
      edges {
        node {
          ...transactionFragment
        }
      }
    }
  }
  ${B4}
`;
var Zt = lib_default`
  query getBlock($blockId: BlockId, $blockHeight: U64) {
    block(id: $blockId, height: $blockHeight) {
      ...blockFragment
    }
  }
  ${Q4}
`;
var jt = lib_default`
  query getBlockWithTransactions($blockId: BlockId, $blockHeight: U64) {
    block(id: $blockId, height: $blockHeight) {
      ...blockFragment
      transactions {
        ...transactionFragment
      }
    }
  }
  ${Q4}
  ${B4}
`;
var Xt = lib_default`
  query getBlocks($after: String, $before: String, $first: Int, $last: Int) {
    blocks(after: $after, before: $before, first: $first, last: $last) {
      edges {
        node {
          ...blockFragment
        }
      }
    }
  }
  ${Q4}
`;
var Jt2 = lib_default`
  query getCoin($coinId: UtxoId!) {
    coin(utxoId: $coinId) {
      ...coinFragment
    }
  }
  ${j3}
`;
var Yt = lib_default`
  query getCoins(
    $filter: CoinFilterInput!
    $after: String
    $before: String
    $first: Int
    $last: Int
  ) {
    coins(filter: $filter, after: $after, before: $before, first: $first, last: $last) {
      edges {
        node {
          ...coinFragment
        }
      }
    }
  }
  ${j3}
`;
var te2 = lib_default`
  query getResourcesToSpend(
    $owner: Address!
    $queryPerAsset: [SpendQueryElementInput!]!
    $excludedIds: ExcludeInput
  ) {
    resourcesToSpend(owner: $owner, queryPerAsset: $queryPerAsset, excludedIds: $excludedIds) {
      ...coinFragment
      ...messageFragment
    }
  }
  ${j3}
  ${mt}
`;
var ee2 = lib_default`
  query getContract($contractId: ContractId!) {
    contract(id: $contractId) {
      bytecode
      id
    }
  }
`;
var ae = lib_default`
  query getBalance($owner: Address!, $assetId: AssetId!) {
    balance(owner: $owner, assetId: $assetId) {
      ...balanceFragment
    }
  }
  ${St2}
`;
var re3 = lib_default`
  query getBalances(
    $filter: BalanceFilterInput!
    $after: String
    $before: String
    $first: Int
    $last: Int
  ) {
    balances(filter: $filter, after: $after, before: $before, first: $first, last: $last) {
      edges {
        node {
          ...balanceFragment
        }
      }
    }
  }
  ${St2}
`;
var se2 = lib_default`
  query getMessages($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
    messages(owner: $owner, after: $after, before: $before, first: $first, last: $last) {
      edges {
        node {
          ...messageFragment
        }
      }
    }
  }
  ${mt}
`;
var ne2 = lib_default`
  query getMessageProof($transactionId: TransactionId!, $messageId: MessageId!) {
    messageProof(transactionId: $transactionId, messageId: $messageId) {
      ...messageProofFragment
    }
  }
  ${Ut}
`;
var oe2 = lib_default`
  mutation dryRun($encodedTransaction: HexString!, $utxoValidation: Boolean) {
    dryRun(tx: $encodedTransaction, utxoValidation: $utxoValidation) {
      ...receiptFragment
    }
  }
  ${gt}
`;
var ie3 = lib_default`
  mutation submit($encodedTransaction: HexString!) {
    submit(tx: $encodedTransaction) {
      id
    }
  }
`;
var ce3 = lib_default`
  mutation startSession {
    startSession
  }
`;
var ue3 = lib_default`
  mutation endSession($sessionId: ID!) {
    endSession(id: $sessionId)
  }
`;
var pe3 = lib_default`
  mutation execute($sessionId: ID!, $op: String!) {
    execute(id: $sessionId, op: $op)
  }
`;
var le2 = lib_default`
  mutation reset($sessionId: ID!) {
    reset(id: $sessionId)
  }
`;
var ye2 = (r2, t5, e2) => r2();
function ft(r2, t5 = ye2) {
  return { getVersion(e2, a6) {
    return t5((s4) => r2.request(Nt, e2, { ...a6, ...s4 }), "getVersion", "query");
  }, getInfo(e2, a6) {
    return t5((s4) => r2.request(Vt3, e2, { ...a6, ...s4 }), "getInfo", "query");
  }, getChain(e2, a6) {
    return t5((s4) => r2.request(Ht, e2, { ...a6, ...s4 }), "getChain", "query");
  }, getTransaction(e2, a6) {
    return t5((s4) => r2.request(Wt2, e2, { ...a6, ...s4 }), "getTransaction", "query");
  }, getTransactionWithReceipts(e2, a6) {
    return t5((s4) => r2.request(vt, e2, { ...a6, ...s4 }), "getTransactionWithReceipts", "query");
  }, getTransactions(e2, a6) {
    return t5((s4) => r2.request(Kt, e2, { ...a6, ...s4 }), "getTransactions", "query");
  }, getTransactionsByOwner(e2, a6) {
    return t5((s4) => r2.request(zt, e2, { ...a6, ...s4 }), "getTransactionsByOwner", "query");
  }, getBlock(e2, a6) {
    return t5((s4) => r2.request(Zt, e2, { ...a6, ...s4 }), "getBlock", "query");
  }, getBlockWithTransactions(e2, a6) {
    return t5((s4) => r2.request(jt, e2, { ...a6, ...s4 }), "getBlockWithTransactions", "query");
  }, getBlocks(e2, a6) {
    return t5((s4) => r2.request(Xt, e2, { ...a6, ...s4 }), "getBlocks", "query");
  }, getCoin(e2, a6) {
    return t5((s4) => r2.request(Jt2, e2, { ...a6, ...s4 }), "getCoin", "query");
  }, getCoins(e2, a6) {
    return t5((s4) => r2.request(Yt, e2, { ...a6, ...s4 }), "getCoins", "query");
  }, getResourcesToSpend(e2, a6) {
    return t5((s4) => r2.request(te2, e2, { ...a6, ...s4 }), "getResourcesToSpend", "query");
  }, getContract(e2, a6) {
    return t5((s4) => r2.request(ee2, e2, { ...a6, ...s4 }), "getContract", "query");
  }, getBalance(e2, a6) {
    return t5((s4) => r2.request(ae, e2, { ...a6, ...s4 }), "getBalance", "query");
  }, getBalances(e2, a6) {
    return t5((s4) => r2.request(re3, e2, { ...a6, ...s4 }), "getBalances", "query");
  }, getMessages(e2, a6) {
    return t5((s4) => r2.request(se2, e2, { ...a6, ...s4 }), "getMessages", "query");
  }, getMessageProof(e2, a6) {
    return t5((s4) => r2.request(ne2, e2, { ...a6, ...s4 }), "getMessageProof", "query");
  }, dryRun(e2, a6) {
    return t5((s4) => r2.request(oe2, e2, { ...a6, ...s4 }), "dryRun", "mutation");
  }, submit(e2, a6) {
    return t5((s4) => r2.request(ie3, e2, { ...a6, ...s4 }), "submit", "mutation");
  }, startSession(e2, a6) {
    return t5((s4) => r2.request(ce3, e2, { ...a6, ...s4 }), "startSession", "mutation");
  }, endSession(e2, a6) {
    return t5((s4) => r2.request(ue3, e2, { ...a6, ...s4 }), "endSession", "mutation");
  }, execute(e2, a6) {
    return t5((s4) => r2.request(pe3, e2, { ...a6, ...s4 }), "execute", "mutation");
  }, reset(e2, a6) {
    return t5((s4) => r2.request(le2, e2, { ...a6, ...s4 }), "reset", "mutation");
  } };
}
var It = (r2) => "utxoId" in r2;
var Ke = (r2) => "recipient" in r2;
var _3 = (r2) => "id" in r2;
var ze = (r2) => "recipient" in r2;
var xt = (r2) => {
  var t5, e2, a6, s4, n3;
  switch (r2.type) {
    case We.Coin: {
      let o4 = arrayify((t5 = r2.predicate) != null ? t5 : "0x"), p6 = arrayify((e2 = r2.predicateData) != null ? e2 : "0x");
      return { type: We.Coin, utxoID: { transactionId: hexlify(arrayify(r2.id).slice(0, 32)), outputIndex: arrayify(r2.id)[32] }, owner: hexlify(r2.owner), amount: i(r2.amount), assetId: hexlify(r2.assetId), txPointer: { blockHeight: F(arrayify(r2.txPointer).slice(0, 8)), txIndex: F(arrayify(r2.txPointer).slice(8, 16)) }, witnessIndex: r2.witnessIndex, maturity: (a6 = r2.maturity) != null ? a6 : 0, predicateLength: o4.length, predicateDataLength: p6.length, predicate: hexlify(o4), predicateData: hexlify(p6) };
    }
    case We.Contract:
      return { type: We.Contract, utxoID: { transactionId: t, outputIndex: 0 }, balanceRoot: t, stateRoot: t, txPointer: { blockHeight: F(arrayify(r2.txPointer).slice(0, 8)), txIndex: F(arrayify(r2.txPointer).slice(8, 16)) }, contractID: hexlify(r2.contractId) };
    case We.Message: {
      let o4 = arrayify((s4 = r2.predicate) != null ? s4 : "0x"), p6 = arrayify((n3 = r2.predicateData) != null ? n3 : "0x");
      return { type: We.Message, sender: hexlify(r2.sender), recipient: hexlify(r2.recipient), amount: i(r2.amount), nonce: i(r2.nonce), witnessIndex: r2.witnessIndex, dataLength: r2.data.length, predicateLength: o4.length, predicateDataLength: p6.length, data: hexlify(r2.data), predicate: hexlify(o4), predicateData: hexlify(p6) };
    }
    default:
      throw new Error("Invalid Input type");
  }
};
var qt = (r2) => {
  switch (r2.type) {
    case Ve.Coin:
      return { type: Ve.Coin, to: hexlify(r2.to), amount: i(r2.amount), assetId: hexlify(r2.assetId) };
    case Ve.Contract:
      return { type: Ve.Contract, inputIndex: r2.inputIndex, balanceRoot: t, stateRoot: t };
    case Ve.Message:
      return { type: Ve.Message, recipient: hexlify(r2.recipient), amount: i(r2.amount) };
    case Ve.Change:
      return { type: Ve.Change, to: hexlify(r2.to), amount: i(0), assetId: hexlify(r2.assetId) };
    case Ve.Variable:
      return { type: Ve.Variable, to: t, amount: i(0), assetId: t };
    case Ve.ContractCreated:
      return { type: Ve.ContractCreated, contractId: hexlify(r2.contractId), stateRoot: hexlify(r2.stateRoot) };
    default:
      throw new Error("Invalid Output type");
  }
};
var Y2 = (r2) => {
  if (r2.length == null && typeof r2 == "object") {
    let t5 = Object.keys(r2).length;
    return arrayify({ ...r2, length: t5 });
  }
  return arrayify(r2);
};
var tt = (r2, t5, e2) => i(Math.ceil(r2.toNumber() / e2.toNumber()) * t5.toNumber());
var Se = (r2) => {
  let t5 = r2.find((e2) => e2.type === Ge.ScriptResult);
  return t5 && t5.type === Ge.ScriptResult ? t5.gasUsed : i(0);
};
function Gt(r2 = 1e3) {
  return new Promise((t5) => {
    setTimeout(() => {
      t5(true);
    }, r2);
  });
}
var fe3 = (r2) => r2.type === Ge.Revert && r2.val.toString("hex") === Vt2;
var Ie2 = (r2) => r2.type === Ge.Panic && r2.contractId !== "0x0000000000000000000000000000000000000000000000000000000000000000";
var Rt2 = (r2) => r2.reduce((t5, e2) => (fe3(e2) && t5.missingOutputVariables.push(e2), Ie2(e2) && t5.missingOutputContractIds.push(e2), t5), { missingOutputVariables: [], missingOutputContractIds: [] });
var M3 = ({ receipts: r2, gasPrice: t5, margin: e2 }) => {
  let a6 = H(Se(r2), e2 || 1), s4 = tt(a6, t5, St);
  return { gasUsed: a6, fee: s4 };
};
var qe = (r2) => {
  let t5 = new Uint8Array(32);
  return t5.set(arrayify(r2)), t5;
};
var Ct = (r2) => {
  let t5, e2;
  return Array.isArray(r2) ? (t5 = r2[0], e2 = r2[1]) : (t5 = r2.key, e2 = r2.value), { key: hexlify(t5), value: hexlify(qe(e2)) };
};
var Bt2 = (r2) => {
  let t5 = arrayify(r2);
  return { data: hexlify(t5), dataLength: t5.length };
};
var _t2 = { bytes: arrayify("0x24000000"), encodeScriptData: () => new Uint8Array(0) };
var Ca = { bytes: arrayify("0x5040C0105D44C0064C40001124000000"), encodeScriptData: () => new Uint8Array(0) };
var E2 = class extends Error {
  constructor() {
    super(...arguments);
    this.name = "ChangeOutputCollisionError";
    this.message = 'A ChangeOutput with the same "assetId" already exists for a different "to" address';
  }
};
var rt = class extends Error {
  constructor(e2) {
    super();
    this.index = e2;
    this.name = "NoWitnessAtIndexError";
    this.message = `Witness at index "${e2}" was not found`;
  }
};
var st = class extends Error {
  constructor(e2) {
    super();
    this.owner = e2;
    this.name = "NoWitnessByOwnerError";
    this.message = `A witness for the given owner "${e2}" was not found`;
  }
};
var N3 = class {
  constructor({ gasPrice: t5, gasLimit: e2, maturity: a6, inputs: s4, outputs: n3, witnesses: o4 } = {}) {
    this.inputs = [];
    this.outputs = [];
    this.witnesses = [];
    this.gasPrice = i(t5 != null ? t5 : 0), this.gasLimit = i(e2 != null ? e2 : 0), this.maturity = a6 != null ? a6 : 0, this.inputs = [...s4 != null ? s4 : []], this.outputs = [...n3 != null ? n3 : []], this.witnesses = [...o4 != null ? o4 : []];
  }
  getBaseTransaction() {
    var s4, n3, o4, p6, c9, y4;
    let t5 = (n3 = (s4 = this.inputs) == null ? void 0 : s4.map(xt)) != null ? n3 : [], e2 = (p6 = (o4 = this.outputs) == null ? void 0 : o4.map(qt)) != null ? p6 : [], a6 = (y4 = (c9 = this.witnesses) == null ? void 0 : c9.map(Bt2)) != null ? y4 : [];
    return { gasPrice: this.gasPrice, gasLimit: this.gasLimit, maturity: this.maturity, inputs: t5, outputs: e2, witnesses: a6, inputsCount: t5.length, outputsCount: e2.length, witnessesCount: a6.length };
  }
  toTransactionBytes() {
    return new Le().encode(this.toTransaction());
  }
  pushInput(t5) {
    return this.inputs.push(t5), this.inputs.length - 1;
  }
  pushOutput(t5) {
    return this.outputs.push(t5), this.outputs.length - 1;
  }
  createWitness() {
    return this.witnesses.push("0x"), this.witnesses.length - 1;
  }
  updateWitnessByOwner(t5, e2) {
    let a6 = this.getCoinInputWitnessIndexByOwner(t5);
    typeof a6 == "number" && this.updateWitness(a6, e2);
  }
  updateWitness(t5, e2) {
    if (!this.witnesses[t5])
      throw new rt(t5);
    this.witnesses[t5] = e2;
  }
  getCoinInputs() {
    return this.inputs.filter((t5) => t5.type === We.Coin);
  }
  getCoinOutputs() {
    return this.outputs.filter((t5) => t5.type === Ve.Coin);
  }
  getChangeOutputs() {
    return this.outputs.filter((t5) => t5.type === Ve.Change);
  }
  getCoinInputWitnessIndexByOwner(t5) {
    var a6, s4;
    let e2 = D2(t5);
    return (s4 = (a6 = this.inputs.find((n3) => n3.type === We.Coin && n3.owner === e2.toB256())) == null ? void 0 : a6.witnessIndex) != null ? s4 : null;
  }
  updateWitnessByCoinInputOwner(t5, e2) {
    let a6 = this.getCoinInputWitnessIndexByOwner(t5);
    if (!a6)
      throw new st(D2(t5));
    this.updateWitness(a6, e2);
  }
  addResource(t5) {
    let e2 = _3(t5) ? t5.owner : t5.recipient, a6 = _3(t5) ? t5.assetId : c2, s4 = _3(t5) ? We.Coin : We.Message, n3 = this.getCoinInputWitnessIndexByOwner(e2);
    typeof n3 != "number" && (n3 = this.createWitness()), this.pushInput(_3(t5) ? { type: s4, ...t5, owner: t5.owner.toB256(), witnessIndex: n3, txPointer: "0x00000000000000000000000000000000" } : { type: s4, ...t5, sender: t5.sender.toB256(), recipient: t5.recipient.toB256(), witnessIndex: n3, txPointer: "0x00000000000000000000000000000000" });
    let o4 = this.getChangeOutputs().find((p6) => hexlify(p6.assetId) === a6);
    if (o4 && hexlify(o4.to) !== e2.toB256())
      throw new E2();
    o4 || this.pushOutput({ type: Ve.Change, to: e2.toB256(), assetId: a6 });
  }
  addResources(t5) {
    t5.forEach((e2) => this.addResource(e2));
  }
  addCoin(t5) {
    let e2 = this.getCoinInputWitnessIndexByOwner(t5.owner);
    typeof e2 != "number" && (e2 = this.createWitness()), this.pushInput({ type: We.Coin, ...t5, owner: t5.owner.toB256(), witnessIndex: e2, txPointer: "0x00000000000000000000000000000000" });
    let a6 = this.getChangeOutputs().find((s4) => hexlify(s4.assetId) === t5.assetId);
    if (a6 && hexlify(a6.to) !== t5.owner.toB256())
      throw new E2();
    a6 || this.pushOutput({ type: Ve.Change, to: t5.owner.toB256(), assetId: t5.assetId });
  }
  addCoins(t5) {
    t5.forEach((e2) => this.addCoin(e2));
  }
  addCoinOutput(t5, e2, a6 = c2) {
    this.pushOutput({ type: Ve.Coin, to: D2(t5).toB256(), amount: e2, assetId: a6 });
  }
  addCoinOutputs(t5, e2) {
    e2.map(O4).forEach((a6) => {
      this.pushOutput({ type: Ve.Coin, to: D2(t5).toB256(), amount: a6.amount, assetId: a6.assetId });
    });
  }
  byteSize() {
    return this.toTransactionBytes().length;
  }
  chargeableByteSize() {
    let t5 = this.witnesses.reduce((e2, a6) => e2 + arrayify(a6).length, 0);
    return i(this.toTransactionBytes().length - t5);
  }
  calculateFee() {
    let t5 = tt(this.gasLimit, this.gasPrice, St);
    return { assetId: c2, amount: t5.isZero() ? i(1) : t5 };
  }
  addMessage(t5) {
    let e2 = this.getCoinInputWitnessIndexByOwner(t5.recipient);
    typeof e2 != "number" && (e2 = this.createWitness()), this.pushInput({ type: We.Message, ...t5, sender: t5.sender.toBytes(), recipient: t5.recipient.toBytes(), witnessIndex: e2 });
  }
  addMessages(t5) {
    t5.forEach((e2) => this.addMessage(e2));
  }
};
var C2 = class extends N3 {
  constructor({ script: e2, scriptData: a6, ...s4 } = {}) {
    super(s4);
    this.type = Ye.Script;
    this.script = Y2(e2 != null ? e2 : _t2.bytes), this.scriptData = Y2(a6 != null ? a6 : _t2.encodeScriptData());
  }
  static from(e2) {
    return e2 instanceof this ? e2 : new this(e2);
  }
  toTransaction() {
    var s4, n3;
    let e2 = arrayify((s4 = this.script) != null ? s4 : "0x"), a6 = arrayify((n3 = this.scriptData) != null ? n3 : "0x");
    return { type: Ye.Script, ...super.getBaseTransaction(), scriptLength: e2.length, scriptDataLength: a6.length, receiptsRoot: t, script: hexlify(e2), scriptData: hexlify(a6) };
  }
  getContractInputs() {
    return this.inputs.filter((e2) => e2.type === We.Contract);
  }
  getContractOutputs() {
    return this.outputs.filter((e2) => e2.type === Ve.Contract);
  }
  getVariableOutputs() {
    return this.outputs.filter((e2) => e2.type === Ve.Variable);
  }
  setScript(e2, a6) {
    this.script = e2.bytes, this.scriptData = e2.encodeScriptData(a6), this.bytesOffset === void 0 && (this.bytesOffset = this.scriptData.byteLength);
  }
  addVariableOutputs(e2 = 1) {
    let a6 = e2;
    for (; a6; )
      this.pushOutput({ type: Ve.Variable }), a6 -= 1;
    return this.outputs.length - 1;
  }
  addMessageOutputs(e2 = 1) {
    let a6 = e2;
    for (; a6; )
      this.pushOutput({ type: Ve.Message, recipient: "0x0000000000000000000000000000000000000000000000000000000000000000", amount: 0 }), a6 -= 1;
    return this.outputs.length - 1;
  }
  addContract(e2) {
    let a6 = D2(e2);
    if (this.getContractInputs().find((n3) => n3.contractId === a6.toB256()))
      return;
    let s4 = super.pushInput({ type: We.Contract, contractId: a6.toB256(), txPointer: "0x00000000000000000000000000000000" });
    this.pushOutput({ type: Ve.Contract, inputIndex: s4 });
  }
};
var V2 = class extends N3 {
  constructor({ bytecodeWitnessIndex: e2, salt: a6, storageSlots: s4, ...n3 } = {}) {
    super(n3);
    this.type = Ye.Create;
    this.bytecodeWitnessIndex = e2 != null ? e2 : 0, this.salt = hexlify(a6 != null ? a6 : t), this.storageSlots = [...s4 != null ? s4 : []];
  }
  static from(e2) {
    return e2 instanceof this ? e2 : new this(e2);
  }
  toTransaction() {
    var n3, o4;
    let e2 = this.getBaseTransaction(), a6 = this.bytecodeWitnessIndex, s4 = (o4 = (n3 = this.storageSlots) == null ? void 0 : n3.map(Ct)) != null ? o4 : [];
    return { type: Ye.Create, ...e2, bytecodeLength: e2.witnesses[a6].dataLength / 4, bytecodeWitnessIndex: a6, storageSlotsCount: s4.length, salt: this.salt ? hexlify(this.salt) : t, storageSlots: s4 };
  }
  getContractCreatedOutputs() {
    return this.outputs.filter((e2) => e2.type === Ve.ContractCreated);
  }
  addContractCreatedOutput(e2, a6) {
    this.pushOutput({ type: Ve.ContractCreated, contractId: e2, stateRoot: a6 });
  }
};
var A3 = (r2) => {
  if (r2 instanceof C2 || r2 instanceof V2)
    return r2;
  switch (r2.type) {
    case Ye.Script:
      return C2.from(r2);
    case Ye.Create:
      return V2.from(r2);
    default:
      throw new Error(`Unknown transaction type: ${r2.type}`);
  }
};
var Be = 5e3;
var _e = 500;
var kt2 = (r2) => {
  let t5 = new fe2().decode(arrayify(r2.rawPayload), 0)[0];
  switch (t5.type) {
    case Ge.ReturnData:
      return { ...t5, data: r2.data };
    case Ge.LogData:
      return { ...t5, data: r2.data };
    default:
      return t5;
  }
};
var W3;
var At;
var H3 = class {
  constructor(t5, e2) {
    ut(this, W3);
    this.gasUsed = i(0);
    this.attempts = 0;
    this.id = t5, this.provider = e2;
  }
  async waitForResult() {
    var a6, s4;
    let t5 = await pt(this, W3, At).call(this), e2 = (a6 = new Le().decode(arrayify(t5.rawPayload), 0)) == null ? void 0 : a6[0];
    switch ((s4 = t5.status) == null ? void 0 : s4.type) {
      case "SubmittedStatus":
        return this.attempts += 1, await Gt(Math.min(_e * this.attempts, Be)), this.waitForResult();
      case "FailureStatus": {
        let n3 = t5.receipts.map(kt2), { gasUsed: o4, fee: p6 } = M3({ receipts: n3, gasPrice: i(t5 == null ? void 0 : t5.gasPrice) });
        return this.gasUsed = o4, { status: { type: "failure", reason: t5.status.reason }, receipts: n3, transactionId: this.id, blockId: t5.status.block.id, time: t5.status.time, gasUsed: o4, fee: p6, transaction: e2 };
      }
      case "SuccessStatus": {
        let n3 = t5.receipts.map(kt2), { gasUsed: o4, fee: p6 } = M3({ receipts: n3, gasPrice: i(t5 == null ? void 0 : t5.gasPrice) });
        return { status: { type: "success", programState: t5.status.programState }, receipts: n3, transactionId: this.id, blockId: t5.status.block.id, time: t5.status.time, gasUsed: o4, fee: p6, transaction: e2 };
      }
      default:
        throw new Error("Invalid Transaction status");
    }
  }
  async wait() {
    let t5 = await this.waitForResult();
    if (t5.status.type === "failure")
      throw new Error(`Transaction failed: ${t5.status.reason}`);
    return t5;
  }
};
W3 = /* @__PURE__ */ new WeakSet(), At = async function() {
  let { transaction: t5 } = await this.provider.operations.getTransactionWithReceipts({ transactionId: this.id });
  if (!t5)
    throw new Error("No Transaction was received from the client.");
  return t5;
};
var Qe = 10;
var ot = (r2) => {
  let t5 = new fe2().decode(arrayify(r2.rawPayload), 0)[0];
  switch (t5.type) {
    case Ge.ReturnData:
      return { ...t5, data: r2.data };
    case Ge.LogData:
      return { ...t5, data: r2.data };
    default:
      return t5;
  }
};
var Le2 = (r2) => ({ name: r2.name, baseChainHeight: i(r2.baseChainHeight), peerCount: r2.peerCount, consensusParameters: { gasPriceFactor: i(r2.consensusParameters.gasPriceFactor), maxGasPerTx: i(r2.consensusParameters.maxGasPerTx), maxScriptLength: i(r2.consensusParameters.maxScriptLength) }, latestBlock: { id: r2.latestBlock.id, height: i(r2.latestBlock.header.height), time: r2.latestBlock.header.time, transactions: r2.latestBlock.transactions.map((t5) => ({ id: t5.id })) } });
var De = (r2) => ({ minGasPrice: i(r2.minGasPrice), nodeVersion: r2.nodeVersion });
var v3 = class {
  constructor(t5) {
    this.url = t5;
    this.addMissingVariables = async (t6) => {
      let e3 = 0, a6 = 0, s4 = 0;
      if (t6.type !== Ye.Create)
        do {
          let n3 = hexlify(t6.toTransactionBytes()), { dryRun: o4 } = await this.operations.dryRun({ encodedTransaction: n3, utxoValidation: false }), p6 = o4.map(ot), { missingOutputVariables: c9, missingOutputContractIds: y4 } = Rt2(p6);
          if (e3 = c9.length, a6 = y4.length, e3 === 0 && a6 === 0)
            return;
          t6.addVariableOutputs(e3), y4.forEach(({ contractId: l7 }) => t6.addContract(t2.fromString(l7))), s4 += 1;
        } while (s4 < Qe);
    };
    let e2 = new import_graphql_request.GraphQLClient(t5);
    this.operations = ft(e2);
  }
  async getVersion() {
    let { nodeInfo: { nodeVersion: t5 } } = await this.operations.getVersion();
    return t5;
  }
  async getNetwork() {
    return { name: "fuelv2", chainId: 3735928559 };
  }
  async getBlockNumber() {
    let { chain: t5 } = await this.operations.getChain();
    return i(t5.latestBlock.header.height, 10);
  }
  async getNodeInfo() {
    let { nodeInfo: t5 } = await this.operations.getInfo();
    return De(t5);
  }
  async getChain() {
    let { chain: t5 } = await this.operations.getChain();
    return Le2(t5);
  }
  async sendTransaction(t5) {
    let e2 = A3(t5);
    await this.addMissingVariables(e2);
    let a6 = hexlify(e2.toTransactionBytes()), { gasUsed: s4, minGasPrice: n3 } = await this.getTransactionCost(e2, 0);
    if (i(s4).gt(i(e2.gasLimit)))
      throw new Error(`gasLimit(${e2.gasLimit}) is lower than the required (${s4})`);
    if (i(n3).gt(i(e2.gasPrice)))
      throw new Error(`gasPrice(${e2.gasPrice}) is lower than the required ${n3}`);
    let { submit: { id: o4 } } = await this.operations.submit({ encodedTransaction: a6 });
    return new H3(o4, this);
  }
  async call(t5, { utxoValidation: e2 } = {}) {
    let a6 = A3(t5);
    await this.addMissingVariables(a6);
    let s4 = hexlify(a6.toTransactionBytes()), { dryRun: n3 } = await this.operations.dryRun({ encodedTransaction: s4, utxoValidation: e2 || false });
    return { receipts: n3.map(ot) };
  }
  async simulate(t5) {
    let e2 = A3(t5);
    await this.addMissingVariables(e2);
    let a6 = hexlify(e2.toTransactionBytes()), { dryRun: s4 } = await this.operations.dryRun({ encodedTransaction: a6, utxoValidation: true });
    return { receipts: s4.map(ot) };
  }
  async getTransactionCost(t5, e2 = 0.2) {
    let a6 = A3((0, import_lodash.default)(t5)), { minGasPrice: s4 } = await this.getNodeInfo(), n3 = L(a6.gasPrice, s4), o4 = 1 + e2;
    a6.gasLimit = lt, a6.gasPrice = i(0);
    let { receipts: p6 } = await this.call(a6), { gasUsed: c9, fee: y4 } = M3({ gasPrice: n3, receipts: p6, margin: o4 });
    return { minGasPrice: s4, gasPrice: n3, gasUsed: c9, fee: y4 };
  }
  async getCoins(t5, e2, a6) {
    return (await this.operations.getCoins({ first: 10, ...a6, filter: { owner: t5.toB256(), assetId: e2 && hexlify(e2) } })).coins.edges.map((o4) => o4.node).map((o4) => ({ id: o4.utxoId, assetId: o4.assetId, amount: i(o4.amount), owner: t2.fromAddressOrString(o4.owner), status: o4.status, maturity: i(o4.maturity).toNumber(), blockCreated: i(o4.blockCreated) }));
  }
  async getResourcesToSpend(t5, e2, a6) {
    var o4, p6;
    let s4 = { messages: ((o4 = a6 == null ? void 0 : a6.messages) == null ? void 0 : o4.map((c9) => hexlify(c9))) || [], utxos: ((p6 = a6 == null ? void 0 : a6.utxos) == null ? void 0 : p6.map((c9) => hexlify(c9))) || [] };
    return (await this.operations.getResourcesToSpend({ owner: t5.toB256(), queryPerAsset: e2.map(O4).map(({ assetId: c9, amount: y4, max: l7 }) => ({ assetId: hexlify(c9), amount: y4.toString(10), max: l7 ? l7.toString(10) : void 0 })), excludedIds: s4 })).resourcesToSpend.flat().map((c9) => It(c9) ? { id: c9.utxoId, amount: i(c9.amount), status: c9.status, assetId: c9.assetId, owner: t2.fromAddressOrString(c9.owner), maturity: i(c9.maturity).toNumber(), blockCreated: i(c9.blockCreated) } : { sender: t2.fromAddressOrString(c9.sender), recipient: t2.fromAddressOrString(c9.recipient), nonce: i(c9.nonce), amount: i(c9.amount), data: W2.decodeData(c9.data), daHeight: i(c9.daHeight), fuelBlockSpend: i(c9.fuelBlockSpend) });
  }
  async getBlock(t5) {
    let e2;
    typeof t5 == "number" ? e2 = { blockHeight: i(t5).toString(10) } : t5 === "latest" ? e2 = { blockHeight: (await this.getBlockNumber()).toString(10) } : e2 = { blockId: i(t5).toString(10) };
    let { block: a6 } = await this.operations.getBlock(e2);
    return a6 ? { id: a6.id, height: i(a6.header.height), time: a6.header.time, transactionIds: a6.transactions.map((s4) => s4.id) } : null;
  }
  async getBlockWithTransactions(t5) {
    let e2;
    typeof t5 == "number" ? e2 = { blockHeight: i(t5).toString(10) } : t5 === "latest" ? e2 = { blockHeight: (await this.getBlockNumber()).toString() } : e2 = { blockId: t5 };
    let { block: a6 } = await this.operations.getBlockWithTransactions(e2);
    return a6 ? { id: a6.id, height: i(a6.header.height, 10), time: a6.header.time, transactionIds: a6.transactions.map((s4) => s4.id), transactions: a6.transactions.map((s4) => {
      var n3;
      return (n3 = new Le().decode(arrayify(s4.rawPayload), 0)) == null ? void 0 : n3[0];
    }) } : null;
  }
  async getTransaction(t5) {
    var a6;
    let { transaction: e2 } = await this.operations.getTransaction({ transactionId: t5 });
    return e2 ? (a6 = new Le().decode(arrayify(e2.rawPayload), 0)) == null ? void 0 : a6[0] : null;
  }
  async getContract(t5) {
    let { contract: e2 } = await this.operations.getContract({ contractId: t5 });
    return e2 || null;
  }
  async getBalance(t5, e2) {
    let { balance: a6 } = await this.operations.getBalance({ owner: t5.toB256(), assetId: hexlify(e2) });
    return i(a6.amount, 10);
  }
  async getBalances(t5, e2) {
    return (await this.operations.getBalances({ first: 10, ...e2, filter: { owner: t5.toB256() } })).balances.edges.map((n3) => n3.node).map((n3) => ({ assetId: n3.assetId, amount: i(n3.amount) }));
  }
  async getMessages(t5, e2) {
    return (await this.operations.getMessages({ first: 10, ...e2, owner: t5.toB256() })).messages.edges.map((n3) => n3.node).map((n3) => ({ sender: t2.fromAddressOrString(n3.sender), recipient: t2.fromAddressOrString(n3.recipient), nonce: i(n3.nonce), amount: i(n3.amount), data: W2.decodeData(n3.data), daHeight: i(n3.daHeight), fuelBlockSpend: i(n3.fuelBlockSpend) }));
  }
  async getMessageProof(t5, e2) {
    let a6 = await this.operations.getMessageProof({ transactionId: t5, messageId: e2 });
    return a6.messageProof ? { proofSet: a6.messageProof.proofSet, proofIndex: i(a6.messageProof.proofIndex), sender: t2.fromAddressOrString(a6.messageProof.sender), recipient: t2.fromAddressOrString(a6.messageProof.recipient), nonce: a6.messageProof.nonce, amount: i(a6.messageProof.amount), data: a6.messageProof.data, signature: a6.messageProof.signature, header: { id: a6.messageProof.header.id, daHeight: i(a6.messageProof.header.daHeight), transactionsCount: i(a6.messageProof.header.transactionsCount), outputMessagesCount: i(a6.messageProof.header.outputMessagesCount), transactionsRoot: a6.messageProof.header.transactionsRoot, outputMessagesRoot: a6.messageProof.header.outputMessagesRoot, height: i(a6.messageProof.header.height), prevRoot: a6.messageProof.header.prevRoot, time: a6.messageProof.header.time, applicationHash: a6.messageProof.header.applicationHash } } : null;
  }
  async buildSpendPredicate(t5, e2, a6, s4, n3 = c2, o4, p6) {
    let c9 = await this.getResourcesToSpend(t5.address, [[e2, n3]]), y4 = { fundTransaction: true, ...o4 }, l7 = new C2({ gasLimit: lt, ...y4 }), K4;
    s4 && t5.types && (K4 = new O2().encode(t5.types, s4));
    let z4 = c9.reduce((w8, ct) => (l7.addResource({ ...ct, predicate: t5.bytes, predicateData: K4 }), l7.outputs = [], w8.add(ct.amount)), i(0));
    l7.addCoinOutput(a6, z4, n3);
    let Z2 = [];
    if (y4.fundTransaction && Z2.push(l7.calculateFee()), Z2.length && p6) {
      let w8 = await this.getResourcesToSpend(p6, Z2);
      l7.addResources(w8);
    }
    return l7;
  }
  async submitSpendPredicate(t5, e2, a6, s4, n3 = c2, o4, p6) {
    var y4;
    let c9 = await this.buildSpendPredicate(t5, e2, a6, s4, n3, o4, p6);
    try {
      return await (await this.sendTransaction(c9)).waitForResult();
    } catch (l7) {
      throw (((y4 = l7 == null ? void 0 : l7.response) == null ? void 0 : y4.errors) || []).some(({ message: z4 }) => z4.includes("unexpected block execution error TransactionValidity(InvalidPredicate")) ? new Error("Invalid Predicate") : l7;
    }
  }
};

// node_modules/@fuel-ts/hasher/dist/index.mjs
var import_lodash2 = __toESM(require_lodash(), 1);
function b4(r2) {
  return sha256(Buffer.from(r2));
}
function q3(r2) {
  let e2 = A3(r2).toTransaction();
  return e2.type === Ye.Script && (e2.receiptsRoot = t), e2.inputs = e2.inputs.map((n3) => {
    let t5 = (0, import_lodash2.default)(n3);
    switch (t5.type) {
      case We.Coin:
        return t5;
      case We.Contract:
        return t5.utxoID = { transactionId: t, outputIndex: 0 }, t5.balanceRoot = t, t5.stateRoot = t, t5;
      default:
        return t5;
    }
  }), e2.outputs = e2.outputs.map((n3) => {
    let t5 = (0, import_lodash2.default)(n3);
    switch (t5.type) {
      case Ve.Contract:
        return t5.balanceRoot = t, t5.stateRoot = t, t5;
      case Ve.Change:
        return t5.amount = i(0), t5;
      case Ve.Variable:
        return t5.to = t, t5.amount = i(0), t5.assetId = t, t5;
      default:
        return t5;
    }
  }), e2.witnessesCount = 0, e2.witnesses = [], sha256(new Le().encode(e2));
}
function w3(r2) {
  return sha256(r2);
}

// node_modules/@fuel-ts/signer/dist/index.mjs
var import_elliptic = __toESM(require_elliptic(), 1);
function o2() {
  return new import_elliptic.ec("secp256k1");
}
var a4 = class {
  constructor(e2) {
    typeof e2 == "string" && e2.match(/^[0-9a-f]*$/i) && e2.length === 64 && (e2 = `0x${e2}`);
    let r2 = arrayify(e2), t5 = o2().keyFromPrivate(r2, "hex");
    this.compressedPublicKey = hexlify(t5.getPublic(true, "array")), this.publicKey = hexlify(t5.getPublic(false, "array").slice(1)), this.privateKey = hexlify(r2), this.address = t2.fromPublicKey(this.publicKey);
  }
  sign(e2) {
    let t5 = o2().keyFromPrivate(arrayify(this.privateKey), "hex").sign(arrayify(e2), { canonical: true }), y4 = R(t5.r, 32), i7 = R(t5.s, 32);
    return i7[0] |= (t5.recoveryParam || 0) << 7, hexlify(concat([y4, i7]));
  }
  addPoint(e2) {
    let r2 = o2().keyFromPublic(arrayify(this.compressedPublicKey)), t5 = o2().keyFromPublic(arrayify(e2)), y4 = r2.getPublic().add(t5.getPublic());
    return hexlify(y4.encode("array", true));
  }
  static recoverPublicKey(e2, r2) {
    let t5 = arrayify(r2), y4 = t5.slice(0, 32), i7 = t5.slice(32, 64), m4 = (i7[0] & 128) >> 7;
    return i7[0] &= 127, o2().recoverPubKey(arrayify(e2), { r: y4, s: i7 }, m4).encode("array", false).slice(1);
  }
  static recoverAddress(e2, r2) {
    return t2.fromPublicKey(a4.recoverPublicKey(e2, r2));
  }
  static generatePrivateKey(e2) {
    return e2 ? w3(concat([u(32), arrayify(e2)])) : u(32);
  }
  static extendPublicKey(e2) {
    let r2 = o2().keyFromPublic(arrayify(e2));
    return hexlify(r2.getPublic(false, "array").slice(1));
  }
};
var k2 = a4;

// node_modules/@ethersproject/basex/lib.esm/index.js
var BaseX = class {
  constructor(alphabet) {
    defineReadOnly(this, "alphabet", alphabet);
    defineReadOnly(this, "base", alphabet.length);
    defineReadOnly(this, "_alphabetMap", {});
    defineReadOnly(this, "_leader", alphabet.charAt(0));
    for (let i7 = 0; i7 < alphabet.length; i7++) {
      this._alphabetMap[alphabet.charAt(i7)] = i7;
    }
  }
  encode(value) {
    let source = arrayify(value);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i7 = 0; i7 < source.length; ++i7) {
      let carry = source[i7];
      for (let j5 = 0; j5 < digits.length; ++j5) {
        carry += digits[j5] << 8;
        digits[j5] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string = "";
    for (let k5 = 0; source[k5] === 0 && k5 < source.length - 1; ++k5) {
      string += this._leader;
    }
    for (let q5 = digits.length - 1; q5 >= 0; --q5) {
      string += this.alphabet[digits[q5]];
    }
    return string;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes = [];
    if (value.length === 0) {
      return new Uint8Array(bytes);
    }
    bytes.push(0);
    for (let i7 = 0; i7 < value.length; i7++) {
      let byte = this._alphabetMap[value[i7]];
      if (byte === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte;
      for (let j5 = 0; j5 < bytes.length; ++j5) {
        carry += bytes[j5] * this.base;
        bytes[j5] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k5 = 0; value[k5] === this._leader && k5 < value.length - 1; ++k5) {
      bytes.push(0);
    }
    return arrayify(new Uint8Array(bytes.reverse()));
  }
};
var Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
var Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

// node_modules/@fuel-ts/wordlists/dist/index.mjs
var t3 = ["abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"];
var o3 = ((e2) => (e2.english = "english", e2))(o3 || {});

// node_modules/@fuel-ts/mnemonic/dist/index.mjs
function y(r2) {
  let e2 = r2.normalize("NFKD"), t5 = [];
  for (let n3 = 0; n3 < e2.length; n3 += 1) {
    let s4 = e2.charCodeAt(n3);
    if (s4 < 128)
      t5.push(s4);
    else if (s4 < 2048)
      t5.push(s4 >> 6 | 192), t5.push(s4 & 63 | 128);
    else if ((s4 & 64512) === 55296) {
      n3 += 1;
      let o4 = e2.charCodeAt(n3);
      if (n3 >= e2.length || (o4 & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      let c9 = 65536 + ((s4 & 1023) << 10) + (o4 & 1023);
      t5.push(c9 >> 18 | 240), t5.push(c9 >> 12 & 63 | 128), t5.push(c9 >> 6 & 63 | 128), t5.push(c9 & 63 | 128);
    } else
      t5.push(s4 >> 12 | 224), t5.push(s4 >> 6 & 63 | 128), t5.push(s4 & 63 | 128);
  }
  return arrayify(t5);
}
function v4(r2) {
  return (1 << r2) - 1;
}
function M4(r2) {
  return (1 << r2) - 1 << 8 - r2;
}
function g2(r2) {
  return Array.isArray(r2) ? r2 : r2.split(" ");
}
function T2(r2) {
  return Array.isArray(r2) ? r2.join(" ") : r2;
}
function P3(r2) {
  let e2 = [0], t5 = 11;
  for (let o4 = 0; o4 < r2.length; o4 += 1)
    t5 > 8 ? (e2[e2.length - 1] <<= 8, e2[e2.length - 1] |= r2[o4], t5 -= 8) : (e2[e2.length - 1] <<= t5, e2[e2.length - 1] |= r2[o4] >> 8 - t5, e2.push(r2[o4] & v4(8 - t5)), t5 += 3);
  let n3 = r2.length / 4, s4 = arrayify(sha256(r2))[0] & M4(n3);
  return e2[e2.length - 1] <<= n3, e2[e2.length - 1] |= s4 >> 8 - n3, e2;
}
function E3(r2, e2) {
  let t5 = Math.ceil(11 * r2.length / 8), n3 = arrayify(new Uint8Array(t5)), s4 = 0;
  for (let a6 = 0; a6 < r2.length; a6 += 1) {
    let m4 = e2.indexOf(r2[a6].normalize("NFKD"));
    if (m4 === -1)
      throw new Error("invalid mnemonic");
    for (let h5 = 0; h5 < 11; h5 += 1)
      m4 & 1 << 10 - h5 && (n3[s4 >> 3] |= 1 << 7 - s4 % 8), s4 += 1;
  }
  let o4 = 32 * r2.length / 3, c9 = r2.length / 3, l7 = M4(c9);
  if ((arrayify(sha256(n3.slice(0, o4 / 8)))[0] & l7) !== (n3[n3.length - 1] & l7))
    throw new Error("invalid checksum");
  return n3.slice(0, o4 / 8);
}
var C3 = y("Bitcoin seed");
var D3 = 76066276;
var I3 = 70615956;
function L3(r2) {
  if (r2.length !== 2048)
    throw new Error("Invalid word list length");
}
function N4(r2) {
  if (r2.length % 4 !== 0 || r2.length < 16 || r2.length > 32)
    throw new Error("invalid entropy");
}
function K3(r2) {
  if (![12, 15, 18, 21, 24].includes(r2.length))
    throw new Error("invalid mnemonic size");
}
var i5 = class {
  constructor(e2 = t3) {
    this.wordlist = e2, L3(this.wordlist);
  }
  mnemonicToEntropy(e2) {
    return i5.mnemonicToEntropy(e2, this.wordlist);
  }
  entropyToMnemonic(e2) {
    return i5.entropyToMnemonic(e2, this.wordlist);
  }
  static mnemonicToEntropy(e2, t5 = t3) {
    let n3 = g2(e2);
    return K3(n3), hexlify(E3(n3, t5));
  }
  static entropyToMnemonic(e2, t5 = t3) {
    let n3 = arrayify(e2, { allowMissingPrefix: true });
    return L3(t5), N4(n3), P3(n3).map((s4) => t5[s4]).join(" ");
  }
  static mnemonicToSeed(e2, t5 = "") {
    K3(g2(e2));
    let n3 = y(T2(e2)), s4 = y(`mnemonic${t5}`);
    return pbkdf2(n3, s4, 2048, 64, "sha512");
  }
  static mnemonicToMasterKeys(e2, t5 = "") {
    let n3 = i5.mnemonicToSeed(e2, t5);
    return i5.masterKeysFromSeed(n3);
  }
  static masterKeysFromSeed(e2) {
    let t5 = arrayify(e2);
    if (t5.length < 16 || t5.length > 64)
      throw new Error("invalid seed");
    return arrayify(computeHmac(SupportedAlgorithm.sha512, C3, t5));
  }
  static seedToExtendedKey(e2, t5 = false) {
    let n3 = i5.masterKeysFromSeed(e2), s4 = arrayify(t5 ? I3 : D3), o4 = "0x00", c9 = "0x00000000", l7 = "0x00000000", A6 = n3.slice(32), a6 = n3.slice(0, 32), m4 = concat([s4, o4, c9, l7, A6, concat(["0x00", a6])]), h5 = hexDataSlice(sha256(sha256(m4)), 0, 4);
    return Base58.encode(concat([m4, h5]));
  }
  static generate(e2 = 32, t5 = "") {
    let n3 = t5 ? sha256(concat([u(e2), arrayify(t5)])) : u(e2);
    return i5.entropyToMnemonic(n3);
  }
};
var R2 = i5;

// node_modules/@fuel-ts/hdwallet/dist/index.mjs
var v5 = 2147483648;
var w4 = hexlify("0x0488ade4");
var l3 = hexlify("0x0488b21e");
var E4 = hexlify("0x04358394");
var u3 = hexlify("0x043587cf");
function b5(n3) {
  return Base58.encode(concat([n3, hexDataSlice(sha256(sha256(n3)), 0, 4)]));
}
function M5(n3 = false, e2 = false) {
  return n3 ? e2 ? u3 : l3 : e2 ? E4 : w4;
}
function N5(n3) {
  return [l3, u3].includes(hexlify(n3.slice(0, 4)));
}
function V3(n3) {
  return [w4, E4, l3, u3].includes(hexlify(n3.slice(0, 4)));
}
function T3(n3, e2 = 0) {
  let t5 = n3.split("/");
  if (t5.length === 0 || t5[0] === "m" && e2 !== 0)
    throw new Error(`invalid path - ${n3}`);
  return t5[0] === "m" && t5.shift(), t5.map((r2) => ~r2.indexOf("'") ? parseInt(r2, 10) + v5 : parseInt(r2, 10));
}
var c6 = class {
  constructor(e2) {
    this.depth = 0;
    this.index = 0;
    this.fingerprint = hexlify("0x00000000");
    this.parentFingerprint = hexlify("0x00000000");
    if (e2.privateKey) {
      let t5 = new k2(e2.privateKey);
      this.publicKey = hexlify(t5.compressedPublicKey), this.privateKey = hexlify(e2.privateKey);
    } else {
      if (!e2.publicKey)
        throw new Error("Public and Private Key are missing!");
      this.publicKey = hexlify(e2.publicKey);
    }
    this.parentFingerprint = e2.parentFingerprint || this.parentFingerprint, this.fingerprint = hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4), this.depth = e2.depth || this.depth, this.index = e2.index || this.index, this.chainCode = e2.chainCode;
  }
  get extendedKey() {
    return this.toExtendedKey();
  }
  deriveIndex(e2) {
    let t5 = this.privateKey && arrayify(this.privateKey), r2 = arrayify(this.publicKey), s4 = arrayify(this.chainCode), o4 = new Uint8Array(37);
    if (e2 & v5) {
      if (!t5)
        throw new Error("Derive hardened requires privateKey");
      o4.set(t5, 1);
    } else
      o4.set(arrayify(this.publicKey));
    o4.set(R(e2, 4), 33);
    let p6 = arrayify(computeHmac(SupportedAlgorithm.sha512, s4, o4)), d3 = p6.slice(0, 32), a6 = p6.slice(32);
    if (t5) {
      let C6 = "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", I5 = i(d3).add(t5).mod(C6).toBytes(32);
      return new c6({ privateKey: I5, chainCode: a6, index: e2, depth: this.depth + 1, parentFingerprint: this.fingerprint });
    }
    let k5 = new k2(hexlify(d3)).addPoint(r2);
    return new c6({ publicKey: k5, chainCode: a6, index: e2, depth: this.depth + 1, parentFingerprint: this.fingerprint });
  }
  derivePath(e2) {
    return T3(e2, this.depth).reduce((r2, s4) => r2.deriveIndex(s4), this);
  }
  toExtendedKey(e2 = false, t5 = false) {
    if (this.depth >= 256)
      throw new Error("Depth too large!");
    let r2 = M5(this.privateKey == null || e2, t5), s4 = hexlify(this.depth), o4 = this.parentFingerprint, p6 = S(this.index, 4), d3 = this.chainCode, a6 = this.privateKey != null && !e2 ? concat(["0x00", this.privateKey]) : this.publicKey, K4 = concat([r2, s4, o4, p6, d3, a6]);
    return b5(K4);
  }
  static fromSeed(e2) {
    let t5 = R2.masterKeysFromSeed(e2);
    return new c6({ chainCode: arrayify(t5.slice(32)), privateKey: arrayify(t5.slice(0, 32)) });
  }
  static fromExtendedKey(e2) {
    let t5 = Base58.decode(e2), r2 = b5(t5.slice(0, 78)) === e2;
    if (t5.length !== 82 || !V3(t5))
      throw new Error("Invalid extended key");
    if (!r2)
      throw new Error("Invalid checksum key");
    let s4 = t5[4], o4 = hexlify(t5.slice(5, 9)), p6 = parseInt(hexlify(t5.slice(9, 13)).substring(2), 16), d3 = hexlify(t5.slice(13, 45)), a6 = t5.slice(45, 78);
    if (s4 === 0 && o4 !== "0x00000000" || s4 === 0 && p6 !== 0)
      throw new Error("Invalid depth");
    if (N5(t5)) {
      if (a6[0] !== 3)
        throw new Error("Invalid public extended key");
      return new c6({ publicKey: a6, chainCode: d3, index: p6, depth: s4, parentFingerprint: o4 });
    }
    if (a6[0] !== 0)
      throw new Error("Invalid private extended key");
    return new c6({ privateKey: a6.slice(1), chainCode: d3, index: p6, depth: s4, parentFingerprint: o4 });
  }
};
var j4 = c6;

// node_modules/@fuel-ts/wallet/dist/index.mjs
var O5 = Object.defineProperty;
var B5 = ((o4) => typeof __require != "undefined" ? __require : typeof Proxy != "undefined" ? new Proxy(o4, { get: (r2, e2) => (typeof __require != "undefined" ? __require : r2)[e2] }) : o4)(function(o4) {
  if (typeof __require != "undefined")
    return __require.apply(this, arguments);
  throw new Error('Dynamic require of "' + o4 + '" is not supported');
});
var _4 = (o4, r2) => () => (o4 && (r2 = o4(o4 = 0)), r2);
var z3 = (o4, r2) => {
  for (var e2 in r2)
    O5(o4, e2, { get: r2[e2], enumerable: true });
};
var i6 = _4(() => {
});
i6();
i6();
i6();
var l4 = "http://127.0.0.1:4000/graphql";
var g3 = class extends e {
  constructor(e2, t5 = l4) {
    super();
    this.provider = this.connect(t5), typeof e2 == "string" ? this._address = t2.fromString(e2) : this._address = D2(e2);
  }
  get address() {
    return this._address;
  }
  connect(e2) {
    if (e2)
      typeof e2 == "string" ? this.provider = new v3(e2) : this.provider = e2;
    else
      throw new Error("Provider is required");
    return this.provider;
  }
  async getResourcesToSpend(e2, t5) {
    return this.provider.getResourcesToSpend(this.address, e2, t5);
  }
  async getCoins() {
    let e2 = [], s4;
    for (; ; ) {
      let n3 = await this.provider.getCoins(this.address, void 0, { first: 9999, after: s4 });
      if (e2.push(...n3), !(n3.length >= 9999))
        break;
      throw new Error(`Wallets with more than ${9999} coins are not yet supported`);
    }
    return e2;
  }
  async getMessages() {
    let e2 = [], s4;
    for (; ; ) {
      let n3 = await this.provider.getMessages(this.address, { first: 9999, after: s4 });
      if (e2.push(...n3), !(n3.length >= 9999))
        break;
      throw new Error(`Wallets with more than ${9999} messages are not yet supported`);
    }
    return e2;
  }
  async getBalance(e2 = c2) {
    return await this.provider.getBalance(this.address, e2);
  }
  async getBalances() {
    let e2 = [], s4;
    for (; ; ) {
      let n3 = await this.provider.getBalances(this.address, { first: 9999, after: s4 });
      if (e2.push(...n3), !(n3.length >= 9999))
        break;
      throw new Error(`Wallets with more than ${9999} balances are not yet supported`);
    }
    return e2;
  }
  async fund(e2) {
    let t5 = e2.calculateFee(), s4 = await this.getResourcesToSpend([t5]);
    e2.addResources(s4);
  }
  async transfer(e2, t5, s4 = c2, n3 = {}) {
    let c9 = { gasLimit: lt, ...n3 }, d3 = new C2(c9);
    d3.addCoinOutput(e2, t5, s4);
    let m4 = d3.calculateFee(), f6 = [];
    m4.assetId === hexlify(s4) ? (m4.amount.add(t5), f6 = [m4]) : f6 = [[t5, s4], m4];
    let b9 = await this.getResourcesToSpend(f6);
    return d3.addResources(b9), this.sendTransaction(d3);
  }
  async withdrawToBaseLayer(e2, t5, s4 = {}) {
    let n3 = arrayify("0x".concat(e2.toHexString().substring(2).padStart(64, "0"))), c9 = arrayify("0x".concat(i(t5).toHex().substring(2).padStart(16, "0"))), m4 = { script: new Uint8Array([...arrayify(Ca.bytes), ...n3, ...c9]), gasLimit: lt, ...s4 }, f6 = new C2(m4);
    f6.addMessageOutputs();
    let b9 = f6.calculateFee(), q5 = [];
    b9.amount.add(t5), q5 = [b9];
    let M7 = await this.getResourcesToSpend(q5);
    return f6.addResources(M7), this.sendTransaction(f6);
  }
  async sendTransaction(e2) {
    let t5 = A3(e2);
    return await this.provider.addMissingVariables(t5), this.provider.sendTransaction(t5);
  }
  async simulateTransaction(e2) {
    let t5 = A3(e2);
    return await this.provider.addMissingVariables(t5), this.provider.simulate(t5);
  }
  async buildPredicateTransaction(e2, t5, s4 = c2, n3) {
    let c9 = { fundTransaction: true, ...n3 }, d3 = new C2({ gasLimit: lt, ...c9 });
    d3.addCoinOutput(e2, t5, s4);
    let m4 = [];
    if (c9.fundTransaction && m4.push(d3.calculateFee()), m4.length) {
      let f6 = await this.getResourcesToSpend(m4);
      d3.addResources(f6);
    }
    return d3;
  }
  async submitPredicate(e2, t5, s4 = c2, n3) {
    let c9 = await this.buildPredicateTransaction(e2, t5, s4, n3);
    return (await this.sendTransaction(c9)).waitForResult();
  }
  async submitSpendPredicate(e2, t5, s4, n3 = c2, c9) {
    return this.provider.submitSpendPredicate(e2, t5, this.address, s4, n3, c9);
  }
};
i6();
var T4 = class extends g3 {
  constructor(e2, t5 = l4) {
    let s4 = new k2(e2);
    super(s4.address, t5);
    this.signer = () => s4, this.provider = this.connect(t5);
  }
  get privateKey() {
    return this.signer().privateKey;
  }
  get publicKey() {
    return this.signer().publicKey;
  }
  async signMessage(e2) {
    return this.signer().sign(b4(e2));
  }
  async signTransaction(e2) {
    let t5 = A3(e2), s4 = q3(t5);
    return this.signer().sign(s4);
  }
  async populateTransactionWitnessesSignature(e2) {
    let t5 = A3(e2), s4 = await this.signTransaction(t5);
    return t5.updateWitnessByOwner(this.address, s4), t5;
  }
  async sendTransaction(e2) {
    let t5 = A3(e2);
    return await this.provider.addMissingVariables(t5), this.provider.sendTransaction(await this.populateTransactionWitnessesSignature(t5));
  }
  async simulateTransaction(e2) {
    let t5 = A3(e2);
    return await this.provider.addMissingVariables(t5), this.provider.call(await this.populateTransactionWitnessesSignature(t5), { utxoValidation: true });
  }
};
T4.defaultPath = "m/44'/1179993420'/0'/0/0";
i6();
i6();
var w5 = class extends g3 {
  unlock(r2) {
    return new a5(r2, this.provider);
  }
};
var a5 = class extends T4 {
  lock() {
    return this.signer = () => new k2("0x00"), new w5(this.address, this.provider);
  }
  static generate(r2) {
    let e2 = k2.generatePrivateKey(r2 == null ? void 0 : r2.entropy);
    return new a5(e2, r2 == null ? void 0 : r2.provider);
  }
  static fromSeed(r2, e2) {
    let s4 = j4.fromSeed(r2).derivePath(e2 || a5.defaultPath);
    return new a5(s4.privateKey);
  }
  static fromMnemonic(r2, e2, t5) {
    let s4 = R2.mnemonicToSeed(r2, t5), c9 = j4.fromSeed(s4).derivePath(e2 || a5.defaultPath);
    return new a5(c9.privateKey);
  }
  static fromExtendedKey(r2) {
    let e2 = j4.fromExtendedKey(r2);
    return new a5(e2.privateKey);
  }
};
var y2 = class {
  static fromAddress(r2, e2 = l4) {
    return new w5(r2, e2);
  }
  static fromPrivateKey(r2, e2 = l4) {
    return new a5(r2, e2);
  }
};
y2.generate = a5.generate, y2.fromSeed = a5.fromSeed, y2.fromMnemonic = a5.fromMnemonic, y2.fromExtendedKey = a5.fromExtendedKey;
var F3 = {};
z3(F3, { generateTestWallet: () => se3, seedWallet: () => U2 });
i6();
i6();
i6();
i6();
i6();
i6();
var x3;
var N6 = "Node";
typeof globalThis < "u" && globalThis.crypto && (x3 = globalThis.crypto, N6 = "Web");
if (!x3 && typeof B5 == "function")
  try {
    x3 = B5("crypto"), N6 = "Node";
  } catch (o4) {
    console.error("keystore expects a standard Web browser or Node environment.", o4);
  }
var v6 = x3;
var S5 = N6;
i6();
var P4 = (o4) => S5 === "Node" ? v6.randomBytes(o4) : v6.getRandomValues(new Uint8Array(o4));
i6();
var U2 = async (o4, r2) => {
  let e2 = new a5(process.env.GENESIS_SECRET || P4(32), o4.provider), t5 = await e2.getResourcesToSpend(r2), s4 = new C2({ gasLimit: 1e4, gasPrice: 1 });
  s4.addResources(t5), r2.map(O4).forEach(({ amount: c9, assetId: d3 }) => s4.addCoinOutput(o4.address, c9, d3)), await (await e2.sendTransaction(s4)).wait();
};
var se3 = async (o4, r2) => {
  let e2 = y2.generate({ provider: o4 });
  return r2 && await U2(e2, r2), e2;
};

// node_modules/@fuel-ts/merkle-shared/dist/index.mjs
var c7 = "0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
function b6(o4) {
  return sha256(o4);
}

// node_modules/@fuel-ts/merkle/dist/index.mjs
var f4 = class {
  constructor(t5, i7, r2, s4, h5, e2 = 0) {
    this.left = t5, this.right = i7, this.parent = r2, this.hash = s4, this.data = h5, this.index = e2;
  }
};
var c8 = f4;
function x4(n3) {
  return b6("0x00".concat(n3.slice(2)));
}
function d(n3, t5) {
  return b6("0x01".concat(n3.slice(2)).concat(t5.slice(2)));
}
function k3(n3) {
  if (!n3.length)
    return c7;
  let t5 = [];
  for (let h5 = 0; h5 < n3.length; h5 += 1) {
    let e2 = x4(n3[h5]);
    t5.push(new c8(-1, -1, -1, e2, n3[h5]));
  }
  let i7 = t5, r2 = t5.length + 1 >> 1, s4 = t5.length & 1;
  for (; ; ) {
    let h5 = 0;
    for (; h5 < r2 - s4; h5 += 1) {
      let e2 = h5 << 1, o4 = d(i7[e2].hash, i7[e2 + 1].hash);
      t5[h5] = new c8(i7[e2].index, i7[e2 + 1].index, -1, o4, "");
    }
    if (s4 === 1 && (t5[h5] = i7[h5 << 1]), r2 === 1)
      break;
    s4 = r2 & 1, r2 = r2 + 1 >> 1, i7 = t5;
  }
  return t5[0].hash;
}

// node_modules/@fuel-ts/sparsemerkle/dist/index.mjs
var A4 = "0x00";
var R3 = "0x01";
function M6(o4, t5) {
  let e2 = "0x00".concat(o4.slice(2)).concat(b6(t5).slice(2));
  return [b6(e2), e2];
}
function d2(o4, t5) {
  let e2 = "0x01".concat(o4.slice(2)).concat(t5.slice(2));
  return [b6(e2), e2];
}
function S6(o4) {
  let t5 = R3.length;
  return ["0x".concat(o4.slice(t5, t5 + 64)), "0x".concat(o4.slice(t5 + 64))];
}
function B6(o4) {
  let t5 = R3.length;
  return ["0x".concat(o4.slice(t5, t5 + 64)), "0x".concat(o4.slice(t5 + 64))];
}
function b7(o4) {
  return o4.slice(0, 4) === A4;
}
var P5 = class {
  constructor(t5, e2, r2, n3, f6) {
    this.SideNodes = t5, this.NonMembershipLeafData = e2, this.BitMask = r2, this.NumSideNodes = n3, this.SiblingData = f6;
  }
};
var C4 = P5;
var D4 = class {
  constructor(t5, e2, r2) {
    this.SideNodes = t5, this.NonMembershipLeafData = e2, this.SiblingData = r2;
  }
};
var L4 = D4;
var l5 = "0x0000000000000000000000000000000000000000000000000000000000000000";
function p4(o4, t5) {
  let e2 = o4.slice(2), r2 = "0x".concat(e2.slice(Math.floor(t5 / 8) * 2, Math.floor(t5 / 8) * 2 + 2));
  return (Number(r2) & 1 << 8 - 1 - t5 % 8) > 0 ? 1 : 0;
}
function k4(o4) {
  let t5 = 0, e2 = o4.length - 1, r2 = o4;
  for (; t5 < e2; )
    [r2[t5], r2[e2]] = [r2[e2], r2[t5]], t5 += 1, e2 -= 1;
  return r2;
}
function v7(o4, t5) {
  let e2 = 0;
  for (let r2 = 0; r2 < 256 && p4(o4, r2) === p4(t5, r2); r2 += 1)
    e2 += 1;
  return e2;
}
function E5(o4) {
  let t5 = [], e2 = [], r2;
  for (let f6 = 0; f6 < o4.SideNodes.length; f6 += 1)
    r2 = o4.SideNodes[f6], r2 === l5 ? t5.push(0) : (e2.push(r2), t5.push(1));
  return new C4(e2, o4.NonMembershipLeafData, t5, o4.SideNodes.length, o4.SiblingData);
}
var H4 = class {
  constructor() {
    let t5 = {};
    this.ms = t5, this.root = l5, this.ms[this.root] = l5;
  }
  get(t5) {
    return this.ms[t5];
  }
  set(t5, e2) {
    this.ms[t5] = e2;
  }
  setRoot(t5) {
    this.root = t5;
  }
  sideNodesForRoot(t5, e2) {
    let r2 = [];
    if (e2 === l5)
      return [r2, l5, "", ""];
    let n3 = this.get(e2);
    if (b7(n3))
      return [r2, e2, n3, ""];
    let f6, i7, s4 = "", c9 = "";
    for (let h5 = 0; h5 < 256; h5 += 1) {
      if ([f6, i7] = B6(n3), p4(t5, h5) === 1 ? (c9 = f6, s4 = i7) : (c9 = i7, s4 = f6), r2.push(c9), s4 === l5) {
        n3 = "";
        break;
      }
      if (n3 = this.get(s4), b7(n3))
        break;
    }
    let a6 = this.get(c9);
    return [k4(r2), s4, n3, a6];
  }
  deleteWithSideNodes(t5, e2, r2, n3) {
    if (r2 === l5)
      return this.root;
    let [f6] = S6(n3);
    if (f6 !== t5)
      return this.root;
    let i7 = "", s4 = "", c9 = "", a6 = "", h5 = false;
    for (let g4 = 0; g4 < e2.length; g4 += 1)
      if (e2[g4] !== "") {
        if (c9 = e2[g4], s4 === "")
          if (a6 = this.get(c9), b7(a6)) {
            i7 = c9, s4 = c9;
            continue;
          } else
            s4 = l5, h5 = true;
        !h5 && c9 === l5 || (h5 || (h5 = true), p4(t5, e2.length - 1 - g4) === 1 ? [i7, s4] = d2(c9, s4) : [i7, s4] = d2(s4, c9), this.set(i7, s4), s4 = i7);
      }
    return i7 === "" && (i7 = l5), i7;
  }
  updateWithSideNodes(t5, e2, r2, n3, f6) {
    let i7, s4;
    this.set(b6(e2), e2), [i7, s4] = M6(t5, e2), this.set(i7, s4), s4 = i7;
    let c9;
    if (n3 === l5)
      c9 = 256;
    else {
      let [a6] = S6(f6);
      c9 = v7(t5, a6);
    }
    c9 !== 256 && (p4(t5, c9) === 1 ? [i7, s4] = d2(n3, s4) : [i7, s4] = d2(s4, n3), this.set(i7, s4), s4 = i7);
    for (let a6 = 0; a6 < 256; a6 += 1) {
      let h5, g4 = 256 - r2.length;
      if (a6 - g4 < 0 || r2[a6 - g4] === "")
        if (c9 !== 256 && c9 > 256 - 1 - a6)
          h5 = l5;
        else
          continue;
      else
        h5 = r2[a6 - g4];
      p4(t5, 256 - 1 - a6) === 1 ? [i7, s4] = d2(h5, s4) : [i7, s4] = d2(s4, h5), this.set(i7, s4), s4 = i7;
    }
    return i7;
  }
  update(t5, e2) {
    let [r2, n3, f6] = this.sideNodesForRoot(t5, this.root), i7;
    e2 === l5 ? i7 = this.deleteWithSideNodes(t5, r2, n3, f6) : i7 = this.updateWithSideNodes(t5, e2, r2, n3, f6), this.setRoot(i7);
  }
  delete(t5) {
    this.update(t5, l5);
  }
  prove(t5) {
    let [e2, r2, n3, f6] = this.sideNodesForRoot(t5, this.root), i7 = [];
    for (let a6 = 0; a6 < e2.length; a6 += 1)
      e2[a6] !== "" && i7.push(e2[a6]);
    let s4 = "";
    if (r2 !== l5) {
      let [a6] = S6(n3);
      a6 !== t5 && (s4 = n3);
    }
    return new L4(i7, s4, f6);
  }
  proveCompacted(t5) {
    let e2 = this.prove(t5);
    return E5(e2);
  }
};
var w6 = H4;

// node_modules/@fuel-ts/script/dist/index.mjs
var D5 = ["Success", "Revert", "OutOfGas", "TransactionValidity", "MemoryOverflow", "ArithmeticOverflow", "ContractNotFound", "MemoryOwnership", "NotEnoughBalance", "ExpectedInternalContext", "AssetIdNotFound", "InputNotFound", "OutputNotFound", "WitnessNotFound", "TransactionMaturity", "InvalidMetadataIdentifier", "MalformedCallStructure", "ReservedRegisterNotWritable", "ErrorFlag", "InvalidImmediateValue", "ExpectedCoinInput", "MaxMemoryAccess", "MemoryWriteOverlap", "ContractNotInInputs", "InternalBalanceOverflow", "ContractMaxSize", "ExpectedUnallocatedStack", "MaxStaticContractsReached", "TransferAmountCannotBeZero", "ExpectedOutputVariable", "ExpectedParentInternalContext", "IllegalJump", "NonZeroMessageOutputRecipient", "ZeroedMessageOutputRecipient"];
var p5 = "https://docs.rs/fuel-asm/latest/fuel_asm/enum.PanicReason.html";
var h3 = (e2) => D5.includes(e2) ? e2 : "unknown";
var S7 = (e2) => {
  if ((e2 == null ? void 0 : e2.type) === "failure") {
    let t5 = h3(e2.reason);
    return { doc: t5 !== "unknown" ? `${p5}#variant.${t5}` : p5, reason: t5 };
  }
  return { doc: p5, reason: "unknown" };
};
var E6 = (e2, t5) => typeof t5 == "bigint" ? t5.toString() : t5;
var I4 = (e2, t5) => `${e2 === t ? "script" : e2}: ${t5}`;
var l6 = class extends Error {
  constructor(t5, r2) {
    let n3 = JSON.stringify(S7(t5.status), null, 2), d3 = t5.receipts.filter((s4) => s4.type === Ge.Revert), y4 = d3.length ? `Reverts:
${d3.map(({ id: s4, ...o4 }) => I4(s4, `${o4.val} ${JSON.stringify(o4, E6)}`)).join(`
`)}` : null, m4 = t5.receipts.filter((s4) => s4.type === Ge.Log || s4.type === Ge.LogData), T6 = m4.length ? `Logs:
${m4.map(({ type: s4, id: o4, ...g4 }) => I4(o4, `${s4 === Ge.LogData ? g4.data : g4.val0}`)).join(`
`)}` : null, O7 = `Receipts:
${JSON.stringify(t5.receipts.map(({ type: s4, ...o4 }) => ({ type: Ge[s4], ...o4 })), E6, 2)}`;
    super(`${r2}

${n3}

${y4 ? `${y4}

` : ""}${T6 ? `${T6}

` : ""}${O7}`);
  }
};
function L5(e2) {
  let t5 = [...e2.receipts], r2 = t5.pop();
  if (!r2)
    throw new Error("Expected scriptResultReceipt");
  if (r2.type !== Ge.ScriptResult)
    throw new Error(`Invalid scriptResultReceipt type: ${r2.type}`);
  let n3 = t5.pop();
  if (!n3)
    throw new Error("Expected returnReceipt");
  if (n3.type !== Ge.Return && n3.type !== Ge.ReturnData && n3.type !== Ge.Revert)
    throw new Error(`Invalid returnReceipt type: ${n3.type}`);
  return { code: r2.result, gasUsed: r2.gasUsed, receipts: t5, scriptResultReceipt: r2, returnReceipt: n3, callResult: e2 };
}
var R4 = class {
  constructor(t5, r2, n3) {
    this.bytes = arrayify(t5), this.scriptDataEncoder = r2, this.scriptResultDecoder = n3;
  }
  getScriptDataOffset() {
    return Jt + Lt + new a3(this.bytes.length).encodedLength;
  }
  getArgOffset() {
    return this.getScriptDataOffset() + Pt + ue + Dt + ue + ue;
  }
  encodeScriptData(t5) {
    return this.scriptDataEncoder(t5);
  }
  decodeCallResult(t5) {
    try {
      let r2 = L5(t5);
      return this.scriptResultDecoder(r2);
    } catch (r2) {
      throw new l6(t5, r2.message);
    }
  }
};
var X3 = new R4("0x24000000", () => new Uint8Array(0), () => {
});

// node_modules/@fuel-ts/contract/dist/index.mjs
var H5 = Object.defineProperty;
var $4 = (o4, t5) => {
  for (var e2 in t5)
    H5(o4, e2, { get: t5[e2], enumerable: true });
};
var D6 = {};
$4(D6, { assert: () => h4, getContractId: () => q4, getContractRoot: () => O6, getContractStorageRoot: () => x5, includeHexPrefix: () => w7 });
var O6 = (o4) => {
  let e2 = [];
  for (let n3 = 0; n3 < o4.length; n3 += 8) {
    let a6 = new Uint8Array(8);
    a6.set(o4.slice(n3, n3 + 8)), e2.push(a6);
  }
  return k3(e2.map((n3) => hexlify(n3)));
};
var x5 = (o4) => {
  let t5 = new w6();
  return o4.forEach(({ key: e2, value: n3 }) => t5.update(e2, n3)), t5.root;
};
var q4 = (o4, t5, e2) => {
  let n3 = O6(arrayify(o4));
  return sha256(concat(["0x4655454C", t5, n3, e2]));
};
function h4(o4, t5) {
  if (!o4)
    throw new Error(t5);
}
var w7 = (o4, t5) => hexlify(o4, { ...t5, allowMissingPrefix: true });
var _5 = [{ type: "function", inputs: [{ name: "script_data", type: "struct ScriptData", components: [{ name: "calls", type: "[enum Option; 5]", components: [{ name: "__array_element", type: "enum Option", components: [{ name: "None", type: "()", components: [], typeArguments: null }, { name: "Some", type: "struct MulticallCall", components: [{ name: "contract_id", type: "struct ContractId", components: [{ name: "value", type: "b256", components: null, typeArguments: null }], typeArguments: null }, { name: "fn_selector", type: "u64", components: null, typeArguments: null }, { name: "fn_arg", type: "enum CallValue", components: [{ name: "Value", type: "u64", components: null, typeArguments: null }, { name: "Data", type: "(u64, u64)", components: [{ name: "__tuple_element", type: "u64", components: null, typeArguments: null }, { name: "__tuple_element", type: "u64", components: null, typeArguments: null }], typeArguments: null }], typeArguments: null }, { name: "parameters", type: "struct CallParameters", components: [{ name: "amount", type: "enum Option", components: [{ name: "None", type: "()", components: [], typeArguments: null }, { name: "Some", type: "u64", components: null, typeArguments: null }], typeArguments: [{ name: "T", type: "u64", components: null, typeArguments: null }] }, { name: "asset_id", type: "enum Option", components: [{ name: "None", type: "()", components: [], typeArguments: null }, { name: "Some", type: "struct ContractId", components: [{ name: "value", type: "b256", components: null, typeArguments: null }], typeArguments: null }], typeArguments: [{ name: "T", type: "struct ContractId", components: [{ name: "value", type: "b256", components: null, typeArguments: null }], typeArguments: null }] }, { name: "gas", type: "enum Option", components: [{ name: "None", type: "()", components: [], typeArguments: null }, { name: "Some", type: "u64", components: null, typeArguments: null }], typeArguments: [{ name: "T", type: "u64", components: null, typeArguments: null }] }], typeArguments: null }], typeArguments: null }], typeArguments: [{ name: "T", type: "struct MulticallCall", components: [{ name: "contract_id", type: "struct ContractId", components: [{ name: "value", type: "b256", components: null, typeArguments: null }], typeArguments: null }, { name: "fn_selector", type: "u64", components: null, typeArguments: null }, { name: "fn_arg", type: "enum CallValue", components: [{ name: "Value", type: "u64", components: null, typeArguments: null }, { name: "Data", type: "(u64, u64)", components: [{ name: "__tuple_element", type: "u64", components: null, typeArguments: null }, { name: "__tuple_element", type: "u64", components: null, typeArguments: null }], typeArguments: null }], typeArguments: null }, { name: "parameters", type: "struct CallParameters", components: [{ name: "amount", type: "enum Option", components: [{ name: "None", type: "()", components: [], typeArguments: null }, { name: "Some", type: "u64", components: null, typeArguments: null }], typeArguments: [{ name: "T", type: "u64", components: null, typeArguments: null }] }, { name: "asset_id", type: "enum Option", components: [{ name: "None", type: "()", components: [], typeArguments: null }, { name: "Some", type: "struct ContractId", components: [{ name: "value", type: "b256", components: null, typeArguments: null }], typeArguments: null }], typeArguments: [{ name: "T", type: "struct ContractId", components: [{ name: "value", type: "b256", components: null, typeArguments: null }], typeArguments: null }] }, { name: "gas", type: "enum Option", components: [{ name: "None", type: "()", components: [], typeArguments: null }, { name: "Some", type: "u64", components: null, typeArguments: null }], typeArguments: [{ name: "T", type: "u64", components: null, typeArguments: null }] }], typeArguments: null }], typeArguments: null }] }], typeArguments: null }], typeArguments: null }], name: "main", outputs: [{ name: "", type: "struct ScriptReturn", components: [{ name: "call_returns", type: "[enum Option; 5]", components: [{ name: "__array_element", type: "enum Option", components: [{ name: "None", type: "()", components: [], typeArguments: null }, { name: "Some", type: "enum CallValue", components: [{ name: "Value", type: "u64", components: null, typeArguments: null }, { name: "Data", type: "(u64, u64)", components: [{ name: "__tuple_element", type: "u64", components: null, typeArguments: null }, { name: "__tuple_element", type: "u64", components: null, typeArguments: null }], typeArguments: null }], typeArguments: null }], typeArguments: [{ name: "T", type: "enum CallValue", components: [{ name: "Value", type: "u64", components: null, typeArguments: null }, { name: "Data", type: "(u64, u64)", components: [{ name: "__tuple_element", type: "u64", components: null, typeArguments: null }, { name: "__tuple_element", type: "u64", components: null, typeArguments: null }], typeArguments: null }], typeArguments: null }] }], typeArguments: null }], typeArguments: null }] }];
var N7 = "0x90000004470000000000000000000cd45dfcc00110fff3001a5c5000910005b861440006724002d0164114005b40100d360000006158000c61440001504175305f5d10a6504175305d4570a6504171385f5d1027504171385d417027134100007340001a9000001f1a445000910000085d43f0005f4500009000002b504171385d4170271341004073400024900000291a445000910000085d43f0015f4500009000002b360000001a44000050417528504175286041100850457528504170085041700860411008504170085d4100001341000073400037900000396144000c9000003b360000001a440000504174305f5d1086504174305d4570865d43f00210450440504174485f5d108961440001504175405f5d10a8504175405d4570a8504171405f5d1028504171405d417028134100007340004f900000541a445000910000085d43f0005f45000090000060504171405d41702813410040734000599000005e1a445000910000085d43f0015f45000090000060360000001a44000050417538504175386041100850457538504170005041700060411008504170005d410000134100007340006c9000006e6144000690000078504170005d410000134100407340007390000076360000001a44000090000078360000001a4400005d43f00220451400504173805f5d1070504174485d497089504173805d4170701a445000910000105f4520005f450001504175a8504175a8604110105d47f00326440000504470015041726050417260604110a026000000504070011a445000910000105f4500005f440001504174785041747860411010504173505f5c006a5d47f0025d43f00412451400504173005f5d1060504173505d45706a504173005d41706016411400734000a4900000b150496000504173505d41706a5545009010452440504170785041707860411090504170785d41000013410040734001249000031f504972601a445000910000a050411000604120a05041748850417488604110a026000000504070011a445000910000105f4500005f44000150417198504171986041101050517198505574885d454001504174085f5d10815d4540015d43f00310450440504173c85f5d10795d4140005d4d4001504573c85d457079154914c0734800d3900000e12644000050487001504573a85f5d207515453000734400da900000de504573a85d457075284504c0900000de504173a85d417075900000e15f510000504173c85d4170795f5100015d454000504174085d417081104504405d43f0032845540050557198505174785d41400113410000734000f1900000f35d4150019000011c5d455001504174105f5d10825d4550015d41400110450440504173d05f5d107a5d4150005d4d5001504573d05d45707a154914c073480102900001102644000050487001504573b05f5d207615453000734401099000010d504573b05d457076284504c09000010d504173b05d417076900001105f550000504173d05d41707a5f5500015d4940005d455000504174105d417082104504405d414001284524005d417082504171985d450000504171985d41000125450000504574885d43f003254500005041707850450008504171a8504171a860411088504171a850450028504171085041710860411018504171085d41000013410000734001339000013f504171085d450002504175485f5d10a9504175485d4970a91a445000910000185d43f0005f4500005f4520029000017b504171085d41000013410040734001449000016050417108504100085d450000504173e85f5d107d50417108504100085d450001504173785f5d106f504175a85d450000504173e85d41707d10450440504173785d41706f1a485000910000105f4910005f4900011a445000910000185d43f0015f45000050411008604120109000017b50417108504100085d450000504173f05f5d107e50417108504100085d450001504173905f5d1072504175a85d450000504173f05d41707e10450440504173905d4170721a485000910000105f4910005f4900011a445000910000185d43f0015f4500005041100860412010504173085041730860411018504171a850550000504171a85d51000450457308504171a8504d0040504170105041701060411018504170105d410000134100007340018d90000194504170105d450002504175505f5d10aa504175505d4570aa900001a8504170105d4100001341004073400199900001a150417010504100085d450000504174385f5d1087504174385d457087900001a850417010504100085d450000504174505f5d108a504174505d45708a504173205f5d1064504173205d4970641a4450009100003050411000604150205f4540045f45200550417230504172306041103050453000504170285041702860411010504170285d41000013410040734001be900001c5504170285d450001504171485f5d1029504171485d457029900001cd504170285d41000013410000734001ca900001cc1a440000900001cd1a440000504171505f5d102a50453010504170385041703860411028504170385d41000013410040734001d8900001df504170385045000850417358504173586041102050497358900001f1504170385d41000013410000734001e4900001eb1a485000910000205d47f00a104513005041200060411020900001f11a485000910000205d47f00a10451300504120006041102050417158504171586041202050453038504170605041706060411010504170605d41000013410040734001fd90000204504170605d450001504173405f5d1068504173405d4570689000020c504170605d41000013410000734002099000020b1a44a0009000020c1a44a000504173485f5d1069504d7230504171505d49702a50457158504173485d4170692d4d24501a44e000504170705f5d100e504170705d41700e134100007340021d900002281a44d000504175785f5d10af504175785d4570af1a485000910000185d43f0005f4900005f4910029000023d504170705d45700e504173885f5d10711a44d000504174585f5d108b504174585d49708b504173885d4170711a445000910000105f4520005f4500011a485000910000185d43f0015f490000504120086041101050417460504174606041201850457460504171205041712060411018504171205d410000134100007340024990000255504171205d450002504175a05f5d10b4504175a05d4970b41a445000910000185d43f0005f4500005f45200290000309504171205d410000134100407340025a900002b250417120504100085d450000504174285f5d108550417120504100085d450001504173985f5d1073504174285d497085504173985d4170731a445000910000105f4520005f45000150417178504171786041101050557478505171785d4140011341000073400275900002775d455001900002a15d455001504174185f5d10835d4550015d41400110450440504173d85f5d107b5d4150005d4d5001504573d85d45707b154914c073480286900002942644000050487001504573b85f5d2077154530007344028d90000291504573b85d457077284504c090000291504173b85d417077900002945f550000504173d85d41707b5f5500015d4940005d455000504174185d417083104504405d41400128452400504174185d457083504173f85f5d107f504173f85d45707f504173985d4170731a485000910000105f4910005f4900011a445000910000185d43f0015f45000050411008604120109000030950417120504100085d450000504174405f5d108850417120504100085d450001504173a05f5d1074504174405d497088504173a05d4170741a445000910000105f4520005f45000150417188504171886041101050557478505171885d41400113410000734002cd900002cf5d455001900002f95d455001504174205f5d10845d4550015d41400110450440504173e05f5d107c5d4150005d4d5001504573e05d45707c154914c0734802de900002ec2644000050487001504573c05f5d207815453000734402e5900002e9504573c05d457078284504c0900002e9504173c05d417078900002ec5f550000504173e05d41707c5f5500015d4940005d455000504174205d417084104504405d41400128452400504174205d457084504174005f5d1080504174005d457080504173a05d4170741a485000910000105f4910005f4900011a445000910000185d43f0015f4500005041100860412010504173285041732860411018504973281a445000910000205d43f0015f450000504110086041201850417558504175586041102050457260504173505d41706a5549002010491480504575585d43f009284914009000032e504175801a445000910000205d43f0005f450000504175806041102050457260504173505d41706a5549002010491480504575805d43f0092849140050417350504173505d41706a104014005f5d006a9000009d470000000000000000000000000000000000000100000000000002d000000000000000a00000000000000090000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000cfc";
var T5 = new R4(N7, (o4) => {
  let t5 = _5[0].inputs, e2 = new O2().getCoder(t5[0]), n3 = e2.coders.calls.length;
  if (o4.length > n3)
    throw new Error(`At most ${n3} calls are supported`);
  let a6 = new Uint8Array(), r2 = [];
  for (let l7 = 0; l7 < n3; l7 += 1) {
    let c9 = o4[l7], u4;
    if (c9) {
      let R5 = arrayify(c9.data), z4 = R5.slice(0, 8), G2 = R5.slice(8, 16).some((X4) => X4 === 1), L6 = R5.slice(16), k5;
      G2 ? (k5 = { Data: [a6.length, L6.length] }, a6 = concat([a6, L6])) : k5 = { Value: new l().decode(L6, 0)[0] }, u4 = { contract_id: { value: c9.contractId }, fn_selector: new l().decode(z4, 0)[0], fn_arg: k5, parameters: { amount: c9.amount ? i(c9.amount) : void 0, asset_id: c9.assetId ? { value: c9.assetId } : void 0, gas: c9.gas ? i(c9.gas) : void 0 } };
    } else
      u4 = void 0;
    r2.push(u4);
  }
  let s4 = { calls: r2 }, i7 = e2.encode(s4);
  return concat([i7, a6]);
}, (o4) => {
  if (F(o4.code) !== 0)
    throw new Error(`Script returned non-zero result: ${o4.code}`);
  if (o4.returnReceipt.type !== Ge.ReturnData)
    throw new Error("Expected returnReceipt to be a ReturnDataReceipt");
  let t5 = arrayify(o4.returnReceipt.data), e2 = _5[0].outputs, n3 = new O2().getCoder(e2[0]), [a6, r2] = n3.decode(t5, 0), s4 = t5.slice(r2), i7 = [];
  return a6.call_returns.forEach((l7, c9) => {
    if (l7)
      if (l7.Data) {
        let [u4, R5] = l7.Data;
        i7[c9] = s4.slice(F(u4), F(u4) + F(R5));
      } else
        i7[c9] = new l().encode(l7.Value);
  }), i7;
});
function i0(o4) {
  let t5 = o4.receipts.find((e2) => e2.type === Ge.ScriptResult);
  return (t5 == null ? void 0 : t5.gasUsed) || i(0);
}
var b8 = class {
  constructor(t5, e2, n3) {
    this.functionScopes = Array.isArray(t5) ? t5 : [t5], this.isMultiCall = n3, this.value = this.getDecodedValue(e2), this.gasUsed = i0(e2);
  }
  getDecodedValue(t5) {
    let n3 = T5.decodeCallResult(t5).map((a6, r2) => {
      var l7;
      let { contract: s4, func: i7 } = this.functionScopes[r2].getCallConfig();
      return (l7 = s4.interface.decodeFunctionResult(i7, a6)) == null ? void 0 : l7[0];
    });
    return this.isMultiCall ? n3 : n3 == null ? void 0 : n3[0];
  }
};
var f5 = class extends b8 {
  constructor(e2, n3, a6, r2, s4) {
    super(e2, a6, s4);
    this.transactionResponse = n3, this.transactionResult = a6, this.transactionId = this.transactionResponse.id, this.contract = r2, this.logs = this.getDecodedLogs(a6.receipts);
  }
  static async build(e2, n3, a6, r2) {
    let s4 = await n3.waitForResult();
    return new f5(e2, n3, s4, r2, a6);
  }
  getDecodedLogs(e2) {
    return e2.reduce((n3, a6) => a6.type === Ge.LogData ? n3.concat(...this.contract.interface.decodeLog(a6.data, a6.val1.toNumber())) : a6.type === Ge.Log ? n3.concat(...this.contract.interface.decodeLog(new l().encode(a6.val0), a6.val1.toNumber())) : n3, []);
  }
};
var y3 = class extends b8 {
  constructor(e2, n3, a6) {
    super(e2, n3, a6);
    this.callResult = n3;
  }
  static async build(e2, n3, a6) {
    return new y3(e2, n3, a6);
  }
};
function p0(o4) {
  let { contract: t5, args: e2, forward: n3, func: a6, callParameters: r2, bytesOffset: s4 } = o4.getCallConfig(), i7 = t5.interface.encodeFunctionData(a6, e2, T5.getScriptDataOffset() + s4);
  return { contractId: t5.id, data: i7, assetId: n3 == null ? void 0 : n3.assetId, amount: n3 == null ? void 0 : n3.amount, gas: r2 == null ? void 0 : r2.gasLimit };
}
var m3 = class {
  constructor(t5, e2) {
    this.functionInvocationScopes = [];
    this.requiredCoins = [];
    this.isMultiCall = false;
    this.contract = t5, this.isMultiCall = e2, this.transactionRequest = new C2({ gasLimit: lt });
  }
  get calls() {
    return this.functionInvocationScopes.map((t5) => p0(t5));
  }
  static getCallOptions(t5) {
    return { fundTransaction: true, ...t5 };
  }
  updateScriptRequest() {
    let t5 = this.calls;
    t5.forEach((e2) => {
      this.transactionRequest.addContract(e2.contractId);
    }), this.transactionRequest.setScript(T5, t5);
  }
  getRequiredCoins() {
    return this.calls.map((e2) => ({ assetId: String(e2.assetId), amount: i(e2.amount || 0) })).concat(this.transactionRequest.calculateFee()).filter(({ assetId: e2, amount: n3 }) => e2 && !i(n3).isZero());
  }
  updateRequiredCoins() {
    let t5 = this.getRequiredCoins(), e2 = (n3, { assetId: a6, amount: r2 }) => {
      var i7;
      let s4 = ((i7 = n3.get(a6)) == null ? void 0 : i7.amount) || i(0);
      return n3.set(a6, { assetId: String(a6), amount: s4.add(r2) });
    };
    this.requiredCoins = Array.from(t5.reduce(e2, /* @__PURE__ */ new Map()).values());
  }
  addCall(t5) {
    return this.addCalls([t5]), this;
  }
  addCalls(t5) {
    return this.functionInvocationScopes.push(...t5), this.updateScriptRequest(), this.updateRequiredCoins(), this;
  }
  async prepareTransaction(t5) {
    this.updateScriptRequest(), this.updateRequiredCoins(), this.checkGasLimitTotal(), m3.getCallOptions(t5).fundTransaction && this.contract.wallet && await this.fundWithRequiredCoins();
  }
  checkGasLimitTotal() {
    if (this.calls.reduce((e2, n3) => e2.add(n3.gas || 0), i(0)).gt(this.transactionRequest.gasLimit))
      throw new Error("Transaction gasLimit can't be lower than the sum of the forwarded gas of each call");
  }
  async getTransactionCost(t5) {
    var r2;
    let e2 = ((r2 = this.contract.wallet) == null ? void 0 : r2.provider) || this.contract.provider;
    h4(e2, "Wallet or Provider is required!"), await this.prepareTransaction(t5);
    let n3 = A3(this.transactionRequest);
    return n3.gasPrice = i(F(n3.gasPrice) || F((t5 == null ? void 0 : t5.gasPrice) || 0)), await e2.getTransactionCost(n3, t5 == null ? void 0 : t5.tolerance);
  }
  async fundWithRequiredCoins() {
    var e2;
    this.transactionRequest.inputs = this.transactionRequest.inputs.filter((n3) => n3.type !== We.Coin);
    let t5 = await ((e2 = this.contract.wallet) == null ? void 0 : e2.getResourcesToSpend(this.requiredCoins));
    return this.transactionRequest.addResources(t5 || []), this;
  }
  txParams(t5) {
    var n3;
    this.txParameters = t5;
    let e2 = this.transactionRequest;
    return e2.gasLimit = i(t5.gasLimit || e2.gasLimit), e2.gasPrice = i(t5.gasPrice || e2.gasPrice), e2.addVariableOutputs(((n3 = this.txParameters) == null ? void 0 : n3.variableOutputs) || 0), this;
  }
  addContracts(t5) {
    return t5.forEach((e2) => this.transactionRequest.addContract(e2)), this;
  }
  async getTransactionRequest(t5) {
    return await this.prepareTransaction(t5), this.transactionRequest;
  }
  async call(t5) {
    h4(this.contract.wallet, "Wallet is required!");
    let e2 = await this.getTransactionRequest(t5), n3 = await this.contract.wallet.sendTransaction(e2);
    return f5.build(this.functionInvocationScopes, n3, this.isMultiCall, this.contract);
  }
  async simulate(t5) {
    h4(this.contract.wallet, "Wallet is required!");
    let e2 = await this.getTransactionRequest(t5), n3 = await this.contract.wallet.simulateTransaction(e2);
    return y3.build(this.functionInvocationScopes, n3, this.isMultiCall);
  }
  async dryRun(t5) {
    var i7;
    let e2 = ((i7 = this.contract.wallet) == null ? void 0 : i7.provider) || this.contract.provider;
    h4(e2, "Wallet or Provider is required!");
    let n3 = await this.getTransactionRequest(t5), a6 = A3(n3), r2 = await e2.call(a6, { utxoValidation: false });
    return await y3.build(this.functionInvocationScopes, r2, this.isMultiCall);
  }
  async get(t5) {
    return this.dryRun({ fundTransaction: false, ...t5 });
  }
};
var S8 = class extends m3 {
  constructor(e2, n3, a6) {
    super(e2, false);
    this.func = n3, this.args = a6 || [], this.setArguments(...a6), super.addCall(this);
  }
  getCallConfig() {
    return { func: this.func, contract: this.contract, callParameters: this.callParameters, txParameters: this.txParameters, forward: this.forward, args: this.args, bytesOffset: this.transactionRequest.bytesOffset || 0 };
  }
  setArguments(...e2) {
    return this.args = e2 || [], this.updateScriptRequest(), this;
  }
  callParams(e2) {
    return this.callParameters = e2, e2 != null && e2.forward && (this.forward = O4(e2.forward)), this.setArguments(...this.args), this.updateRequiredCoins(), this;
  }
};
var v8 = class extends m3 {
  constructor(t5, e2) {
    super(t5, true), this.addCalls(e2);
  }
  addCall(t5) {
    return super.addCalls([t5]);
  }
  addCalls(t5) {
    return super.addCalls(t5);
  }
};
var C5 = class {
  constructor(t5, e2, n3 = null) {
    this.functions = {};
    this.interface = e2 instanceof E ? e2 : new E(e2), this.id = t2.fromAddressOrString(t5), n3 instanceof g3 ? (this.provider = n3.provider, this.wallet = n3) : (this.provider = n3, this.wallet = null), Object.keys(this.interface.functions).forEach((a6) => {
      let r2 = this.interface.getFunction(a6);
      Object.defineProperty(this.functions, r2.name, { value: this.buildFunction(r2), writable: false });
    });
  }
  buildFunction(t5) {
    return (...e2) => new S8(this, t5, e2);
  }
  multiCall(t5) {
    return new v8(this, t5);
  }
};
var T0 = new Logger("0.21.0");
var A5 = class {
  constructor(t5, e2, n3 = null) {
    this.bytecode = t5, e2 instanceof E ? this.interface = e2 : this.interface = new E(e2), n3 instanceof g3 ? (this.provider = n3.provider, this.wallet = n3) : n3 instanceof v3 ? (this.provider = n3, this.wallet = null) : (this.provider = null, this.wallet = null);
  }
  connect(t5) {
    return new A5(this.bytecode, this.interface, t5);
  }
  async deployContract(t5) {
    var l7;
    if (!this.wallet)
      return T0.throwArgumentError("Cannot deploy without wallet", "wallet", this.wallet);
    let e2 = (l7 = t5 == null ? void 0 : t5.storageSlots) == null ? void 0 : l7.map(({ key: c9, value: u4 }) => ({ key: w7(c9), value: w7(u4) })).sort(({ key: c9 }, { key: u4 }) => c9.localeCompare(u4)), n3 = { salt: u(32), ...t5, storageSlots: e2 || [] }, a6 = n3.stateRoot || x5(n3.storageSlots), r2 = q4(this.bytecode, n3.salt, a6), s4 = new V2({ gasPrice: 0, gasLimit: lt, bytecodeWitnessIndex: 0, witnesses: [this.bytecode], ...n3 });
    return s4.addContractCreatedOutput(r2, a6), await this.wallet.fund(s4), await (await this.wallet.sendTransaction(s4)).wait(), new C5(r2, this.interface, this.wallet);
  }
};

// node_modules/@fuel-ts/predicate/dist/index.mjs
var t4 = class extends c4 {
  constructor(r2, e2) {
    super();
    this.bytes = arrayify(r2), this.address = t2.fromB256(D6.getContractRoot(this.bytes)), this.types = e2;
  }
};
export {
  V as ABI,
  Pt as ASSET_ID_LEN,
  O2 as AbiCoder,
  r as AbstractAddress,
  a as AbstractContract,
  c4 as AbstractPredicate,
  s2 as AbstractScript,
  e as AbstractWallet,
  t2 as Address,
  P as ArrayCoder,
  D as B256Coder,
  n as BN,
  Vt as BYTES_32,
  g3 as BaseWalletLocked,
  T4 as BaseWalletUnlocked,
  b as BooleanCoder,
  a3 as ByteArrayCoder,
  J as ByteCoder,
  Dt as CONTRACT_ID_LEN,
  Bt as CONTRACT_MAX_SIZE,
  E2 as ChangeOutputCollisionError,
  i2 as Coder,
  dt as CoinStatus,
  C5 as Contract,
  A5 as ContractFactory,
  D6 as ContractUtils,
  V2 as CreateTransactionRequest,
  f as DECIMAL_UNITS,
  B as DEFAULT_MIN_PRECISION,
  c as DEFAULT_PRECISION,
  b2 as EmptyRoot,
  A as EnumCoder,
  Vt2 as FAILED_TRANSFER_TO_ADDRESS_SIGNAL,
  o as FUEL_BECH32_HRP_PREFIX,
  q as Fragment,
  x as FunctionFragment,
  f5 as FunctionInvocationResult,
  S8 as FunctionInvocationScope,
  Mt as GAS_PER_BYTE,
  St as GAS_PRICE_FACTOR,
  M2 as InputCoder,
  F2 as InputCoinCoder,
  j2 as InputContractCoder,
  W2 as InputMessageCoder,
  We as InputType,
  E as Interface,
  b8 as InvocationResult,
  lt as MAX_GAS_PER_TX,
  Rt as MAX_INPUTS,
  Wt as MAX_PREDICATE_DATA_LENGTH,
  _t as MAX_PREDICATE_LENGTH,
  kt as MAX_SCRIPT_DATA_LENGTH,
  Pt2 as MAX_SCRIPT_LENGTH,
  Et as MAX_STATIC_CONTRACTS,
  Dt2 as MAX_WITNESSES,
  v8 as MultiCallInvocationScope,
  c2 as NativeAssetId,
  rt as NoWitnessAtIndexError,
  st as NoWitnessByOwnerError,
  S2 as NumberCoder,
  v as OPTION_CODER_TYPE,
  J2 as OutputChangeCoder,
  P2 as OutputCoder,
  $3 as OutputCoinCoder,
  q2 as OutputContractCoder,
  Q3 as OutputContractCreatedCoder,
  z2 as OutputMessageCoder,
  Ve as OutputType,
  K2 as OutputVariableCoder,
  t4 as Predicate,
  v3 as Provider,
  ee as ReceiptCallCoder,
  fe2 as ReceiptCoder,
  se as ReceiptLogCoder,
  ce2 as ReceiptLogDataCoder,
  ie2 as ReceiptMessageOutCoder,
  oe as ReceiptPanicCoder,
  te as ReceiptReturnCoder,
  ne as ReceiptReturnDataCoder,
  re2 as ReceiptRevertCoder,
  ue2 as ReceiptScriptResultCoder,
  pe2 as ReceiptTransferCoder,
  de as ReceiptTransferOutCoder,
  Ge as ReceiptType,
  C2 as ScriptTransactionRequest,
  H2 as StorageSlotCoder,
  B2 as StringCoder,
  k as StructCoder,
  Lt as TRANSACTION_SCRIPT_FIXED_SIZE,
  F3 as TestUtils,
  Le as TransactionCoder,
  ye as TransactionCreateCoder,
  H3 as TransactionResponse,
  we as TransactionScriptCoder,
  Ye as TransactionType,
  C as TupleCoder,
  l2 as TxPointerCoder,
  l as U64Coder,
  S4 as UtxoIdCoder,
  ie as VEC_CODER_TYPE,
  Jt as VM_TX_MEMORY,
  T as VecCoder,
  ue as WORD_SIZE,
  y2 as Wallet,
  w5 as WalletLocked,
  a5 as WalletUnlocked,
  _2 as WitnessCoder,
  t as ZeroBytes32,
  D2 as addressify,
  Y2 as arraifyFromUint8Array,
  M as arrayRegEx,
  arrayify,
  i as bn,
  tt as calculatePriceWithFactor,
  M3 as calculateTransactionFee,
  O4 as coinQuantityfy,
  concat,
  X as decrypt,
  Q2 as encrypt,
  Y as enumRegEx,
  j as filterEmptyParams,
  $ as format,
  O as formatUnits,
  c5 as fromBech32,
  pe as genericRegEx,
  h2 as getBytesFromBech32,
  Se as getGasUsedFromReceipts,
  a2 as getRandomB256,
  Rt2 as getReceiptsWithMissingData,
  le as getVectorAdjustments,
  me as hasOptionTypes,
  hexConcat,
  hexDataLength,
  hexDataSlice,
  hexStripZeros,
  hexValue,
  hexZeroPad,
  hexlify,
  xt as inputify,
  n2 as isBech32,
  isBytes,
  isBytesLike,
  _3 as isCoin,
  G as isFlatJsonAbi,
  isHexString,
  ze as isMessage,
  It as isRawCoin,
  Ke as isRawMessage,
  fe as isReferenceType,
  joinSignature,
  m as keyFromPassword,
  L as max,
  H as multiply,
  u2 as normalizeBech32,
  qt as outputify,
  u as randomBytes,
  _t2 as returnZeroScript,
  Gt as sleep,
  splitSignature,
  Z as stringRegEx,
  stripZeros,
  W as structRegEx,
  m2 as toB256,
  i4 as toBech32,
  R as toBytes,
  I as toFixed,
  S as toHex,
  F as toNumber,
  A3 as transactionRequestify,
  ce as tupleRegEx,
  Ca as withdrawScript,
  zeroPad
};
//# sourceMappingURL=fuels.js.map
