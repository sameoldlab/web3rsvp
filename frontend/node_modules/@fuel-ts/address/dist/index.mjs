import{arrayify as b,hexlify as d}from"@ethersproject/bytes";import{Logger as y}from"@ethersproject/logger";import{AbstractContract as l,AbstractWallet as x}from"@fuel-ts/interfaces";import{randomBytes as w}from"@fuel-ts/keystore";import{bech32m as s}from"bech32";var S=new y(process.env.BUILD_VERSION||"~"),o="fuel";function c(r){return s.decode(r)}function i(r){return s.encode(o,s.toWords(b(d(r))))}function n(r){return typeof r=="string"&&r.indexOf(o+1)===0&&c(r).prefix===o}function h(r){return new Uint8Array(s.fromWords(c(r).words))}function m(r){return n(r)||S.throwArgumentError("Invalid Bech32 Address","address",r),d(h(r))}function u(r){let{words:A}=c(r);return s.encode(o,A)}var D=r=>r instanceof x?r.address:r instanceof l?r.id:r,a=()=>d(w(32));import{Logger as I}from"@ethersproject/logger";import{sha256 as E}from"@ethersproject/sha2";import{AbstractAddress as L}from"@fuel-ts/interfaces";var p=new I(process.env.BUILD_VERSION||"~"),t=class extends L{constructor(e){super();p.checkNew(new.target,t),this.bech32Address=u(e),n(this.bech32Address)||p.throwArgumentError("Invalid Bech32 Address","address",e)}toAddress(){return this.bech32Address}toB256(){return m(this.bech32Address)}toBytes(){return h(this.bech32Address)}toHexString(){return this.toB256()}toString(){return this.bech32Address}toJSON(){return this.toString()}valueOf(){return this.toString()}equals(e){return this.bech32Address===e.bech32Address}static fromPublicKey(e){let g=E(e);return new t(i(g))}static fromB256(e){return new t(i(e))}static fromRandom(){return this.fromB256(a())}static fromString(e){return n(e)?new t(e):this.fromB256(e)}static fromAddressOrString(e){return typeof e=="string"?this.fromString(e):e}};export{t as Address,o as FUEL_BECH32_HRP_PREFIX,D as addressify,c as fromBech32,h as getBytesFromBech32,a as getRandomB256,n as isBech32,u as normalizeBech32,m as toB256,i as toBech32};
//# sourceMappingURL=index.mjs.map