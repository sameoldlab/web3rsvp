{"version":3,"sources":["../src/utils.ts","../src/address.ts"],"sourcesContent":["import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport { Logger } from '@ethersproject/logger';\nimport { AbstractContract, AbstractWallet } from '@fuel-ts/interfaces';\nimport type {\n  Bech32Address,\n  B256Address,\n  AddressLike,\n  ContractIdLike,\n  AbstractAddress,\n} from '@fuel-ts/interfaces';\nimport { randomBytes } from '@fuel-ts/keystore';\nimport type { Decoded } from 'bech32';\nimport { bech32m } from 'bech32';\n\nconst logger = new Logger(process.env.BUILD_VERSION || '~');\n\n// Fuel Network HRP (human-readable part) for bech32 encoding\nexport const FUEL_BECH32_HRP_PREFIX = 'fuel';\n\n/**\n * Decodes a Bech32 address string into Decoded\n */\nexport function fromBech32(address: Bech32Address): Decoded {\n  return bech32m.decode(address);\n}\n\n/**\n * Converts a B256 address string into Bech32\n */\nexport function toBech32(address: B256Address): Bech32Address {\n  return bech32m.encode(\n    FUEL_BECH32_HRP_PREFIX,\n    bech32m.toWords(arrayify(hexlify(address)))\n  ) as Bech32Address;\n}\n\n/**\n * Determines if a given string is Bech32 format\n */\nexport function isBech32(address: BytesLike): boolean {\n  return (\n    typeof address === 'string' &&\n    address.indexOf(FUEL_BECH32_HRP_PREFIX + 1) === 0 &&\n    fromBech32(address as Bech32Address).prefix === FUEL_BECH32_HRP_PREFIX\n  );\n}\n\n/**\n * Takes a Bech32 address and returns the byte data\n */\nexport function getBytesFromBech32(address: Bech32Address): Uint8Array {\n  return new Uint8Array(bech32m.fromWords(fromBech32(address).words));\n}\n\n/**\n * Converts a Bech32 address string into B256\n */\nexport function toB256(address: Bech32Address): B256Address {\n  if (!isBech32(address)) {\n    logger.throwArgumentError('Invalid Bech32 Address', 'address', address);\n  }\n\n  return hexlify(getBytesFromBech32(address));\n}\n\n/**\n * Takes a Bech32 address and returns a normalized (i.e. lower case) representation of it.\n *\n * The input is validated along the way, which makes this significantly safer than\n * using `address.toLowerCase()`.\n */\nexport function normalizeBech32(address: Bech32Address): Bech32Address {\n  const { words } = fromBech32(address);\n  return bech32m.encode(FUEL_BECH32_HRP_PREFIX, words) as Bech32Address;\n}\n\nexport const addressify = (addressLike: AddressLike | ContractIdLike): AbstractAddress => {\n  if (addressLike instanceof AbstractWallet) {\n    return addressLike.address;\n  }\n\n  if (addressLike instanceof AbstractContract) {\n    return addressLike.id;\n  }\n\n  return addressLike;\n};\n\nexport const getRandomB256 = () => hexlify(randomBytes(32));\n","import { Logger } from '@ethersproject/logger';\nimport { sha256 } from '@ethersproject/sha2';\nimport { AbstractAddress } from '@fuel-ts/interfaces';\nimport type { Bech32Address, B256Address } from '@fuel-ts/interfaces';\n\nimport {\n  normalizeBech32,\n  isBech32,\n  toB256,\n  getBytesFromBech32,\n  toBech32,\n  getRandomB256,\n} from './utils';\n\nconst logger = new Logger(process.env.BUILD_VERSION || '~');\n\nexport default class Address extends AbstractAddress {\n  readonly bech32Address: Bech32Address;\n\n  constructor(address: Bech32Address) {\n    super();\n    logger.checkNew(new.target, Address);\n    this.bech32Address = normalizeBech32(address);\n\n    if (!isBech32(this.bech32Address)) {\n      logger.throwArgumentError('Invalid Bech32 Address', 'address', address);\n    }\n  }\n\n  /**\n   * @returns This address as a Bech32m string\n   */\n  toAddress(): Bech32Address {\n    return this.bech32Address;\n  }\n\n  /**\n   * @returns This address as 256 bit hash string\n   */\n  toB256(): B256Address {\n    return toB256(this.bech32Address);\n  }\n\n  /**\n   * @returns Returns this address as a byte array\n   */\n  toBytes(): Uint8Array {\n    return getBytesFromBech32(this.bech32Address);\n  }\n\n  /**\n   * @returns This address as hexed 256 bit hash string\n   */\n  toHexString(): B256Address {\n    return this.toB256();\n  }\n\n  /**\n   * Prints this Address value\n   * @returns a string address in Bech32m Format\n   */\n  toString(): string {\n    return this.bech32Address;\n  }\n\n  /**\n   * Parses this Address value\n   * @returns a string address in Bech32m Format\n   */\n  toJSON(): string {\n    return this.toString();\n  }\n\n  /**\n   * Returns the value of this Address value\n   * @returns a string address in Bech32m Format\n   */\n  valueOf(): string {\n    return this.toString();\n  }\n\n  /**\n   * Compare this Address value to another for direct equality\n   * @param other - the other address to compare against\n   * @returns true if addresses are equal\n   */\n  equals(other: Address): boolean {\n    return this.bech32Address === other.bech32Address;\n  }\n\n  /**\n   * Takes a Public Key, hashes it, and creates an Address\n   * @param publicKey - the wallets public key\n   * @returns a new `Address` instance\n   */\n  static fromPublicKey(publicKey: string): Address {\n    const b256Address = sha256(publicKey);\n    return new Address(toBech32(b256Address));\n  }\n\n  /**\n   * Takes a B256Address and creates an Address\n   * @param b256Address - the b256 hash\n   * @returns a new `Address` instance\n   */\n  static fromB256(b256Address: string): Address {\n    return new Address(toBech32(b256Address));\n  }\n\n  /**\n   * Creates a random address within an Address\n   * @returns a new `Address` instance\n   */\n  static fromRandom(): Address {\n    return this.fromB256(getRandomB256());\n  }\n\n  /**\n   * Takes an ambiguous string and attempts to create an Address\n   * @returns a new `Address` instance\n   */\n  static fromString(address: string): Address {\n    return isBech32(address) ? new Address(address as Bech32Address) : this.fromB256(address);\n  }\n\n  /**\n   * Takes an ambiguous string or address and creates an address\n   * @returns a new `Address` instance\n   */\n  static fromAddressOrString(address: string | AbstractAddress): AbstractAddress {\n    return typeof address === 'string' ? this.fromString(address) : address;\n  }\n}\n"],"mappings":"AACA,OAAS,YAAAA,EAAU,WAAAC,MAAe,uBAClC,OAAS,UAAAC,MAAc,wBACvB,OAAS,oBAAAC,EAAkB,kBAAAC,MAAsB,sBAQjD,OAAS,eAAAC,MAAmB,oBAE5B,OAAS,WAAAC,MAAe,SAExB,IAAMC,EAAS,IAAIL,EAAO,QAAQ,IAAI,eAAiB,GAAG,EAG7CM,EAAyB,OAK/B,SAASC,EAAWC,EAAiC,CAC1D,OAAOJ,EAAQ,OAAOI,CAAO,CAC/B,CAKO,SAASC,EAASD,EAAqC,CAC5D,OAAOJ,EAAQ,OACbE,EACAF,EAAQ,QAAQN,EAASC,EAAQS,CAAO,CAAC,CAAC,CAC5C,CACF,CAKO,SAASE,EAASF,EAA6B,CACpD,OACE,OAAOA,GAAY,UACnBA,EAAQ,QAAQF,EAAyB,CAAC,IAAM,GAChDC,EAAWC,CAAwB,EAAE,SAAWF,CAEpD,CAKO,SAASK,EAAmBH,EAAoC,CACrE,OAAO,IAAI,WAAWJ,EAAQ,UAAUG,EAAWC,CAAO,EAAE,KAAK,CAAC,CACpE,CAKO,SAASI,EAAOJ,EAAqC,CAC1D,OAAKE,EAASF,CAAO,GACnBH,EAAO,mBAAmB,yBAA0B,UAAWG,CAAO,EAGjET,EAAQY,EAAmBH,CAAO,CAAC,CAC5C,CAQO,SAASK,EAAgBL,EAAuC,CACrE,GAAM,CAAE,MAAAM,CAAM,EAAIP,EAAWC,CAAO,EACpC,OAAOJ,EAAQ,OAAOE,EAAwBQ,CAAK,CACrD,CAEO,IAAMC,EAAcC,GACrBA,aAAuBd,EAClBc,EAAY,QAGjBA,aAAuBf,EAClBe,EAAY,GAGdA,EAGIC,EAAgB,IAAMlB,EAAQI,EAAY,EAAE,CAAC,ECzF1D,OAAS,UAAAe,MAAc,wBACvB,OAAS,UAAAC,MAAc,sBACvB,OAAS,mBAAAC,MAAuB,sBAYhC,IAAMC,EAAS,IAAIC,EAAO,QAAQ,IAAI,eAAiB,GAAG,EAErCC,EAArB,cAAqCC,CAAgB,CAGnD,YAAYC,EAAwB,CAClC,MAAM,EACNJ,EAAO,SAAS,WAAYE,CAAO,EACnC,KAAK,cAAgBG,EAAgBD,CAAO,EAEvCE,EAAS,KAAK,aAAa,GAC9BN,EAAO,mBAAmB,yBAA0B,UAAWI,CAAO,CAE1E,CAKA,WAA2B,CACzB,OAAO,KAAK,aACd,CAKA,QAAsB,CACpB,OAAOG,EAAO,KAAK,aAAa,CAClC,CAKA,SAAsB,CACpB,OAAOC,EAAmB,KAAK,aAAa,CAC9C,CAKA,aAA2B,CACzB,OAAO,KAAK,OAAO,CACrB,CAMA,UAAmB,CACjB,OAAO,KAAK,aACd,CAMA,QAAiB,CACf,OAAO,KAAK,SAAS,CACvB,CAMA,SAAkB,CAChB,OAAO,KAAK,SAAS,CACvB,CAOA,OAAOC,EAAyB,CAC9B,OAAO,KAAK,gBAAkBA,EAAM,aACtC,CAOA,OAAO,cAAcC,EAA4B,CAC/C,IAAMC,EAAcC,EAAOF,CAAS,EACpC,OAAO,IAAIR,EAAQW,EAASF,CAAW,CAAC,CAC1C,CAOA,OAAO,SAASA,EAA8B,CAC5C,OAAO,IAAIT,EAAQW,EAASF,CAAW,CAAC,CAC1C,CAMA,OAAO,YAAsB,CAC3B,OAAO,KAAK,SAASG,EAAc,CAAC,CACtC,CAMA,OAAO,WAAWV,EAA0B,CAC1C,OAAOE,EAASF,CAAO,EAAI,IAAIF,EAAQE,CAAwB,EAAI,KAAK,SAASA,CAAO,CAC1F,CAMA,OAAO,oBAAoBA,EAAoD,CAC7E,OAAO,OAAOA,GAAY,SAAW,KAAK,WAAWA,CAAO,EAAIA,CAClE,CACF","names":["arrayify","hexlify","Logger","AbstractContract","AbstractWallet","randomBytes","bech32m","logger","FUEL_BECH32_HRP_PREFIX","fromBech32","address","toBech32","isBech32","getBytesFromBech32","toB256","normalizeBech32","words","addressify","addressLike","getRandomB256","Logger","sha256","AbstractAddress","logger","Logger","Address","AbstractAddress","address","normalizeBech32","isBech32","toB256","getBytesFromBech32","other","publicKey","b256Address","sha256","toBech32","getRandomB256"]}