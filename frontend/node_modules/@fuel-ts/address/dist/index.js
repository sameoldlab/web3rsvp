"use strict";var u=Object.defineProperty;var E=Object.getOwnPropertyDescriptor;var L=Object.getOwnPropertyNames;var R=Object.prototype.hasOwnProperty;var O=(r,t)=>{for(var e in t)u(r,e,{get:t[e],enumerable:!0})},U=(r,t,e,h)=>{if(t&&typeof t=="object"||typeof t=="function")for(let d of L(t))!R.call(r,d)&&d!==e&&u(r,d,{get:()=>t[d],enumerable:!(h=E(t,d))||h.enumerable});return r};var v=r=>U(u({},"__esModule",{value:!0}),r);var F={};O(F,{Address:()=>s,FUEL_BECH32_HRP_PREFIX:()=>c,addressify:()=>D,fromBech32:()=>f,getBytesFromBech32:()=>m,getRandomB256:()=>g,isBech32:()=>i,normalizeBech32:()=>p,toB256:()=>a,toBech32:()=>B});module.exports=v(F);var n=require("@ethersproject/bytes"),y=require("@ethersproject/logger"),A=require("@fuel-ts/interfaces"),l=require("@fuel-ts/keystore"),o=require("bech32"),C=new y.Logger(process.env.BUILD_VERSION||"~"),c="fuel";function f(r){return o.bech32m.decode(r)}function B(r){return o.bech32m.encode(c,o.bech32m.toWords((0,n.arrayify)((0,n.hexlify)(r))))}function i(r){return typeof r=="string"&&r.indexOf(c+1)===0&&f(r).prefix===c}function m(r){return new Uint8Array(o.bech32m.fromWords(f(r).words))}function a(r){return i(r)||C.throwArgumentError("Invalid Bech32 Address","address",r),(0,n.hexlify)(m(r))}function p(r){let{words:t}=f(r);return o.bech32m.encode(c,t)}var D=r=>r instanceof A.AbstractWallet?r.address:r instanceof A.AbstractContract?r.id:r,g=()=>(0,n.hexlify)((0,l.randomBytes)(32));var w=require("@ethersproject/logger"),S=require("@ethersproject/sha2"),I=require("@fuel-ts/interfaces");var x=new w.Logger(process.env.BUILD_VERSION||"~"),s=class extends I.AbstractAddress{constructor(e){super();x.checkNew(new.target,s),this.bech32Address=p(e),i(this.bech32Address)||x.throwArgumentError("Invalid Bech32 Address","address",e)}toAddress(){return this.bech32Address}toB256(){return a(this.bech32Address)}toBytes(){return m(this.bech32Address)}toHexString(){return this.toB256()}toString(){return this.bech32Address}toJSON(){return this.toString()}valueOf(){return this.toString()}equals(e){return this.bech32Address===e.bech32Address}static fromPublicKey(e){let h=(0,S.sha256)(e);return new s(B(h))}static fromB256(e){return new s(B(e))}static fromRandom(){return this.fromB256(g())}static fromString(e){return i(e)?new s(e):this.fromB256(e)}static fromAddressOrString(e){return typeof e=="string"?this.fromString(e):e}};0&&(module.exports={Address,FUEL_BECH32_HRP_PREFIX,addressify,fromBech32,getBytesFromBech32,getRandomB256,isBech32,normalizeBech32,toB256,toBech32});
//# sourceMappingURL=index.js.map