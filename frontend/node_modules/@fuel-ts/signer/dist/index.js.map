{"version":3,"sources":["../src/index.ts","../src/signer.ts"],"sourcesContent":["export { default as Signer } from './signer';\nexport * from './signer';\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { concat, hexlify, arrayify } from '@ethersproject/bytes';\nimport { Address } from '@fuel-ts/address';\nimport { hash } from '@fuel-ts/hasher';\nimport { randomBytes } from '@fuel-ts/keystore';\nimport { toBytes } from '@fuel-ts/math';\nimport { ec as EC } from 'elliptic';\n\n/**\n * Return elliptic instance with curve secp256k1\n */\nexport function getCurve() {\n  return new EC('secp256k1');\n}\n\nclass Signer {\n  readonly address: Address;\n\n  readonly publicKey: string;\n\n  readonly compressedPublicKey: string;\n\n  readonly privateKey: string;\n\n  /**\n   * Create a Signer instance from a given private key\n   *\n   * @param privateKey - The private key to use for signing\n   * @returns A new Signer instance\n   */\n  constructor(privateKey: BytesLike) {\n    // A lot of common tools do not prefix private keys with a 0x\n    if (typeof privateKey === 'string') {\n      if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {\n        // eslint-disable-next-line no-param-reassign\n        privateKey = `0x${privateKey}`;\n      }\n    }\n\n    // Convert to byte array, normalize private key input allowing it to be BytesLike\n    // like remove 0x prefix and accept array of bytes\n    const privateKeyBytes = arrayify(privateKey);\n    const keyPair = getCurve().keyFromPrivate(privateKeyBytes, 'hex');\n\n    // Slice(1) removes the encoding scheme from the public key\n    this.compressedPublicKey = hexlify(keyPair.getPublic(true, 'array'));\n    this.publicKey = hexlify(keyPair.getPublic(false, 'array').slice(1));\n    this.privateKey = hexlify(privateKeyBytes);\n    this.address = Address.fromPublicKey(this.publicKey);\n  }\n\n  /**\n   * Sign data using the Signer instance\n   *\n   * Signature is a 64 byte array of the concatenated r and s values with the compressed recoveryParam byte. [Read more](FuelLabs/fuel-specs/specs/protocol/cryptographic_primitives.md#public-key-cryptography)\n   *\n   * @param data - The data to be sign\n   * @returns hashed signature\n   */\n  sign(data: BytesLike) {\n    const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey), 'hex');\n    const signature = keyPair.sign(arrayify(data), {\n      canonical: true,\n    });\n    const r = toBytes(signature.r, 32);\n    const s = toBytes(signature.s, 32);\n\n    // add recoveryParam to first s byte\n    s[0] |= (signature.recoveryParam || 0) << 7;\n\n    return hexlify(concat([r, s]));\n  }\n\n  /**\n   * Add point on the current elliptic curve\n   *\n   * @param point - Point to add on the curve\n   * @returns compressed point on the curve\n   */\n  addPoint(point: BytesLike) {\n    const p0 = getCurve().keyFromPublic(arrayify(this.compressedPublicKey));\n    const p1 = getCurve().keyFromPublic(arrayify(point));\n    const result = p0.getPublic().add(p1.getPublic());\n\n    return hexlify(result.encode('array', true));\n  }\n\n  /**\n   * Recover the public key from a signature performed with [`sign`](#sign).\n   *\n   * @param data - Data\n   * @param signature - hashed signature\n   * @returns public key from signature from the\n   */\n  static recoverPublicKey(data: BytesLike, signature: BytesLike) {\n    const signedMessageBytes = arrayify(signature);\n    const r = signedMessageBytes.slice(0, 32);\n    const s = signedMessageBytes.slice(32, 64);\n    const recoveryParam = (s[0] & 0x80) >> 7;\n\n    // remove recoveryParam from s first byte\n    s[0] &= 0x7f;\n\n    const publicKey = getCurve()\n      .recoverPubKey(arrayify(data), { r, s }, recoveryParam)\n      .encode('array', false)\n      .slice(1);\n\n    return publicKey;\n  }\n\n  /**\n   * Recover the address from a signature performed with [`sign`](#sign).\n   *\n   * @param data - Data\n   * @param signature - Signature\n   * @returns Address from signature\n   */\n  static recoverAddress(data: BytesLike, signature: BytesLike): Address {\n    return Address.fromPublicKey(Signer.recoverPublicKey(data, signature));\n  }\n\n  /**\n   * Generate a random privateKey\n   *\n   * @param entropy - Adds extra entropy to generate the privateKey\n   * @returns random 32-byte hashed\n   */\n  static generatePrivateKey(entropy?: BytesLike) {\n    return entropy ? hash(concat([randomBytes(32), arrayify(entropy)])) : randomBytes(32);\n  }\n\n  /**\n   * Extended publicKey from a compact publicKey\n   *\n   * @param publicKey - Compact publicKey\n   * @returns extended publicKey\n   */\n  static extendPublicKey(publicKey: BytesLike) {\n    const keyPair = getCurve().keyFromPublic(arrayify(publicKey));\n    return hexlify(keyPair.getPublic(false, 'array').slice(1));\n  }\n}\n\nexport default Signer;\n"],"mappings":"yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,YAAAE,EAAA,aAAAC,IAAA,eAAAC,EAAAJ,GCCA,IAAAK,EAA0C,gCAC1CC,EAAwB,4BACxBC,EAAqB,2BACrBC,EAA4B,6BAC5BC,EAAwB,yBACxBC,EAAyB,oBAKlB,SAASC,GAAW,CACzB,OAAO,IAAI,EAAAC,GAAG,WAAW,CAC3B,CAEA,IAAMC,EAAN,KAAa,CAeX,YAAYC,EAAuB,CAE7B,OAAOA,GAAe,UACpBA,EAAW,MAAM,cAAc,GAAKA,EAAW,SAAW,KAE5DA,EAAa,KAAKA,KAMtB,IAAMC,KAAkB,YAASD,CAAU,EACrCE,EAAUL,EAAS,EAAE,eAAeI,EAAiB,KAAK,EAGhE,KAAK,uBAAsB,WAAQC,EAAQ,UAAU,GAAM,OAAO,CAAC,EACnE,KAAK,aAAY,WAAQA,EAAQ,UAAU,GAAO,OAAO,EAAE,MAAM,CAAC,CAAC,EACnE,KAAK,cAAa,WAAQD,CAAe,EACzC,KAAK,QAAU,UAAQ,cAAc,KAAK,SAAS,CACrD,CAUA,KAAKE,EAAiB,CAEpB,IAAMC,EADUP,EAAS,EAAE,kBAAe,YAAS,KAAK,UAAU,EAAG,KAAK,EAChD,QAAK,YAASM,CAAI,EAAG,CAC7C,UAAW,EACb,CAAC,EACKE,KAAI,WAAQD,EAAU,EAAG,EAAE,EAC3BE,KAAI,WAAQF,EAAU,EAAG,EAAE,EAGjC,OAAAE,EAAE,KAAOF,EAAU,eAAiB,IAAM,KAEnC,cAAQ,UAAO,CAACC,EAAGC,CAAC,CAAC,CAAC,CAC/B,CAQA,SAASC,EAAkB,CACzB,IAAMC,EAAKX,EAAS,EAAE,iBAAc,YAAS,KAAK,mBAAmB,CAAC,EAChEY,EAAKZ,EAAS,EAAE,iBAAc,YAASU,CAAK,CAAC,EAC7CG,EAASF,EAAG,UAAU,EAAE,IAAIC,EAAG,UAAU,CAAC,EAEhD,SAAO,WAAQC,EAAO,OAAO,QAAS,EAAI,CAAC,CAC7C,CASA,OAAO,iBAAiBP,EAAiBC,EAAsB,CAC7D,IAAMO,KAAqB,YAASP,CAAS,EACvCC,EAAIM,EAAmB,MAAM,EAAG,EAAE,EAClCL,EAAIK,EAAmB,MAAM,GAAI,EAAE,EACnCC,GAAiBN,EAAE,GAAK,MAAS,EAGvC,OAAAA,EAAE,IAAM,IAEUT,EAAS,EACxB,iBAAc,YAASM,CAAI,EAAG,CAAE,EAAAE,EAAG,EAAAC,CAAE,EAAGM,CAAa,EACrD,OAAO,QAAS,EAAK,EACrB,MAAM,CAAC,CAGZ,CASA,OAAO,eAAeT,EAAiBC,EAA+B,CACpE,OAAO,UAAQ,cAAcL,EAAO,iBAAiBI,EAAMC,CAAS,CAAC,CACvE,CAQA,OAAO,mBAAmBS,EAAqB,CAC7C,OAAOA,KAAU,WAAK,UAAO,IAAC,eAAY,EAAE,KAAG,YAASA,CAAO,CAAC,CAAC,CAAC,KAAI,eAAY,EAAE,CACtF,CAQA,OAAO,gBAAgBC,EAAsB,CAC3C,IAAMZ,EAAUL,EAAS,EAAE,iBAAc,YAASiB,CAAS,CAAC,EAC5D,SAAO,WAAQZ,EAAQ,UAAU,GAAO,OAAO,EAAE,MAAM,CAAC,CAAC,CAC3D,CACF,EAEOa,EAAQhB","names":["src_exports","__export","signer_default","getCurve","__toCommonJS","import_bytes","import_address","import_hasher","import_keystore","import_math","import_elliptic","getCurve","EC","Signer","privateKey","privateKeyBytes","keyPair","data","signature","r","s","point","p0","p1","result","signedMessageBytes","recoveryParam","entropy","publicKey","signer_default"]}