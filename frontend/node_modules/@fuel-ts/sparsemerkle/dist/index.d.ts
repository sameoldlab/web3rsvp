declare class SparseCompactMerkleProof {
    SideNodes: string[];
    NonMembershipLeafData: string;
    BitMask: number[];
    NumSideNodes: number;
    SiblingData: string;
    constructor(SideNodes: string[], NonMembershipLeafData: string, Bitmask: number[], NumSideNodes: number, SiblingData: string);
}

declare class SparseMerkleProof {
    SideNodes: string[];
    NonMembershipLeafData: string;
    SiblingData: string;
    constructor(sideNodes: string[], NonMembershipLeafData: string, SiblingData: string);
}

interface MapStore {
    [key: string]: string;
}

declare class SparseMerkleTree {
    ms: MapStore;
    root: string;
    constructor();
    get(key: string): string;
    set(key: string, value: string): void;
    setRoot(root: string): void;
    sideNodesForRoot(key: string, root: string): [string[], string, string, string];
    deleteWithSideNodes(key: string, sideNodes: string[], oldLeafHash: string, oldLeafData: string): string;
    updateWithSideNodes(key: string, value: string, sideNodes: string[], oldLeafHash: string, oldLeafData: string): string;
    update(key: string, value: string): void;
    delete(key: string): void;
    prove(key: string): SparseMerkleProof;
    proveCompacted(key: string): SparseCompactMerkleProof;
}

export { SparseMerkleTree as default };
