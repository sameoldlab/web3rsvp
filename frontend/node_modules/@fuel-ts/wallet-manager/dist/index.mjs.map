{"version":3,"sources":["../src/wallet-manager.ts","../src/storages/memory-storage.ts","../src/vaults/mnemonic-vault.ts","../src/vaults/privatekey-vault.ts"],"sourcesContent":["import type { AbstractAddress } from '@fuel-ts/interfaces';\nimport type { Keystore } from '@fuel-ts/keystore';\nimport { encrypt, decrypt } from '@fuel-ts/keystore';\nimport type { WalletUnlocked } from '@fuel-ts/wallet';\nimport { EventEmitter } from 'events';\n\nimport MemoryStorage from './storages/memory-storage';\nimport type {\n  StorageAbstract,\n  Account,\n  VaultConfig,\n  VaultsState,\n  WalletManagerOptions,\n  WalletManagerState,\n  Vault,\n} from './types';\nimport { MnemonicVault } from './vaults/mnemonic-vault';\nimport { PrivateKeyVault } from './vaults/privatekey-vault';\n\nconst ERROR_MESSAGES = {\n  invalid_vault_type: 'Invalid VaultType',\n  address_not_found: 'Address not found',\n  vault_not_found: 'Vault not found',\n  wallet_not_unlocked: 'Wallet is locked',\n  passphrase_not_match: \"Passphrase didn't match\",\n};\n\n/**\n * Generic assert function to avoid undesirable errors\n */\nfunction assert(condition: unknown, message: string): asserts condition {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\n/**\n * WalletManager is a upper package to manage multiple vaults like mnemonic and privateKeys.\n *\n * - VaultTypes can be add to `WalletManager.Vaults` enabling to add custom Vault types.\n * - Storage can be instantiate when initializing enabling custom storage types.\n */\nexport class WalletManager extends EventEmitter {\n  /**\n   * Vaults\n   *\n   * Vaults are responsible to store secret keys and return an `Wallet` instance,\n   * to interact with the network.\n   *\n   * Each vault has access to its own state\n   *\n   */\n  static Vaults = [MnemonicVault, PrivateKeyVault];\n  /**\n   * Storage\n   *\n   * Persistent encrypted data. `The default storage works only on memory`.\n   */\n  readonly storage: StorageAbstract = new MemoryStorage();\n  /* Key name passed to the storage */\n  readonly STORAGE_KEY: string = 'WalletManager';\n\n  // `This variables are only accessible from inside the class`\n  #vaults: VaultsState = [];\n  #passphrase = '';\n  #isLocked: boolean = true;\n\n  constructor(options?: WalletManagerOptions) {\n    super();\n    this.storage = options?.storage || this.storage;\n  }\n\n  get isLocked(): boolean {\n    return this.#isLocked;\n  }\n\n  /**\n   * Return the vault serialized object containing all the privateKeys,\n   * the format of the return depends on the Vault type.\n   */\n  exportVault<T extends Vault>(vaultId: number): ReturnType<T['serialize']> {\n    assert(!this.#isLocked, ERROR_MESSAGES.wallet_not_unlocked);\n    const vaultState = this.#vaults.find((_, idx) => idx === vaultId);\n    assert(vaultState, ERROR_MESSAGES.vault_not_found);\n    return vaultState.vault.serialize() as ReturnType<T['serialize']>;\n  }\n\n  /**\n   * List all vaults on the Wallet Manager, this function not return secret's\n   */\n  getVaults(): Array<{ title?: string; type: string; vaultId: number }> {\n    return this.#vaults.map((v, idx) => ({\n      title: v.title,\n      type: v.type,\n      vaultId: idx,\n    }));\n  }\n\n  /**\n   * List all accounts on the Wallet Manager not vault information is revealed\n   */\n  getAccounts(): Array<Account> {\n    // Return all accounts from vaults\n    return this.#vaults.flatMap<Account>((vaultState, vaultId) =>\n      vaultState.vault.getAccounts().map((account) => ({ ...account, vaultId }))\n    );\n  }\n\n  /**\n   * Create a Wallet instance for the specific account\n   */\n  getWallet(address: AbstractAddress): WalletUnlocked {\n    const vaultState = this.#vaults.find((vs) =>\n      vs.vault.getAccounts().find((a) => a.address.equals(address))\n    );\n    assert(vaultState, ERROR_MESSAGES.address_not_found);\n\n    return vaultState.vault.getWallet(address);\n  }\n\n  /**\n   * Export specific account privateKey\n   */\n  exportPrivateKey(address: AbstractAddress) {\n    assert(!this.#isLocked, ERROR_MESSAGES.wallet_not_unlocked);\n    const vaultState = this.#vaults.find((vs) =>\n      vs.vault.getAccounts().find((a) => a.address.equals(address))\n    );\n    assert(vaultState, ERROR_MESSAGES.address_not_found);\n\n    return vaultState.vault.exportAccount(address);\n  }\n\n  /**\n   * Add account to a selected vault or on the first vault as default.\n   * If not vaults are adds it will return error\n   */\n  async addAccount(options?: { vaultId: number }) {\n    // Make sure before add new vault state is fully loaded\n    await this.loadState();\n    // Get vault instance\n    const vaultState = this.#vaults[options?.vaultId || 0];\n    await assert(vaultState, ERROR_MESSAGES.vault_not_found);\n    // Add account on vault\n    vaultState.vault.addAccount();\n    // Save the accounts state\n    await this.saveState();\n  }\n\n  /**\n   * Remove vault by index, by remove the vault you also remove all accounts\n   * created by the vault.\n   */\n  async removeVault(index: number) {\n    this.#vaults.splice(index, 1);\n    await this.saveState();\n  }\n\n  /**\n   * Add Vault, the `vaultConfig.type` will look for the Vaults supported if\n   * didn't found it will throw.\n   */\n  async addVault(vaultConfig: VaultConfig) {\n    // Make sure before add new vault state is fully loaded\n    await this.loadState();\n    // Check if vault is supported\n    const Vault = this.getVaultClass(vaultConfig.type);\n    // create Vault instance\n    const vault = new Vault(vaultConfig);\n    // Push vaults to state\n    this.#vaults = this.#vaults.concat({\n      title: vaultConfig.title,\n      type: vaultConfig.type,\n      vault,\n    });\n    // Persist data on storage\n    await this.saveState();\n  }\n\n  /**\n   * Lock wallet. It removes passphrase from class instance, encrypt and hide all address and\n   * secrets.\n   */\n  async lock() {\n    this.#isLocked = true;\n    // Clean state vaults from state\n    this.#vaults = [];\n    // Clean password from state\n    this.#passphrase = '';\n    // Emit event that wallet is locked\n    this.emit('lock');\n  }\n\n  /**\n   * Unlock wallet. It sets passphrase on WalletManger instance load all address from configured vaults.\n   * Vaults with secrets are not unlocked or instantiated on this moment.\n   */\n  async unlock(passphrase: string) {\n    // Set password on state\n    this.#passphrase = passphrase;\n    // Set locked state to true\n    this.#isLocked = false;\n    // Load state\n    await this.loadState();\n    // Emit event that wallet is unlocked\n    this.emit('unlock');\n  }\n\n  /**\n   * Update WalletManager encryption passphrase\n   */\n  async updatePassphrase(oldpass: string, newpass: string) {\n    const isLocked = this.#isLocked;\n    // Unlock wallet to decrypt data\n    await this.unlock(oldpass);\n    // Set new password on state\n    this.#passphrase = newpass;\n    // Persist data on storage\n    await this.saveState();\n    // Load state with new password\n    await this.loadState();\n    // If wallet was locked, lock the wallet again\n    if (isLocked) {\n      await this.lock();\n    }\n  }\n\n  /**\n   * Retrieve and decrypt WalletManager state from storage\n   */\n  async loadState() {\n    await assert(!this.#isLocked, ERROR_MESSAGES.wallet_not_unlocked);\n\n    const data = await this.storage.getItem<string>(this.STORAGE_KEY);\n    if (data) {\n      const state = await decrypt<WalletManagerState>(this.#passphrase, <Keystore>JSON.parse(data));\n      this.#vaults = this.#deserializeVaults(state.vaults);\n    }\n  }\n\n  /**\n   * Store encrypted WalletManager state on storage\n   */\n  private async saveState() {\n    await assert(!this.#isLocked, ERROR_MESSAGES.wallet_not_unlocked);\n\n    const encryptedData = await encrypt(this.#passphrase, {\n      vaults: this.#serializeVaults(this.#vaults),\n    });\n    this.storage.setItem(this.STORAGE_KEY, JSON.stringify(encryptedData));\n    this.emit('update');\n  }\n\n  /**\n   * Serialize all vaults to store\n   *\n   * `This is only accessible from inside the class`\n   */\n  #serializeVaults(vaults: VaultsState) {\n    return vaults.map(({ title, type, vault }) => ({\n      title,\n      type,\n      data: vault.serialize(),\n    }));\n  }\n\n  /**\n   * Deserialize all vaults to state\n   *\n   * `This is only accessible from inside the class`\n   */\n  #deserializeVaults(vaults: VaultsState) {\n    return vaults.map(({ title, type, data: vaultConfig }) => {\n      const VaultClass = this.getVaultClass(type);\n      return {\n        title,\n        type,\n        vault: new VaultClass(<VaultConfig>vaultConfig),\n      };\n    });\n  }\n\n  /**\n   * Return a instantiable Class reference from `WalletManager.Vaults` supported list.\n   */\n  private getVaultClass(type: string) {\n    const VaultClass = WalletManager.Vaults.find((v) => v.type === type);\n\n    assert(VaultClass, ERROR_MESSAGES.invalid_vault_type);\n\n    return VaultClass;\n  }\n}\n","class MemoryStorage {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  storage = new Map<string, any>();\n\n  async getItem(key: string) {\n    return this.storage.get(key);\n  }\n\n  async setItem<T>(key: string, value: T) {\n    return this.storage.set(key, value);\n  }\n\n  async removeItem(key: string) {\n    this.storage.delete(key);\n  }\n\n  async clear() {\n    return this.storage.clear();\n  }\n}\n\nexport default MemoryStorage;\n","import type { AbstractAddress } from '@fuel-ts/interfaces';\nimport { Mnemonic } from '@fuel-ts/mnemonic';\nimport type { WalletUnlocked } from '@fuel-ts/wallet';\nimport { Wallet } from '@fuel-ts/wallet';\n\nimport type { Vault } from '../types';\n\ninterface MnemonicVaultOptions {\n  secret?: string;\n  rootPath?: string;\n  numberOfAccounts?: number | null;\n}\n\nexport class MnemonicVault implements Vault<MnemonicVaultOptions> {\n  static readonly type = 'mnemonic';\n  readonly #secret: string;\n\n  pathKey = '{}';\n  rootPath: string = `m/44'/1179993420'/${this.pathKey}'/0/0`;\n  numberOfAccounts: number = 0;\n\n  constructor(options: MnemonicVaultOptions) {\n    this.#secret = options.secret || Mnemonic.generate();\n    this.rootPath = options.rootPath || this.rootPath;\n    // On creating the vault also adds one account\n    this.numberOfAccounts = options.numberOfAccounts || 1;\n  }\n\n  getDerivePath(index: number) {\n    if (this.rootPath.includes(this.pathKey)) {\n      return this.rootPath.replace(this.pathKey, String(index));\n    }\n    return `${this.rootPath}/${index}`;\n  }\n\n  serialize(): MnemonicVaultOptions {\n    return {\n      secret: this.#secret,\n      rootPath: this.rootPath,\n      numberOfAccounts: this.numberOfAccounts,\n    };\n  }\n\n  getAccounts() {\n    const accounts = [];\n    let numberOfAccounts = 0;\n\n    // Create all accounts to current vault\n    do {\n      const wallet = Wallet.fromMnemonic(this.#secret, this.getDerivePath(numberOfAccounts));\n      accounts.push({\n        publicKey: wallet.publicKey,\n        address: wallet.address,\n      });\n      numberOfAccounts += 1;\n    } while (numberOfAccounts < this.numberOfAccounts);\n\n    return accounts;\n  }\n\n  addAccount() {\n    this.numberOfAccounts += 1;\n    const wallet = Wallet.fromMnemonic(this.#secret, this.getDerivePath(this.numberOfAccounts));\n\n    return {\n      publicKey: wallet.publicKey,\n      address: wallet.address,\n    };\n  }\n\n  exportAccount(address: AbstractAddress): string {\n    let numberOfAccounts = 0;\n\n    // Look for the account that has the same address\n    do {\n      const wallet = Wallet.fromMnemonic(this.#secret, this.getDerivePath(numberOfAccounts));\n      if (wallet.address.equals(address)) {\n        return wallet.privateKey;\n      }\n      numberOfAccounts += 1;\n    } while (numberOfAccounts < this.numberOfAccounts);\n\n    throw new Error('Account not found');\n  }\n\n  getWallet(address: AbstractAddress): WalletUnlocked {\n    const privateKey = this.exportAccount(address);\n    return Wallet.fromPrivateKey(privateKey);\n  }\n}\n","import type { AbstractAddress } from '@fuel-ts/interfaces';\nimport type { WalletUnlocked } from '@fuel-ts/wallet';\nimport { Wallet } from '@fuel-ts/wallet';\n\nimport type { Account, Vault } from '../types';\n\ninterface PkVaultOptions {\n  secret?: string;\n  accounts?: Array<string>;\n}\n\nexport class PrivateKeyVault implements Vault<PkVaultOptions> {\n  static readonly type = 'privateKey';\n\n  #privateKeys: Array<string> = [];\n\n  /**\n   * If privateKey vault is initialized with a secretKey, it creates\n   * one account with the fallowing secret\n   */\n  constructor(options: PkVaultOptions) {\n    if (options.secret) {\n      this.#privateKeys = [options.secret];\n    } else {\n      this.#privateKeys = options.accounts || [Wallet.generate().privateKey];\n    }\n  }\n\n  serialize(): PkVaultOptions {\n    return {\n      accounts: this.#privateKeys,\n    };\n  }\n\n  getPublicAccount(privateKey: string) {\n    const wallet = Wallet.fromPrivateKey(privateKey);\n    return {\n      address: wallet.address,\n      publicKey: wallet.publicKey,\n    };\n  }\n\n  getAccounts(): Account[] {\n    return this.#privateKeys.map(this.getPublicAccount);\n  }\n\n  addAccount() {\n    const wallet = Wallet.generate();\n\n    this.#privateKeys.push(wallet.privateKey);\n\n    return this.getPublicAccount(wallet.privateKey);\n  }\n\n  exportAccount(address: AbstractAddress): string {\n    const privateKey = this.#privateKeys.find((pk) =>\n      Wallet.fromPrivateKey(pk).address.equals(address)\n    );\n\n    if (!privateKey) {\n      throw new Error('Address not found');\n    }\n\n    return privateKey;\n  }\n\n  getWallet(address: AbstractAddress): WalletUnlocked {\n    const privateKey = this.exportAccount(address);\n    return Wallet.fromPrivateKey(privateKey);\n  }\n}\n"],"mappings":"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","names":["encrypt","decrypt","EventEmitter","MemoryStorage","key","value","memory_storage_default","Mnemonic","Wallet","_secret","MnemonicVault","options","__privateAdd","__privateSet","Mnemonic","index","__privateGet","accounts","numberOfAccounts","wallet","Wallet","address","privateKey","Wallet","_privateKeys","PrivateKeyVault","options","__privateAdd","__privateSet","Wallet","__privateGet","privateKey","wallet","address","pk","ERROR_MESSAGES","assert","condition","message","_vaults","_passphrase","_isLocked","_serializeVaults","serializeVaults_fn","_deserializeVaults","deserializeVaults_fn","_WalletManager","EventEmitter","options","__privateAdd","memory_storage_default","__privateGet","vaultId","vaultState","_","idx","v","account","address","vs","a","index","vaultConfig","Vault","vault","__privateSet","passphrase","oldpass","newpass","isLocked","data","state","decrypt","__privateMethod","encryptedData","encrypt","type","VaultClass","WalletManager","vaults","title","MnemonicVault","PrivateKeyVault"]}