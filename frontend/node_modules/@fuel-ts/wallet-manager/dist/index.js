"use strict";var K=Object.defineProperty;var R=Object.getOwnPropertyDescriptor;var U=Object.getOwnPropertyNames;var C=Object.prototype.hasOwnProperty;var D=(a,e)=>{for(var t in e)K(a,t,{get:e[t],enumerable:!0})},q=(a,e,t,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of U(e))!C.call(a,n)&&n!==t&&K(a,n,{get:()=>e[n],enumerable:!(s=R(e,n))||s.enumerable});return a};var G=a=>q(K({},"__esModule",{value:!0}),a);var O=(a,e,t)=>{if(!e.has(a))throw TypeError("Cannot "+t)};var r=(a,e,t)=>(O(a,e,"read from private field"),t?t.call(a):e.get(a)),c=(a,e,t)=>{if(e.has(a))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(a):e.set(a,t)},o=(a,e,t,s)=>(O(a,e,"write to private field"),s?s.call(a,t):e.set(a,t),t);var k=(a,e,t)=>(O(a,e,"access private method"),t);var L={};D(L,{WalletManager:()=>b});module.exports=G(L);var S=require("@fuel-ts/keystore"),M=require("events");var P=class{constructor(){this.storage=new Map}async getItem(e){return this.storage.get(e)}async setItem(e,t){return this.storage.set(e,t)}async removeItem(e){this.storage.delete(e)}async clear(){return this.storage.clear()}},E=P;var x=require("@fuel-ts/mnemonic"),g=require("@fuel-ts/wallet");var m,A=class{constructor(e){c(this,m,void 0);this.pathKey="{}";this.rootPath=`m/44'/1179993420'/${this.pathKey}'/0/0`;this.numberOfAccounts=0;o(this,m,e.secret||x.Mnemonic.generate()),this.rootPath=e.rootPath||this.rootPath,this.numberOfAccounts=e.numberOfAccounts||1}getDerivePath(e){return this.rootPath.includes(this.pathKey)?this.rootPath.replace(this.pathKey,String(e)):`${this.rootPath}/${e}`}serialize(){return{secret:r(this,m),rootPath:this.rootPath,numberOfAccounts:this.numberOfAccounts}}getAccounts(){let e=[],t=0;do{let s=g.Wallet.fromMnemonic(r(this,m),this.getDerivePath(t));e.push({publicKey:s.publicKey,address:s.address}),t+=1}while(t<this.numberOfAccounts);return e}addAccount(){this.numberOfAccounts+=1;let e=g.Wallet.fromMnemonic(r(this,m),this.getDerivePath(this.numberOfAccounts));return{publicKey:e.publicKey,address:e.address}}exportAccount(e){let t=0;do{let s=g.Wallet.fromMnemonic(r(this,m),this.getDerivePath(t));if(s.address.equals(e))return s.privateKey;t+=1}while(t<this.numberOfAccounts);throw new Error("Account not found")}getWallet(e){let t=this.exportAccount(e);return g.Wallet.fromPrivateKey(t)}};m=new WeakMap,A.type="mnemonic";var y=require("@fuel-ts/wallet");var d,v=class{constructor(e){c(this,d,[]);e.secret?o(this,d,[e.secret]):o(this,d,e.accounts||[y.Wallet.generate().privateKey])}serialize(){return{accounts:r(this,d)}}getPublicAccount(e){let t=y.Wallet.fromPrivateKey(e);return{address:t.address,publicKey:t.publicKey}}getAccounts(){return r(this,d).map(this.getPublicAccount)}addAccount(){let e=y.Wallet.generate();return r(this,d).push(e.privateKey),this.getPublicAccount(e.privateKey)}exportAccount(e){let t=r(this,d).find(s=>y.Wallet.fromPrivateKey(s).address.equals(e));if(!t)throw new Error("Address not found");return t}getWallet(e){let t=this.exportAccount(e);return y.Wallet.fromPrivateKey(t)}};d=new WeakMap,v.type="privateKey";var h={invalid_vault_type:"Invalid VaultType",address_not_found:"Address not found",vault_not_found:"Vault not found",wallet_not_unlocked:"Wallet is locked",passphrase_not_match:"Passphrase didn't match"};function p(a,e){if(!a)throw new Error(e)}var i,f,l,V,T,_,I,W=class extends M.EventEmitter{constructor(t){super();c(this,V);c(this,_);this.storage=new E;this.STORAGE_KEY="WalletManager";c(this,i,[]);c(this,f,"");c(this,l,!0);this.storage=(t==null?void 0:t.storage)||this.storage}get isLocked(){return r(this,l)}exportVault(t){p(!r(this,l),h.wallet_not_unlocked);let s=r(this,i).find((n,u)=>u===t);return p(s,h.vault_not_found),s.vault.serialize()}getVaults(){return r(this,i).map((t,s)=>({title:t.title,type:t.type,vaultId:s}))}getAccounts(){return r(this,i).flatMap((t,s)=>t.vault.getAccounts().map(n=>({...n,vaultId:s})))}getWallet(t){let s=r(this,i).find(n=>n.vault.getAccounts().find(u=>u.address.equals(t)));return p(s,h.address_not_found),s.vault.getWallet(t)}exportPrivateKey(t){p(!r(this,l),h.wallet_not_unlocked);let s=r(this,i).find(n=>n.vault.getAccounts().find(u=>u.address.equals(t)));return p(s,h.address_not_found),s.vault.exportAccount(t)}async addAccount(t){await this.loadState();let s=r(this,i)[(t==null?void 0:t.vaultId)||0];await p(s,h.vault_not_found),s.vault.addAccount(),await this.saveState()}async removeVault(t){r(this,i).splice(t,1),await this.saveState()}async addVault(t){await this.loadState();let s=this.getVaultClass(t.type),n=new s(t);o(this,i,r(this,i).concat({title:t.title,type:t.type,vault:n})),await this.saveState()}async lock(){o(this,l,!0),o(this,i,[]),o(this,f,""),this.emit("lock")}async unlock(t){o(this,f,t),o(this,l,!1),await this.loadState(),this.emit("unlock")}async updatePassphrase(t,s){let n=r(this,l);await this.unlock(t),o(this,f,s),await this.saveState(),await this.loadState(),n&&await this.lock()}async loadState(){await p(!r(this,l),h.wallet_not_unlocked);let t=await this.storage.getItem(this.STORAGE_KEY);if(t){let s=await(0,S.decrypt)(r(this,f),JSON.parse(t));o(this,i,k(this,_,I).call(this,s.vaults))}}async saveState(){await p(!r(this,l),h.wallet_not_unlocked);let t=await(0,S.encrypt)(r(this,f),{vaults:k(this,V,T).call(this,r(this,i))});this.storage.setItem(this.STORAGE_KEY,JSON.stringify(t)),this.emit("update")}getVaultClass(t){let s=W.Vaults.find(n=>n.type===t);return p(s,h.invalid_vault_type),s}},b=W;i=new WeakMap,f=new WeakMap,l=new WeakMap,V=new WeakSet,T=function(t){return t.map(({title:s,type:n,vault:u})=>({title:s,type:n,data:u.serialize()}))},_=new WeakSet,I=function(t){return t.map(({title:s,type:n,data:u})=>{let z=this.getVaultClass(n);return{title:s,type:n,vault:new z(u)}})},b.Vaults=[A,v];0&&(module.exports={WalletManager});
//# sourceMappingURL=index.js.map