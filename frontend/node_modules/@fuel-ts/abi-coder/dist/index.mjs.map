{"version":3,"sources":["../src/coders/abstract-coder.ts","../src/coders/array.ts","../src/coders/b256.ts","../src/coders/boolean.ts","../src/coders/byte.ts","../src/coders/enum.ts","../src/coders/u64.ts","../src/coders/number.ts","../src/coders/string.ts","../src/coders/struct.ts","../src/coders/option.ts","../src/coders/tuple.ts","../src/coders/vec.ts","../src/constants.ts","../src/utilities.ts","../src/fragments/fragment.ts","../src/fragments/param-type.ts","../src/fragments/function-fragment.ts","../src/interface.ts","../src/abi-coder.ts","../src/json-abi.ts"],"sourcesContent":["import type { BytesLike } from '@ethersproject/bytes';\nimport { Logger } from '@ethersproject/logger';\nimport type { BN } from '@fuel-ts/math';\n\nconst logger = new Logger(process.env.BUILD_VERSION || '~');\n\ntype Primitive = string | number | boolean;\n\n/**\n * The type of value you can provide to `Coder.encode`\n */\nexport type InputValue =\n  | Primitive\n  | BN\n  | BytesLike\n  | InputValue[]\n  | { [key: string]: InputValue }\n  | Record<string, Primitive | BytesLike>;\n\n/**\n * The type of value you can get from `Coder.decode`\n */\nexport type DecodedValue =\n  | Primitive\n  | DecodedValue[]\n  | { [key: string]: DecodedValue }\n  | Record<string, Primitive>;\n\nexport type TypesOfCoder<TCoder> = TCoder extends Coder<infer TInput, infer TDecoded>\n  ? { Input: TInput; Decoded: TDecoded }\n  : never;\n\nexport default abstract class Coder<TInput = unknown, TDecoded = unknown> {\n  readonly name: string;\n  readonly type: string;\n  readonly encodedLength: number;\n  offset?: number;\n\n  constructor(name: string, type: string, encodedLength: number) {\n    this.name = name;\n    this.type = type;\n    this.encodedLength = encodedLength;\n  }\n\n  throwError(message: string, value: unknown): never {\n    logger.throwArgumentError(message, this.name, value);\n    // `logger.throwArgumentError` throws, but TS doesn't know it\n    // so we throw here to make sure our `never` works\n    throw new Error('unreachable');\n  }\n\n  setOffset(offset: number): void {\n    this.offset = offset;\n  }\n\n  abstract encode(value: TInput, length?: number): Uint8Array;\n\n  abstract decode(data: Uint8Array, offset: number, length?: number): [TDecoded, number];\n}\n","import { concat } from '@ethersproject/bytes';\n\nimport type { TypesOfCoder } from './abstract-coder';\nimport Coder from './abstract-coder';\n\ntype InputValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Input']>;\ntype DecodedValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Decoded']>;\n\nexport default class ArrayCoder<TCoder extends Coder> extends Coder<\n  InputValueOf<TCoder>,\n  DecodedValueOf<TCoder>\n> {\n  coder: TCoder;\n  length: number;\n\n  constructor(coder: TCoder, length: number) {\n    super('array', `[${coder.type}; ${length}]`, length * coder.encodedLength);\n    this.coder = coder;\n    this.length = length;\n  }\n\n  encode(value: InputValueOf<TCoder>): Uint8Array {\n    if (!Array.isArray(value)) {\n      this.throwError('expected array value', value);\n    }\n\n    if (this.length !== value.length) {\n      this.throwError('Types/values length mismatch', value);\n    }\n\n    return concat(Array.from(value).map((v) => this.coder.encode(v)));\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoder>, number] {\n    let newOffset = offset;\n    const decodedValue = Array(this.length)\n      .fill(0)\n      .map(() => {\n        let decoded;\n        [decoded, newOffset] = this.coder.decode(data, newOffset);\n        return decoded;\n      });\n\n    return [decodedValue as DecodedValueOf<TCoder>, newOffset];\n  }\n}\n","import { arrayify } from '@ethersproject/bytes';\nimport { bn, toHex } from '@fuel-ts/math';\n\nimport Coder from './abstract-coder';\n\nexport default class B256Coder extends Coder<string, string> {\n  constructor() {\n    super('b256', 'b256', 32);\n  }\n\n  encode(value: string): Uint8Array {\n    let encodedValue;\n    try {\n      encodedValue = arrayify(value);\n    } catch (error) {\n      this.throwError(`Invalid ${this.type}`, value);\n    }\n    if (encodedValue.length !== 32) {\n      this.throwError(`Invalid ${this.type}`, value);\n    }\n    return encodedValue;\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    let bytes = data.slice(offset, offset + 32);\n    const decoded = bn(bytes);\n    if (decoded.isZero()) {\n      bytes = new Uint8Array(32);\n    }\n    if (bytes.length !== 32) {\n      this.throwError('Invalid size for b256', bytes);\n    }\n    return [toHex(bytes, 32), offset + 32];\n  }\n}\n","import { bn, toBytes } from '@fuel-ts/math';\n\nimport Coder from './abstract-coder';\n\nexport default class BooleanCoder extends Coder<boolean, boolean> {\n  constructor() {\n    super('boolean', 'boolean', 8);\n  }\n\n  encode(value: boolean): Uint8Array {\n    let bytes;\n\n    try {\n      bytes = toBytes(value ? 1 : 0);\n    } catch (error) {\n      this.throwError('Invalid bool', value);\n    }\n    if (bytes.length > 1) {\n      this.throwError('Invalid bool', value);\n    }\n\n    return toBytes(bytes, 8);\n  }\n\n  decode(data: Uint8Array, offset: number): [boolean, number] {\n    const bytes = bn(data.slice(offset, offset + 8));\n    if (bytes.isZero()) {\n      return [false, offset + 8];\n    }\n    if (!bytes.eq(bn(1))) {\n      this.throwError('Invalid boolean value', bytes);\n    }\n    return [true, offset + 8];\n  }\n}\n","import { bn, toBytes } from '@fuel-ts/math';\n\nimport Coder from './abstract-coder';\n\nexport default class ByteCoder extends Coder<number, number> {\n  constructor() {\n    super('byte', 'byte', 8);\n  }\n\n  encode(value: number): Uint8Array {\n    let bytes;\n\n    try {\n      bytes = toBytes(value, 1);\n    } catch (error) {\n      this.throwError('Invalid Byte', value);\n    }\n\n    return toBytes(bytes, 8);\n  }\n\n  decode(data: Uint8Array, offset: number): [number, number] {\n    const bytes = data.slice(offset, offset + 8);\n    const value = bn(bytes);\n    if (value.gt(bn(255))) {\n      this.throwError('Invalid Byte', value);\n    }\n    const byte = Number(value);\n    return [byte, offset + 8];\n  }\n}\n","import { concat } from '@ethersproject/bytes';\nimport { toNumber } from '@fuel-ts/math';\nimport type { RequireExactlyOne } from 'type-fest';\n\nimport type { TypesOfCoder } from './abstract-coder';\nimport Coder from './abstract-coder';\nimport U64Coder from './u64';\n\nexport type InputValueOf<TCoders extends Record<string, Coder>> = RequireExactlyOne<{\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n}>;\nexport type DecodedValueOf<TCoders extends Record<string, Coder>> = RequireExactlyOne<{\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n}>;\n\nexport default class EnumCoder<TCoders extends Record<string, Coder>> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  name: string;\n  coders: TCoders;\n  #caseIndexCoder: U64Coder;\n  #encodedValueSize: number;\n\n  constructor(name: string, coders: TCoders) {\n    const caseIndexCoder = new U64Coder();\n    const encodedValueSize = Object.values(coders).reduce(\n      (max, coder) => Math.max(max, coder.encodedLength),\n      0\n    );\n    super('enum', `enum ${name}`, caseIndexCoder.encodedLength + encodedValueSize);\n    this.name = name;\n    this.coders = coders;\n    this.#caseIndexCoder = caseIndexCoder;\n    this.#encodedValueSize = encodedValueSize;\n  }\n\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    const [caseKey, ...empty] = Object.keys(value);\n    if (!caseKey) {\n      throw new Error('A field for the case must be provided');\n    }\n    if (empty.length !== 0) {\n      throw new Error('Only one field must be provided');\n    }\n    const valueCoder = this.coders[caseKey];\n    const caseIndex = Object.keys(this.coders).indexOf(caseKey);\n    const encodedValue = valueCoder.encode(value[caseKey]);\n\n    const padding = new Uint8Array(this.#encodedValueSize - valueCoder.encodedLength);\n    return concat([this.#caseIndexCoder.encode(caseIndex), padding, encodedValue]);\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    let newOffset = offset;\n\n    let decoded;\n    [decoded, newOffset] = new U64Coder().decode(data, newOffset);\n    const caseIndex = toNumber(decoded);\n    const caseKey = Object.keys(this.coders)[caseIndex];\n    if (!caseKey) {\n      throw new Error(`Invalid caseIndex \"${caseIndex}\". Valid cases: ${Object.keys(this.coders)}`);\n    }\n    const valueCoder = this.coders[caseKey];\n    const padding = this.#encodedValueSize - valueCoder.encodedLength;\n    newOffset += padding;\n    [decoded, newOffset] = valueCoder.decode(data, newOffset);\n\n    return [{ [caseKey]: decoded } as DecodedValueOf<TCoders>, newOffset];\n  }\n}\n","import type { BN, BNInput } from '@fuel-ts/math';\nimport { bn, toBytes } from '@fuel-ts/math';\n\nimport Coder from './abstract-coder';\n\nexport default class U64Coder extends Coder<BNInput, BN> {\n  constructor() {\n    super('u64', 'u64', 8);\n  }\n\n  encode(value: BNInput): Uint8Array {\n    let bytes;\n\n    try {\n      bytes = toBytes(value, 8);\n    } catch (error) {\n      this.throwError(`Invalid ${this.type}`, value);\n    }\n\n    return bytes;\n  }\n\n  decode(data: Uint8Array, offset: number): [BN, number] {\n    let bytes = data.slice(offset, offset + 8);\n    bytes = bytes.slice(0, 8);\n\n    return [bn(bytes), offset + 8];\n  }\n}\n","import { toNumber, toBytes } from '@fuel-ts/math';\n\nimport Coder from './abstract-coder';\n\ntype NumberCoderType = 'u8' | 'u16' | 'u32';\n\nexport default class NumberCoder extends Coder<number, number> {\n  // This is to align the bits to the total bytes\n  // See https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/abi.md#unsigned-integers\n  length: number;\n  baseType: NumberCoderType;\n\n  constructor(baseType: NumberCoderType) {\n    super('number', baseType, 8);\n    this.baseType = baseType;\n    switch (baseType) {\n      case 'u8':\n        this.length = 1;\n        break;\n      case 'u16':\n        this.length = 2;\n        break;\n      case 'u32':\n      default:\n        this.length = 4;\n        break;\n    }\n  }\n\n  encode(value: number | string): Uint8Array {\n    let bytes;\n\n    try {\n      bytes = toBytes(value);\n    } catch (error) {\n      this.throwError(`Invalid ${this.baseType}`, value);\n    }\n\n    if (bytes.length > this.length) {\n      this.throwError(`Invalid ${this.baseType}. Too many bytes.`, value);\n    }\n\n    return toBytes(bytes, 8);\n  }\n\n  decode(data: Uint8Array, offset: number): [number, number] {\n    let bytes = data.slice(offset, offset + 8);\n    bytes = bytes.slice(8 - this.length, 8);\n\n    return [toNumber(bytes), offset + 8];\n  }\n}\n","import { concat } from '@ethersproject/bytes';\nimport { toUtf8Bytes, toUtf8String } from '@ethersproject/strings';\n\nimport Coder from './abstract-coder';\n\nexport default class StringCoder<TLength extends number = number> extends Coder<string, string> {\n  length: TLength;\n  #paddingLength: number;\n\n  constructor(length: TLength) {\n    let paddingLength = (8 - length) % 8;\n    paddingLength = paddingLength < 0 ? paddingLength + 8 : paddingLength;\n    super('string', `str[${length}]`, length + paddingLength);\n    this.length = length;\n    this.#paddingLength = paddingLength;\n  }\n\n  encode(value: string): Uint8Array {\n    const encoded = toUtf8Bytes(value.slice(0, this.length));\n    const padding = new Uint8Array(this.#paddingLength);\n    return concat([encoded, padding]);\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    const bytes = data.slice(offset, offset + this.length);\n    const value = toUtf8String(bytes);\n\n    const padding = this.#paddingLength;\n    return [value, offset + this.length + padding];\n  }\n}\n","import { concat } from '@ethersproject/bytes';\n\nimport type { TypesOfCoder } from './abstract-coder';\nimport Coder from './abstract-coder';\nimport OptionCoder from './option';\n\ntype InputValueOf<TCoders extends Record<string, Coder>> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n};\ntype DecodedValueOf<TCoders extends Record<string, Coder>> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n};\n\nexport default class StructCoder<TCoders extends Record<string, Coder>> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  name: string;\n  coders: TCoders;\n\n  constructor(name: string, coders: TCoders) {\n    const encodedLength = Object.values(coders).reduce(\n      (acc, coder) => acc + coder.encodedLength,\n      0\n    );\n    super('struct', `struct ${name}`, encodedLength);\n    this.name = name;\n    this.coders = coders;\n  }\n\n  encode(value: InputValueOf<TCoders>) {\n    const encodedFields = Object.keys(this.coders).map((fieldName) => {\n      const fieldCoder = this.coders[fieldName];\n      const fieldValue = value[fieldName];\n\n      if (!(fieldCoder instanceof OptionCoder) && fieldValue == null) {\n        this.throwError(`Invalid ${this.type}. Field \"${fieldName}\" not present.`, value);\n      }\n      const encoded = fieldCoder.encode(fieldValue);\n      return encoded;\n    });\n    return concat(encodedFields);\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    let newOffset = offset;\n    const decodedValue = Object.keys(this.coders).reduce((obj, fieldName) => {\n      const fieldCoder = this.coders[fieldName];\n      let decoded;\n      [decoded, newOffset] = fieldCoder.decode(data, newOffset);\n      // eslint-disable-next-line no-param-reassign\n      obj[fieldName as keyof DecodedValueOf<TCoders>] = decoded;\n      return obj;\n    }, {} as DecodedValueOf<TCoders>);\n\n    return [decodedValue, newOffset];\n  }\n}\n","import type Coder from './abstract-coder';\nimport type { InputValueOf, DecodedValueOf } from './enum';\nimport EnumCoder from './enum';\n\ntype Option<T> = T | undefined;\ntype SwayOption<T> = { None: [] } | { Some: T };\n\nexport default class OptionCoder<TCoders extends Record<string, Coder>> extends EnumCoder<TCoders> {\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    const result = super.encode(this.toSwayOption(value) as unknown as InputValueOf<TCoders>);\n    return result;\n  }\n\n  toSwayOption(input: InputValueOf<TCoders>): SwayOption<unknown> {\n    if (input !== undefined) {\n      return { Some: input };\n    }\n\n    return { None: [] };\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    const [decoded, newOffset] = super.decode(data, offset);\n    return [this.toOption(decoded) as DecodedValueOf<TCoders>, newOffset];\n  }\n\n  toOption(output?: DecodedValueOf<TCoders>): Option<unknown> {\n    if (output && 'Some' in output) {\n      return output.Some;\n    }\n\n    return undefined;\n  }\n}\n","import { concat } from '@ethersproject/bytes';\n\nimport type { TypesOfCoder } from './abstract-coder';\nimport Coder from './abstract-coder';\n\ntype InputValueOf<TCoders extends Coder[]> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n};\ntype DecodedValueOf<TCoders extends Coder[]> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n};\n\nexport default class TupleCoder<TCoders extends Coder[]> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  coders: TCoders;\n\n  constructor(coders: TCoders) {\n    const encodedLength = coders.reduce((acc, coder) => acc + coder.encodedLength, 0);\n    super('tuple', `(${coders.map((coder) => coder.type).join(', ')})`, encodedLength);\n    this.coders = coders;\n  }\n\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    if (this.coders.length !== value.length) {\n      this.throwError('Types/values length mismatch', { value });\n    }\n\n    return concat(this.coders.map((coder, i) => coder.encode(value[i])));\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    let newOffset = offset;\n    const decodedValue = this.coders.map((coder) => {\n      let decoded;\n      [decoded, newOffset] = coder.decode(data, newOffset);\n      return decoded;\n    });\n\n    return [decodedValue as DecodedValueOf<TCoders>, newOffset];\n  }\n}\n","import { concat } from '@ethersproject/bytes';\n\nimport { WORD_SIZE } from '../constants';\n\nimport type { TypesOfCoder } from './abstract-coder';\nimport Coder from './abstract-coder';\nimport U64Coder from './u64';\n\nconst VEC_PROPERTY_SPACE = 3; // ptr + cap + length\n\ntype InputValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Input']>;\ntype DecodedValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Decoded']>;\n\nexport default class VecCoder<TCoder extends Coder> extends Coder<\n  InputValueOf<TCoder>,\n  DecodedValueOf<TCoder>\n> {\n  coder: TCoder;\n\n  constructor(coder: TCoder) {\n    super('struct', `struct Vec`, 0);\n    this.coder = coder;\n  }\n\n  static getBaseOffset(): number {\n    return VEC_PROPERTY_SPACE * WORD_SIZE;\n  }\n\n  getEncodedVectorData(value: InputValueOf<TCoder>): Uint8Array {\n    if (!Array.isArray(value)) {\n      this.throwError('expected array value', value);\n    }\n\n    const encodedValues = Array.from(value).map((v) => this.coder.encode(v));\n    return concat(encodedValues);\n  }\n\n  encode(value: InputValueOf<TCoder>): Uint8Array {\n    if (!Array.isArray(value)) {\n      this.throwError('expected array value', value);\n    }\n\n    const parts: Uint8Array[] = [];\n    // pointer (ptr)\n    const pointer = this.offset || 0;\n    parts.push(new U64Coder().encode(pointer));\n    // capacity (cap)\n    parts.push(new U64Coder().encode(value.length));\n    // length (len)\n    parts.push(new U64Coder().encode(value.length));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoder>, number] {\n    this.throwError('unexpected Vec decode', 'not implemented');\n    return [undefined as unknown as DecodedValueOf<TCoder>, offset];\n  }\n}\n","export const OPTION_CODER_TYPE = 'enum Option';\nexport const VEC_CODER_TYPE = 'struct Vec';\nexport const stringRegEx = /str\\[(?<length>[0-9]+)\\]/;\nexport const arrayRegEx = /\\[(?<item>[\\w\\s\\\\[\\]]+);\\s*(?<length>[0-9]+)\\]/;\nexport const structRegEx = /^struct (?<name>\\w+)$/;\nexport const enumRegEx = /^enum (?<name>\\w+)$/;\nexport const tupleRegEx = /^\\((?<items>.*)\\)$/;\nexport const genericRegEx = /^generic (?<name>\\w+)$/;\n\nexport const WORD_SIZE = 8;\nexport const BYTES_32 = 32;\nexport const MAX_INPUTS = 255;\nexport const ASSET_ID_LEN = BYTES_32;\nexport const CONTRACT_ID_LEN = BYTES_32;\n\n// VM_TX_MEMORY = 10240\nexport const VM_TX_MEMORY =\n  BYTES_32 + // Tx ID\n  WORD_SIZE + // Tx size\n  // Asset ID/Balance coin input pairs\n  MAX_INPUTS * (ASSET_ID_LEN + WORD_SIZE);\n\n// TRANSACTION_SCRIPT_FIXED_SIZE = 112\nexport const TRANSACTION_SCRIPT_FIXED_SIZE =\n  WORD_SIZE + // Identifier\n  WORD_SIZE + // Gas price\n  WORD_SIZE + // Gas limit\n  WORD_SIZE + // Maturity\n  WORD_SIZE + // Script size\n  WORD_SIZE + // Script data size\n  WORD_SIZE + // Inputs size\n  WORD_SIZE + // Outputs size\n  WORD_SIZE + // Witnesses size\n  BYTES_32; // Receipts root\n","import type { InputValue } from './coders/abstract-coder';\nimport type Coder from './coders/abstract-coder';\nimport VecCoder from './coders/vec';\nimport { OPTION_CODER_TYPE } from './constants';\nimport type { ParamType } from './fragments/param-type';\n\nexport function filterEmptyParams<T>(types: T): T;\nexport function filterEmptyParams(types: ReadonlyArray<string | ParamType>) {\n  return types.filter((t) => (t as Readonly<ParamType>)?.type !== '()' && t !== '()');\n}\n\nexport function hasOptionTypes<T>(types: T): T;\nexport function hasOptionTypes(types: ReadonlyArray<string | ParamType>) {\n  return types.some((t) => (t as Readonly<ParamType>)?.type === OPTION_CODER_TYPE);\n}\n\ntype ByteInfo = { vecByteLength: number } | { byteLength: number };\nexport function getVectorAdjustments(\n  coders: Coder<unknown, unknown>[],\n  values: InputValue[],\n  offset = 0\n) {\n  const vectorData: Uint8Array[] = [];\n  const byteMap: ByteInfo[] = coders.map((encoder, i) => {\n    if (!(encoder instanceof VecCoder)) {\n      return { byteLength: encoder.encodedLength };\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const data = encoder.getEncodedVectorData(values[i] as any);\n    vectorData.push(data);\n    return { vecByteLength: data.byteLength };\n  });\n\n  const baseVectorOffset = vectorData.length * VecCoder.getBaseOffset() + offset;\n  const offsetMap = coders.map((encoder, paramIndex) => {\n    if (!(encoder instanceof VecCoder)) {\n      return 0;\n    }\n\n    return byteMap.reduce((sum, byteInfo, byteIndex) => {\n      if ('byteLength' in byteInfo) {\n        return sum + byteInfo.byteLength;\n      }\n\n      if (byteIndex === 0 && byteIndex === paramIndex) {\n        return baseVectorOffset;\n      }\n\n      if (byteIndex < paramIndex) {\n        return sum + byteInfo.vecByteLength + baseVectorOffset;\n      }\n\n      return sum;\n    }, 0);\n  });\n\n  coders.forEach((code, i) => code.setOffset(offsetMap[i]));\n  return vectorData;\n}\n","import type { ParamType } from './param-type';\n\ninterface FragmentParams {\n  readonly type: string;\n  readonly name: string;\n  readonly inputs: Array<ParamType>;\n  readonly outputs: Array<ParamType>;\n}\n\nexport abstract class Fragment {\n  readonly type: string;\n  readonly name: string;\n  readonly inputs: Array<ParamType> = [];\n  readonly outputs: Array<ParamType> = [];\n\n  constructor(params: FragmentParams) {\n    this.type = params.type;\n    this.name = params.name;\n    this.inputs = params.inputs;\n    this.outputs = params.outputs;\n  }\n\n  abstract getInputsSighash(format?: string): string;\n}\n","import { defineReadOnly } from '@ethersproject/properties';\n\nimport { arrayRegEx, enumRegEx, structRegEx, stringRegEx } from '../constants';\n\nexport interface JsonFragmentType {\n  readonly name?: string;\n  readonly type: string;\n  readonly components?: ReadonlyArray<JsonFragmentType>;\n  readonly typeArguments?: ReadonlyArray<JsonFragmentType>;\n}\n\nfunction populate(object: ParamType, params: { type?: string } & ParamTypeProps) {\n  Object.keys(params).forEach((key) => {\n    const paramTypeKey = key as keyof ParamTypeProps;\n    const value = params[paramTypeKey];\n\n    defineReadOnly(object, paramTypeKey, value);\n  });\n}\n\nexport interface ParamTypeProps {\n  // The local name of the parameter (of null if unbound)\n  readonly name?: string;\n\n  // The type of this ParamType: https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/abi.md#types\n  readonly type: string;\n\n  // Internal components for complex types (Tuples, Structs, Arrays, Enums)\n  readonly components?: Array<ParamType>;\n\n  // Internal typeArguments for complex types (Tuples, Structs, Arrays, Enums)\n  // Only used when dynamic types are declared\n  readonly typeArguments?: Array<ParamType>;\n\n  // Typeguard prop\n  readonly isParamType?: boolean;\n}\n\nexport class ParamType implements ParamTypeProps {\n  readonly name?: string;\n  readonly type!: string;\n  readonly indexed?: boolean;\n  readonly components?: Array<ParamType>;\n  readonly typeArguments?: Array<ParamType>;\n  readonly isParamType?: boolean;\n\n  constructor(params: ParamTypeProps) {\n    populate(this, params);\n\n    this.isParamType = true;\n\n    Object.freeze(this);\n  }\n\n  getSignaturePrefix(): string {\n    if (this.type) {\n      const structMatch = structRegEx.test(this.type);\n      if (structMatch) return 's';\n\n      const arrayMatch = arrayRegEx.test(this.type);\n      if (arrayMatch) return 'a';\n\n      const enumMatch = enumRegEx.test(this.type);\n      if (enumMatch) return 'e';\n    }\n\n    return '';\n  }\n\n  getSignatureContent(): string {\n    const type = this.type || '';\n\n    if (type === 'raw untyped ptr') {\n      return 'rawptr';\n    }\n\n    const arrayMatch = arrayRegEx.exec(type)?.groups;\n    if (arrayMatch) {\n      return `[${this.components ? this.components[0].getSighash() : arrayMatch.item};${\n        arrayMatch.length\n      }]`;\n    }\n\n    const strMatch = stringRegEx.exec(type)?.groups;\n    if (strMatch) {\n      return `str[${strMatch.length}]`;\n    }\n\n    if (Array.isArray(this.components)) {\n      const typeArgumentsSignature = Array.isArray(this.typeArguments)\n        ? `<${this.typeArguments.map((typeArg) => typeArg.getSighash()).join(',')}>`\n        : '';\n      const componentsSignature = `(${this.components.map((comp) => comp.getSighash()).join(',')})`;\n\n      return `${typeArgumentsSignature}${componentsSignature}`;\n    }\n\n    return type;\n  }\n\n  getSighash(): string {\n    const prefix = this.getSignaturePrefix();\n    const content = this.getSignatureContent();\n\n    return `${prefix}${content}`;\n  }\n\n  static fromObject(value: JsonFragmentType | ParamTypeProps): ParamType {\n    if (ParamType.isParamType(value)) {\n      return value;\n    }\n\n    return new ParamType({\n      name: value.name,\n      type: value.type,\n      components: value.components ? value.components.map(ParamType.fromObject) : undefined,\n      typeArguments: value.typeArguments\n        ? value.typeArguments.map(ParamType.fromObject)\n        : undefined,\n    });\n  }\n\n  static isParamType(value?: JsonFragmentType | ParamType): value is ParamType {\n    return Boolean((value as ParamTypeProps)?.isParamType);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport type { JsonAbiFragment } from '../json-abi';\n\nimport { Fragment } from './fragment';\nimport { ParamType } from './param-type';\n\nexport default class FunctionFragment extends Fragment {\n  static fromObject(value: JsonAbiFragment): FunctionFragment {\n    const { inputs = [], outputs = [] } = value;\n\n    const params = {\n      type: 'function',\n      name: value.name,\n      // TODO: Remove `as any`s when forc doesn't output nulls (https://github.com/FuelLabs/sway/issues/926)\n      inputs: (inputs as any).map(ParamType.fromObject),\n      outputs: (outputs as any).map(ParamType.fromObject),\n    };\n\n    return new FunctionFragment(params);\n  }\n\n  getInputsSighash(): string {\n    const inputsSignatures = this.inputs.map((input) => input.getSighash());\n    return `${this.name}(${inputsSignatures.join(',')})`;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, concat, hexlify } from '@ethersproject/bytes';\nimport { Logger } from '@ethersproject/logger';\nimport { sha256 } from '@ethersproject/sha2';\nimport { toUtf8Bytes } from '@ethersproject/strings';\n\nimport AbiCoder from './abi-coder';\nimport type { InputValue } from './coders/abstract-coder';\nimport BooleanCoder from './coders/boolean';\nimport type { Fragment } from './fragments/fragment';\nimport FunctionFragment from './fragments/function-fragment';\nimport type {\n  JsonAbiFragment,\n  JsonFlatAbi,\n  JsonFlatAbiFragmentType,\n  JsonAbi,\n  JsonAbiLogFragment,\n} from './json-abi';\nimport { isFlatJsonAbi, ABI, isReferenceType } from './json-abi';\nimport { filterEmptyParams } from './utilities';\n\nconst logger = new Logger(process.env.BUILD_VERSION || '~');\n\nconst coerceFragments = (value: ReadonlyArray<JsonAbiFragment>): Array<Fragment> => {\n  const fragments: Array<Fragment> = [];\n\n  value.forEach((v) => {\n    if (v.type === 'function') {\n      fragments.push(FunctionFragment.fromObject(v));\n    }\n  });\n\n  return fragments;\n};\n\nexport default class Interface {\n  readonly fragments: Array<Fragment>;\n  readonly functions: { [name: string]: FunctionFragment };\n  readonly abiCoder: AbiCoder;\n  readonly abi: ABI | null;\n  readonly types: ReadonlyArray<JsonFlatAbiFragmentType>;\n  readonly loggedTypes: ReadonlyArray<JsonAbiLogFragment>;\n\n  constructor(jsonAbi: JsonAbi | JsonFlatAbi) {\n    this.abi = isFlatJsonAbi(jsonAbi) ? new ABI(jsonAbi) : null;\n    this.fragments = coerceFragments(ABI.unflatten(jsonAbi));\n\n    this.types = this.abi ? this.abi.types : [];\n    this.loggedTypes = this.abi ? this.abi.unflattenLoggedTypes() : [];\n\n    this.abiCoder = new AbiCoder();\n    this.functions = {};\n    this.fragments.forEach((fragment) => {\n      let bucket: { [name: string]: Fragment } = {};\n      switch (fragment.type) {\n        case 'function':\n          bucket = this.functions;\n          break;\n        default:\n          return;\n      }\n      const signature = fragment.getInputsSighash();\n      if (bucket[signature]) {\n        logger.warn(`duplicate definition - ${signature}`);\n        return;\n      }\n      bucket[signature] = fragment;\n    });\n  }\n\n  static getSighash(fragment: FunctionFragment | string): Uint8Array {\n    const bytes =\n      typeof fragment === 'string'\n        ? toUtf8Bytes(fragment)\n        : toUtf8Bytes(fragment.getInputsSighash());\n\n    return concat([new Uint8Array(4), arrayify(sha256(bytes)).slice(0, 4)]);\n  }\n\n  getFunction(nameOrSignatureOrSighash: string): FunctionFragment {\n    if (this.functions[nameOrSignatureOrSighash]) {\n      return this.functions[nameOrSignatureOrSighash];\n    }\n\n    const functionFragment = Object.values(this.functions).find(\n      (fragment: Fragment) =>\n        hexlify(Interface.getSighash(fragment)) === nameOrSignatureOrSighash ||\n        fragment.name === nameOrSignatureOrSighash\n    );\n\n    if (functionFragment) {\n      return functionFragment;\n    }\n\n    return logger.throwArgumentError(\n      `function ${nameOrSignatureOrSighash} not found.`,\n      'data',\n      functionFragment\n    );\n  }\n\n  // Decode the data for a function call (e.g. tx.data)\n  decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): any {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    const bytes = arrayify(data);\n    if (hexlify(bytes.slice(0, 8)) !== hexlify(Interface.getSighash(fragment))) {\n      logger.throwArgumentError(\n        `data signature does not match function ${fragment.name}.`,\n        'data',\n        hexlify(bytes)\n      );\n    }\n\n    return this.abiCoder.decode(fragment.inputs, bytes.slice(16));\n  }\n\n  encodeFunctionData(\n    functionFragment: FunctionFragment | string,\n    values: Array<InputValue>,\n    offset = 0\n  ): Uint8Array {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    if (!fragment) {\n      throw new Error('Fragment not found');\n    }\n\n    const selector = Interface.getSighash(fragment);\n    const inputs = filterEmptyParams(fragment.inputs);\n\n    if (inputs.length === 0) {\n      return selector;\n    }\n\n    const isRef = inputs.length > 1 || isReferenceType(inputs[0].type);\n    const args = this.abiCoder.encode(inputs, values, offset);\n    return concat([selector, new BooleanCoder().encode(isRef), args]);\n  }\n\n  // Decode the result of a function call\n  decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): any {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    const bytes = arrayify(data);\n\n    return this.abiCoder.decode(fragment.outputs, bytes);\n  }\n\n  decodeLog(data: BytesLike, logId: number): any {\n    const logType = this.loggedTypes.find((type) => type.logId === logId);\n    if (!logType?.abiFragmentType) {\n      throw new Error(`Log ID - ${logId} unknown`);\n    }\n    return this.abiCoder.decode(logType.abiFragmentType, data);\n  }\n\n  encodeFunctionResult(\n    functionFragment: FunctionFragment | string,\n    values: Array<InputValue>\n  ): Uint8Array {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    if (!fragment) {\n      throw new Error('Fragment not found');\n    }\n\n    return this.abiCoder.encode(fragment.outputs, values);\n  }\n}\n","// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\nimport type { BytesLike } from '@ethersproject/bytes';\nimport { concat, arrayify } from '@ethersproject/bytes';\nimport { Logger } from '@ethersproject/logger';\n\nimport type { DecodedValue, InputValue } from './coders/abstract-coder';\nimport type Coder from './coders/abstract-coder';\nimport ArrayCoder from './coders/array';\nimport B256Coder from './coders/b256';\nimport BooleanCoder from './coders/boolean';\nimport ByteCoder from './coders/byte';\nimport EnumCoder from './coders/enum';\nimport NumberCoder from './coders/number';\nimport OptionCoder from './coders/option';\nimport StringCoder from './coders/string';\nimport StructCoder from './coders/struct';\nimport TupleCoder from './coders/tuple';\nimport U64Coder from './coders/u64';\nimport VecCoder from './coders/vec';\nimport {\n  arrayRegEx,\n  enumRegEx,\n  stringRegEx,\n  structRegEx,\n  tupleRegEx,\n  OPTION_CODER_TYPE,\n  VEC_CODER_TYPE,\n} from './constants';\nimport type { JsonAbiFragmentType } from './json-abi';\nimport { filterEmptyParams, getVectorAdjustments, hasOptionTypes } from './utilities';\n\nconst logger = new Logger(process.env.BUILD_VERSION || '~');\n\nexport default class AbiCoder {\n  constructor() {\n    logger.checkNew(new.target, AbiCoder);\n  }\n\n  getCoder(param: JsonAbiFragmentType): Coder {\n    switch (param.type) {\n      case 'u8':\n      case 'u16':\n      case 'u32':\n        return new NumberCoder(param.type);\n      case 'u64':\n      case 'raw untyped ptr':\n        return new U64Coder();\n      case 'bool':\n        return new BooleanCoder();\n      case 'byte':\n        return new ByteCoder();\n      case 'b256':\n        return new B256Coder();\n      default:\n    }\n\n    const arrayMatch = arrayRegEx.exec(param.type)?.groups;\n    if (arrayMatch) {\n      const length = parseInt(arrayMatch.length, 10);\n      const itemComponent = param.components?.[0];\n      if (!itemComponent) {\n        throw new Error('Expected array type to have an item component');\n      }\n      const itemCoder = this.getCoder(itemComponent);\n      return new ArrayCoder(itemCoder, length);\n    }\n\n    const stringMatch = stringRegEx.exec(param.type)?.groups;\n    if (stringMatch) {\n      const length = parseInt(stringMatch.length, 10);\n\n      return new StringCoder(length);\n    }\n\n    if (param.type === VEC_CODER_TYPE && Array.isArray(param.typeArguments)) {\n      const typeArgument = param.typeArguments[0];\n      if (!typeArgument) {\n        throw new Error('Expected Vec type to have a type argument');\n      }\n      const itemCoder = this.getCoder(typeArgument);\n      return new VecCoder(itemCoder);\n    }\n\n    const structMatch = structRegEx.exec(param.type)?.groups;\n    if (structMatch && Array.isArray(param.components)) {\n      const coders = param.components.reduce((obj, component) => {\n        // eslint-disable-next-line no-param-reassign\n        obj[component.name] = this.getCoder(component);\n        return obj;\n      }, {});\n      return new StructCoder(structMatch.name, coders);\n    }\n\n    const enumMatch = enumRegEx.exec(param.type)?.groups;\n    if (enumMatch && Array.isArray(param.components)) {\n      const coders = param.components.reduce((obj, component) => {\n        // eslint-disable-next-line no-param-reassign\n        obj[component.name] = this.getCoder(component);\n        return obj;\n      }, {});\n\n      const isOptionEnum = param.type === OPTION_CODER_TYPE;\n      if (isOptionEnum) {\n        return new OptionCoder(enumMatch.name, coders);\n      }\n      return new EnumCoder(enumMatch.name, coders);\n    }\n\n    const tupleMatch = tupleRegEx.exec(param.type)?.groups;\n    if (tupleMatch && Array.isArray(param.components)) {\n      const coders = param.components.map((component) => this.getCoder(component));\n      return new TupleCoder(coders);\n    }\n\n    return logger.throwArgumentError('Invalid type', 'type', param.type);\n  }\n\n  encode(types: ReadonlyArray<JsonAbiFragmentType>, values: InputValue[], offset = 0): Uint8Array {\n    const nonEmptyTypes = filterEmptyParams(types);\n    const shallowCopyValues = values.slice();\n\n    if (Array.isArray(values) && nonEmptyTypes.length !== values.length) {\n      if (!hasOptionTypes(types)) {\n        logger.throwError('Types/values length mismatch', Logger.errors.INVALID_ARGUMENT, {\n          count: { types: nonEmptyTypes.length, values: values.length },\n          value: { types, values },\n        });\n      } else {\n        shallowCopyValues.length = types.length;\n        shallowCopyValues.fill(undefined as unknown as InputValue, values.length);\n      }\n    }\n\n    const coders = nonEmptyTypes.map((type) => this.getCoder(type));\n    const vectorData = getVectorAdjustments(coders, shallowCopyValues, offset);\n\n    const coder = new TupleCoder(coders);\n    const results = coder.encode(shallowCopyValues);\n\n    return concat([results, concat(vectorData)]);\n  }\n\n  decode(types: ReadonlyArray<JsonAbiFragmentType>, data: BytesLike): DecodedValue[] | undefined {\n    const bytes = arrayify(data);\n    const nonEmptyTypes = filterEmptyParams(types);\n    const assertParamsMatch = (newOffset: number) => {\n      if (newOffset !== bytes.length) {\n        logger.throwError('Types/values length mismatch', Logger.errors.INVALID_ARGUMENT, {\n          count: { types: nonEmptyTypes.length, values: bytes.length },\n          value: { types: nonEmptyTypes, bytes },\n        });\n      }\n    };\n\n    if (types.length === 0 || nonEmptyTypes.length === 0) {\n      // The VM is current return 0x0000000000000000, but we should treat it as undefined / void\n      assertParamsMatch(bytes.length ? 8 : 0);\n      return undefined;\n    }\n\n    const coders = nonEmptyTypes.map((type) => this.getCoder(type));\n    const coder = new TupleCoder(coders);\n    const [decoded, newOffset] = coder.decode(bytes, 0);\n\n    assertParamsMatch(newOffset);\n\n    return decoded as DecodedValue[];\n  }\n}\n","/**\n * Types for Fuel JSON ABI Format as defined on:\n * https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/abi.md#json-abi-format\n */\n\nimport { genericRegEx } from './constants';\nimport type { JsonFragmentType } from './fragments/param-type';\nimport { ParamType } from './fragments/param-type';\n\nexport interface JsonAbiFragmentType {\n  readonly type: string;\n  readonly name?: string;\n  // TODO: Remove `null` when forc doesn't output nulls (https://github.com/FuelLabs/sway/issues/926)\n  readonly components?: ReadonlyArray<JsonAbiFragmentType> | null;\n  readonly typeArguments?: ReadonlyArray<JsonAbiFragmentType> | null;\n}\n\nexport interface JsonAbiFragment {\n  readonly type:\n    | 'function'\n    // We actually shouldn't accept string here, but when importing a JSON file\n    // TS types string literals as strings so we have to.\n    // TODO: Remove when TS issue is resolved: https://github.com/microsoft/TypeScript/issues/32063\n    | string;\n  readonly name: string;\n  readonly inputs?: ReadonlyArray<JsonAbiFragmentType>;\n  readonly outputs?: ReadonlyArray<JsonAbiFragmentType>;\n}\n\nexport interface JsonAbiLogFragment {\n  readonly logId: number;\n  readonly loggedType: JsonFlatAbiFragmentArgumentType;\n  readonly abiFragmentType?: ReadonlyArray<JsonAbiFragmentType>;\n}\n\nexport interface JsonFlatAbiFragmentType {\n  readonly typeId: number;\n  readonly type: string;\n  readonly name?: string;\n  readonly components?: ReadonlyArray<JsonFlatAbiFragmentArgumentType> | null;\n  readonly typeParameters?: ReadonlyArray<number> | null;\n}\n\nexport interface JsonFlatAbiFragmentLoggedType {\n  readonly logId: number;\n  readonly loggedType: JsonFlatAbiFragmentArgumentType;\n}\n\nexport interface JsonFlatAbiFragmentArgumentType {\n  readonly type: number;\n  readonly name?: string;\n  readonly typeArguments?: ReadonlyArray<JsonFlatAbiFragmentArgumentType> | null;\n}\n\nexport interface JsonFlatAbiFragmentFunction {\n  readonly name: string;\n  readonly inputs?: ReadonlyArray<JsonFlatAbiFragmentArgumentType>;\n  readonly output?: Readonly<JsonFlatAbiFragmentArgumentType>;\n}\n\nexport interface JsonFlatAbi {\n  readonly types: ReadonlyArray<JsonFlatAbiFragmentType>;\n  readonly loggedTypes: ReadonlyArray<JsonFlatAbiFragmentLoggedType>;\n  readonly functions: ReadonlyArray<JsonFlatAbiFragmentFunction>;\n}\n\nexport const isFlatJsonAbi = (jsonAbi: JsonAbi): jsonAbi is JsonFlatAbi => !Array.isArray(jsonAbi);\n/**\n * A JSON ABI object\n */\nexport type JsonAbi = ReadonlyArray<JsonAbiFragment> | JsonFlatAbi;\n\nexport class ABI {\n  readonly types: ReadonlyArray<JsonFlatAbiFragmentType>;\n  readonly functions: ReadonlyArray<JsonFlatAbiFragmentFunction>;\n  readonly loggedTypes: ReadonlyArray<JsonFlatAbiFragmentLoggedType>;\n\n  constructor(jsonAbi: JsonFlatAbi) {\n    this.types = jsonAbi.types;\n    this.functions = jsonAbi.functions;\n    this.loggedTypes = jsonAbi.loggedTypes;\n  }\n\n  parseLoggedType(loggedType: JsonFlatAbiFragmentLoggedType): JsonAbiFragmentType {\n    return ParamType.fromObject(this.parseInput(loggedType.loggedType) as JsonFragmentType);\n  }\n\n  parseInput(\n    input: JsonFlatAbiFragmentArgumentType,\n    typeArgumentsList: Map<number, JsonAbiFragmentType> = new Map()\n  ): JsonAbiFragmentType {\n    const type = this.types[input.type];\n    let components;\n    let typeArguments: Array<JsonAbiFragmentType> | undefined;\n\n    if (!type) {\n      throw new Error(`${input.type} not found`);\n    }\n\n    if (Array.isArray(input.typeArguments)) {\n      typeArguments = input.typeArguments.map((ta) => this.parseInput(ta, typeArgumentsList));\n    }\n\n    if (Array.isArray(type.typeParameters) && Array.isArray(typeArguments)) {\n      type.typeParameters.forEach((tp, index) => {\n        if (typeArguments?.[index]) {\n          typeArgumentsList.set(tp, typeArguments[index]);\n        }\n      });\n    }\n\n    if (Array.isArray(type.components)) {\n      components = type.components.map((c) => this.parseInput(c, typeArgumentsList));\n    }\n\n    if (genericRegEx.test(type.type)) {\n      const typeInput = typeArgumentsList.get(type.typeId);\n      if (typeInput) {\n        return {\n          ...typeInput,\n          name: input.name,\n        };\n      }\n    }\n\n    return {\n      type: type.type,\n      name: input.name,\n      typeArguments,\n      components,\n    };\n  }\n\n  static unflatten(jsonAbi: JsonAbi) {\n    if (isFlatJsonAbi(jsonAbi)) {\n      const abi = new ABI(jsonAbi);\n      return abi.unflatten();\n    }\n\n    return jsonAbi;\n  }\n\n  unflattenLoggedTypes(): ReadonlyArray<JsonAbiLogFragment> {\n    return this.loggedTypes.map((loggedType) => ({\n      ...loggedType,\n      abiFragmentType: [this.parseLoggedType(loggedType)],\n    }));\n  }\n\n  unflatten(): ReadonlyArray<JsonAbiFragment> {\n    return this.functions.map((functionType) => ({\n      type: 'function',\n      name: functionType.name,\n      inputs: (functionType.inputs || []).map((i) => this.parseInput(i)),\n      outputs: functionType.output ? [this.parseInput(functionType.output)] : [],\n    }));\n  }\n}\n\n/**\n * Checks if a given type is a reference type\n * See: https://github.com/FuelLabs/sway/issues/1368\n */\nexport const isReferenceType = (type: string) => {\n  switch (type) {\n    case 'u8':\n    case 'u16':\n    case 'u32':\n    case 'u64':\n    case 'bool': {\n      return false;\n    }\n    default: {\n      return true;\n    }\n  }\n};\n"],"mappings":"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","names":["Logger","logger","Coder","name","type","encodedLength","message","value","offset","concat","ArrayCoder","Coder","coder","length","value","concat","v","data","offset","newOffset","decoded","arrayify","bn","toHex","B256Coder","Coder","value","encodedValue","arrayify","data","offset","bytes","bn","toHex","bn","toBytes","BooleanCoder","Coder","value","bytes","toBytes","data","offset","bn","bn","toBytes","ByteCoder","Coder","value","bytes","toBytes","data","offset","bn","concat","toNumber","bn","toBytes","U64Coder","Coder","value","bytes","toBytes","data","offset","bn","_caseIndexCoder","_encodedValueSize","EnumCoder","Coder","name","coders","caseIndexCoder","U64Coder","encodedValueSize","max","coder","__privateAdd","__privateSet","value","caseKey","empty","valueCoder","caseIndex","encodedValue","padding","__privateGet","concat","data","offset","newOffset","decoded","toNumber","toNumber","toBytes","NumberCoder","Coder","baseType","value","bytes","toBytes","data","offset","toNumber","concat","toUtf8Bytes","toUtf8String","_paddingLength","StringCoder","Coder","length","paddingLength","__privateAdd","__privateSet","value","encoded","toUtf8Bytes","padding","__privateGet","concat","data","offset","bytes","toUtf8String","concat","OptionCoder","EnumCoder","value","input","data","offset","decoded","newOffset","output","StructCoder","Coder","name","coders","encodedLength","acc","coder","value","encodedFields","fieldName","fieldCoder","fieldValue","OptionCoder","concat","data","offset","newOffset","obj","decoded","concat","TupleCoder","Coder","coders","encodedLength","acc","coder","value","concat","i","data","offset","newOffset","decoded","concat","OPTION_CODER_TYPE","VEC_CODER_TYPE","stringRegEx","arrayRegEx","structRegEx","enumRegEx","tupleRegEx","genericRegEx","WORD_SIZE","BYTES_32","MAX_INPUTS","ASSET_ID_LEN","CONTRACT_ID_LEN","VM_TX_MEMORY","TRANSACTION_SCRIPT_FIXED_SIZE","VEC_PROPERTY_SPACE","VecCoder","Coder","coder","value","encodedValues","v","concat","parts","pointer","U64Coder","data","offset","filterEmptyParams","types","t","hasOptionTypes","OPTION_CODER_TYPE","getVectorAdjustments","coders","values","offset","vectorData","byteMap","encoder","i","VecCoder","data","baseVectorOffset","offsetMap","paramIndex","sum","byteInfo","byteIndex","code","Fragment","params","defineReadOnly","populate","object","params","key","paramTypeKey","value","defineReadOnly","ParamType","structRegEx","arrayRegEx","enumRegEx","_a","_b","type","arrayMatch","strMatch","stringRegEx","typeArgumentsSignature","typeArg","componentsSignature","comp","prefix","content","FunctionFragment","Fragment","value","inputs","outputs","params","ParamType","inputsSignatures","input","arrayify","concat","hexlify","Logger","sha256","toUtf8Bytes","concat","arrayify","Logger","logger","Logger","AbiCoder","param","_a","_b","_c","_d","_e","_f","NumberCoder","U64Coder","BooleanCoder","ByteCoder","B256Coder","arrayMatch","arrayRegEx","length","itemComponent","itemCoder","ArrayCoder","stringMatch","stringRegEx","StringCoder","VEC_CODER_TYPE","typeArgument","VecCoder","structMatch","structRegEx","coders","obj","component","StructCoder","enumMatch","enumRegEx","OPTION_CODER_TYPE","OptionCoder","EnumCoder","tupleRegEx","TupleCoder","types","values","offset","nonEmptyTypes","filterEmptyParams","shallowCopyValues","hasOptionTypes","type","vectorData","getVectorAdjustments","results","concat","data","bytes","arrayify","assertParamsMatch","newOffset","coder","decoded","isFlatJsonAbi","jsonAbi","ABI","loggedType","ParamType","input","typeArgumentsList","type","components","typeArguments","ta","tp","index","c","genericRegEx","typeInput","functionType","i","isReferenceType","logger","Logger","coerceFragments","value","fragments","v","FunctionFragment","Interface","jsonAbi","isFlatJsonAbi","ABI","AbiCoder","fragment","bucket","signature","bytes","toUtf8Bytes","concat","arrayify","sha256","nameOrSignatureOrSighash","functionFragment","hexlify","data","values","offset","selector","inputs","filterEmptyParams","isRef","isReferenceType","args","BooleanCoder","logId","logType","type"]}