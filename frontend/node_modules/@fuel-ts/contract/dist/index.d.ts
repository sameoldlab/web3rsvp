import { FunctionFragment, Interface, JsonAbi, JsonFlatAbi } from '@fuel-ts/abi-coder';
import { BigNumberish, BN } from '@fuel-ts/math';
import * as _fuel_ts_providers from '@fuel-ts/providers';
import { CallResult, TransactionResponse, TransactionResult, TransactionResultReceipt, ScriptTransactionRequest, CoinQuantity, TransactionRequest, Provider, CoinQuantityLike, CreateTransactionRequestLike } from '@fuel-ts/providers';
import { AbstractAddress, ContractIdLike, AbstractContract } from '@fuel-ts/interfaces';
import { BaseWalletLocked } from '@fuel-ts/wallet';
import { BytesLike, DataOptions } from '@ethersproject/bytes';
import { StorageSlot } from '@fuel-ts/transactions';

declare type ContractCall = {
    contractId: AbstractAddress;
    data: BytesLike;
    amount?: BigNumberish;
    assetId?: BytesLike;
    gas?: BigNumberish;
};

declare class InvocationResult<T = any> {
    readonly functionScopes: Array<InvocationScopeLike>;
    readonly isMultiCall: boolean;
    readonly gasUsed: BN;
    readonly value: T;
    constructor(funcScopes: InvocationScopeLike | Array<InvocationScopeLike>, callResult: CallResult, isMultiCall: boolean);
    protected getDecodedValue(callResult: CallResult): T;
}
declare class FunctionInvocationResult<T = any> extends InvocationResult<T> {
    readonly transactionId: string;
    readonly transactionResponse: TransactionResponse;
    readonly transactionResult: TransactionResult<any>;
    readonly contract: Contract;
    readonly logs: Array<any>;
    constructor(funcScopes: InvocationScopeLike | Array<InvocationScopeLike>, transactionResponse: TransactionResponse, transactionResult: TransactionResult<any>, contract: Contract, isMultiCall: boolean);
    static build<T>(funcScope: InvocationScopeLike | Array<InvocationScopeLike>, transactionResponse: TransactionResponse, isMultiCall: boolean, contract: Contract): Promise<FunctionInvocationResult<T>>;
    protected getDecodedLogs(receipts: Array<TransactionResultReceipt>): never[];
}
declare class InvocationCallResult<T = any> extends InvocationResult<T> {
    readonly callResult: CallResult;
    constructor(funcScopes: InvocationScopeLike | Array<InvocationScopeLike>, callResult: CallResult, isMultiCall: boolean);
    static build<T>(funcScopes: InvocationScopeLike | Array<InvocationScopeLike>, callResult: CallResult, isMultiCall: boolean): Promise<InvocationCallResult<T>>;
}

declare class BaseInvocationScope<TReturn = any> {
    transactionRequest: ScriptTransactionRequest;
    protected contract: Contract;
    protected functionInvocationScopes: Array<InvocationScopeLike>;
    protected txParameters?: TxParams;
    protected requiredCoins: CoinQuantity[];
    protected isMultiCall: boolean;
    constructor(contract: Contract, isMultiCall: boolean);
    protected get calls(): ContractCall[];
    protected static getCallOptions(options?: CallOptions): {
        fundTransaction: boolean;
    };
    protected updateScriptRequest(): void;
    protected getRequiredCoins(): Array<CoinQuantity>;
    protected updateRequiredCoins(): void;
    protected addCall(funcScope: InvocationScopeLike): this;
    protected addCalls(funcScopes: Array<InvocationScopeLike>): this;
    protected prepareTransaction(options?: CallOptions): Promise<void>;
    protected checkGasLimitTotal(): void;
    /**
     * Run a valid transaction in dryRun mode and returns useful details about
     * gasUsed, gasPrice and transaction estimate fee in native coins.
     */
    getTransactionCost(options?: TransactionCostOptions): Promise<_fuel_ts_providers.TransactionCost>;
    /**
     * Add to the transaction scope the required amount of unspent UTXO's.
     *
     * Required Amount = forward coins + transfers + gas fee.
     */
    fundWithRequiredCoins(): Promise<this>;
    txParams(txParams: TxParams): this;
    addContracts(contracts: Array<ContractIdLike>): this;
    /**
     * Prepare transaction request object, adding Inputs, Outputs, coins, check gas costs
     * and transaction validity.
     *
     * It's possible to get the transaction without adding coins, by passing `fundTransaction`
     * as false.
     */
    getTransactionRequest(options?: CallOptions): Promise<TransactionRequest>;
    /**
     * Submits a transaction to the blockchain.
     *
     * This is a final action and will spend the coins and change the state of the contract.
     * It also means that invalid transactions will throw an error, and consume gas. To avoid this
     * running invalid tx and consuming gas try to `simulate` first when possible.
     */
    call<T = TReturn>(options?: CallOptions): Promise<FunctionInvocationResult<T>>;
    /**
     * Run a valid transaction and return the result without change the chain state.
     * This means, all signatures are validated but no UTXO is spent.
     *
     * This method is useful for validate propose to avoid spending coins on invalid TXs, also
     * to estimate the amount of gas that will be required to run the transaction.
     */
    simulate<T = TReturn>(options?: CallOptions): Promise<InvocationCallResult<T>>;
    /**
     * Executes a transaction in dry run mode, without UTXO validations.
     *
     * A transaction in dry run mode can't change the state of the blockchain. It can be useful to access readonly
     * methods or just ust get.
     * The UTXO validation disable in this case, enables to send invalid inputs to emulate different conditions, of a
     * transaction
     */
    dryRun<T = TReturn>(options?: CallOptions): Promise<InvocationCallResult<T>>;
    /**
     * Executes a readonly contract method call.
     *
     * Under the hood it uses the `dryRun` method but don't fund the transaction
     * with coins by default, for emulating executions with forward coins use `dryRun`
     * or pass the options.fundTransaction as true
     */
    get<T = TReturn>(options?: CallOptions): Promise<InvocationCallResult<T>>;
}

declare class FunctionInvocationScope<TArgs extends Array<any> = Array<any>, TReturn = any> extends BaseInvocationScope<TReturn> {
    private func;
    private callParameters?;
    private forward?;
    private args;
    constructor(contract: Contract, func: FunctionFragment, args: TArgs);
    getCallConfig(): CallConfig<TArgs>;
    setArguments(...args: TArgs): this;
    callParams(callParams: CallParams): this;
}

declare class MultiCallInvocationScope<TReturn = any> extends BaseInvocationScope<TReturn> {
    constructor(contract: Contract, funcScopes: Array<FunctionInvocationScope>);
    addCall(funcScope: FunctionInvocationScope): this;
    addCalls(funcScopes: Array<FunctionInvocationScope>): this;
}

declare class Contract implements AbstractContract {
    id: AbstractAddress;
    provider: Provider | null;
    interface: Interface;
    wallet: BaseWalletLocked | null;
    functions: InvokeFunctions;
    constructor(id: string | AbstractAddress, abi: JsonAbi | JsonFlatAbi | Interface, walletOrProvider?: BaseWalletLocked | Provider | null);
    buildFunction(func: FunctionFragment): (...args: Array<unknown>) => FunctionInvocationScope<unknown[], any>;
    multiCall(calls: Array<FunctionInvocationScope>): MultiCallInvocationScope<any>;
}

declare type CallParams = Partial<{
    forward: CoinQuantityLike;
    gasLimit: BigNumberish;
}>;
declare type TxParams = Partial<{
    gasPrice: BigNumberish;
    gasLimit: BigNumberish;
    variableOutputs: number;
}>;
declare type CallOptions = Partial<{
    fundTransaction: boolean;
}>;
declare type CallConfig<T = unknown> = {
    func: FunctionFragment;
    contract: Contract;
    callParameters?: CallParams;
    txParameters?: TxParams;
    forward?: CoinQuantity;
    args: T;
    bytesOffset: number;
};
declare type InvokeFunction<TArgs extends Array<any> = Array<any>, TReturn = any> = (...args: TArgs) => FunctionInvocationScope<TArgs, TReturn>;
interface InvokeFunctions {
    [key: string]: InvokeFunction;
}
declare type InvocationScopeLike<T = unknown> = {
    getCallConfig(): CallConfig<T>;
};
declare type TransactionCostOptions = Partial<{
    fundTransaction: boolean;
    gasPrice: BigNumberish;
    tolerance: number;
}>;

declare type DeployContractOptions = {
    salt?: BytesLike;
    storageSlots?: StorageSlot[];
    stateRoot?: BytesLike;
} & CreateTransactionRequestLike;
declare class ContractFactory {
    bytecode: BytesLike;
    interface: Interface;
    provider: Provider | null;
    wallet: BaseWalletLocked | null;
    constructor(bytecode: BytesLike, abi: JsonAbi | Interface, walletOrProvider?: BaseWalletLocked | Provider | null);
    connect(provider: Provider | null): ContractFactory;
    deployContract(deployContractOptions?: DeployContractOptions): Promise<Contract>;
}

declare const getContractRoot: (bytecode: Uint8Array) => string;
declare const getContractStorageRoot: (storageSlots: StorageSlot[]) => string;
declare const getContractId: (bytecode: BytesLike, salt: BytesLike, stateRoot: BytesLike) => string;
/**
 * Generic assert function to avoid undesirable errors
 */
declare function assert(condition: unknown, message: string): asserts condition;
declare const includeHexPrefix: (value: string, options?: DataOptions) => string;

declare const util_getContractRoot: typeof getContractRoot;
declare const util_getContractStorageRoot: typeof getContractStorageRoot;
declare const util_getContractId: typeof getContractId;
declare const util_assert: typeof assert;
declare const util_includeHexPrefix: typeof includeHexPrefix;
declare namespace util {
  export {
    util_getContractRoot as getContractRoot,
    util_getContractStorageRoot as getContractStorageRoot,
    util_getContractId as getContractId,
    util_assert as assert,
    util_includeHexPrefix as includeHexPrefix,
  };
}

export { CallConfig, CallOptions, CallParams, Contract, ContractFactory, util as ContractUtils, FunctionInvocationResult, FunctionInvocationScope, InvocationResult, InvocationScopeLike, InvokeFunction, InvokeFunctions, MultiCallInvocationScope, TransactionCostOptions, TxParams };
