{"version":3,"sources":["../src/sumMerkleTree.ts","../src/types/node.ts","../src/types/proof.ts"],"sourcesContent":["/// @dev The Fuel testing Merkle trees.\n/// A set of useful helper methods for testing and deploying Merkle trees.\nimport { bn, toHex } from '@fuel-ts/math';\nimport { hash } from '@fuel-ts/merkle-shared';\n\nimport Node from './types/node';\nimport Proof from './types/proof';\n\n/**\n * Slice off the '0x' on each argument to simulate abi.encodePacked\n * hash(prefix + value + data)\n */\nexport function hashLeaf(value: string, data: string): string {\n  return hash('0x00'.concat(toHex(value, 32).slice(2)).concat(data.slice(2)));\n}\n\n/**\n * Slice off the '0x' on each argument to simulate abi.encodePacked\n * hash (prefix + leftSum + leftHash + rightSum + rightHash)\n */\nexport function hashNode(\n  leftValue: string,\n  left: string,\n  rightValue: string,\n  right: string\n): string {\n  return hash(\n    '0x01'\n      .concat(toHex(leftValue, 32).slice(2))\n      .concat(left.slice(2))\n      .concat(toHex(rightValue, 32).slice(2))\n      .concat(right.slice(2))\n  );\n}\n\n/**\n * Construct tree\n */\nexport function constructTree(sums: string[], data: string[]): Node[] {\n  const nodes = [];\n  for (let i = 0, n = data.length; i < n; i += 1) {\n    const hashed = hashLeaf(sums[i], data[i]);\n    const leaf = new Node(-1, -1, -1, hashed, sums[i], data[i]);\n    leaf.index = i;\n    nodes.push(leaf);\n  }\n  const nodesList = [...nodes];\n  let pNodes = [...nodes];\n  let size = (nodes.length + 1) >> 1;\n  let odd = nodes.length & 1;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let i = 0;\n    for (; i < size - odd; i += 1) {\n      const j = i << 1;\n      const hashed = hashNode(pNodes[j].sum, pNodes[j].hash, pNodes[j + 1].sum, pNodes[j + 1].hash);\n      nodes[i] = new Node(\n        pNodes[j].index,\n        pNodes[j + 1].index,\n        -1,\n        hashed,\n        bn(pNodes[j].sum)\n          .add(pNodes[j + 1].sum)\n          .toHex(),\n        ''\n      );\n      nodes[i].index = nodesList.length;\n      nodesList[pNodes[j].index].parent = nodesList.length;\n      nodesList[pNodes[j + 1].index].parent = nodesList.length;\n      nodesList.push(nodes[i]);\n    }\n    if (odd === 1) {\n      nodes[i] = pNodes[i << 1];\n    }\n    if (size === 1) {\n      break;\n    }\n    odd = size & 1;\n    size = (size + 1) >> 1;\n    pNodes = [...nodes];\n  }\n  return nodesList;\n}\n\n/**\n * Compute the merkle root\n */\nexport function calcRoot(sums: string[], data: string[]): Node {\n  const nodes = [];\n  for (let i = 0; i < data.length; i += 1) {\n    const hashed = hashLeaf(sums[i], data[i]);\n    nodes.push(new Node(-1, -1, -1, hashed, sums[i], data[i]));\n  }\n  let pNodes = nodes;\n  let size = (nodes.length + 1) >> 1;\n  let odd = nodes.length & 1;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let i = 0;\n    for (; i < size - odd; i += 1) {\n      const j = i << 1;\n      const hashed = hashNode(pNodes[j].sum, pNodes[j].hash, pNodes[j + 1].sum, pNodes[j + 1].hash);\n      nodes[i] = new Node(\n        pNodes[j].index,\n        pNodes[j + 1].index,\n        -1,\n        hashed,\n        bn(pNodes[j].sum)\n          .add(pNodes[j + 1].sum)\n          .toHex(),\n        ''\n      );\n    }\n    if (odd === 1) {\n      nodes[i] = pNodes[i << 1];\n    }\n    if (size === 1) {\n      break;\n    }\n    odd = size & 1;\n    size = (size + 1) >> 1;\n    pNodes = nodes;\n  }\n  return nodes[0];\n}\n\n/**\n * Get proof for the leaf\n */\nexport function getProof(nodes: Node[], id: number): Proof {\n  const proof: Proof = new Proof([], []);\n  for (let prev = id, cur = nodes[id].parent; cur !== -1; prev = cur, cur = nodes[cur].parent) {\n    if (nodes[cur].left === prev) {\n      proof.sideNodes.push(nodes[nodes[cur].right].hash);\n      proof.nodeSums.push(nodes[nodes[cur].right].sum);\n    } else {\n      proof.sideNodes.push(nodes[nodes[cur].left].hash);\n      proof.nodeSums.push(nodes[nodes[cur].left].sum);\n    }\n  }\n  return proof;\n}\n","class Node {\n  left: number;\n  right: number;\n  parent: number;\n  hash: string;\n  data: string;\n  sum: string;\n  index: number;\n\n  constructor(\n    left: number,\n    right: number,\n    parent: number,\n    hash: string,\n    sum: string,\n    data: string,\n    index: number = 0\n  ) {\n    this.left = left;\n    this.right = right;\n    this.parent = parent;\n    this.hash = hash;\n    this.sum = sum;\n    this.data = data;\n    this.index = index;\n  }\n}\n\nexport default Node;\n","// Sum Merkle proof\nclass Proof {\n  sideNodes: string[];\n  nodeSums: string[];\n\n  constructor(sideNodes: string[], sums: string[]) {\n    this.sideNodes = sideNodes;\n    this.nodeSums = sums;\n  }\n}\n\nexport default Proof;\n"],"mappings":"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","names":["bn","toHex","hash","Node","left","right","parent","hash","sum","data","index","node_default","Proof","sideNodes","sums","proof_default","hashLeaf","value","data","hash","toHex","hashNode","leftValue","left","rightValue","right","constructTree","sums","nodes","i","n","hashed","leaf","node_default","nodesList","pNodes","size","odd","j","bn","calcRoot","getProof","id","proof","proof_default","prev","cur"]}