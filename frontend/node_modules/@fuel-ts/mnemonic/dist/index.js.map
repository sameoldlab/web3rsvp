{"version":3,"sources":["../src/index.ts","../src/mnemonic.ts","../src/utils.ts"],"sourcesContent":["export { default as Mnemonic } from './mnemonic';\nexport type { MnemonicPhrase } from './utils';\n","import { Base58 } from '@ethersproject/basex';\nimport type { BytesLike } from '@ethersproject/bytes';\nimport { hexDataSlice, concat, hexlify, arrayify } from '@ethersproject/bytes';\nimport { pbkdf2 } from '@ethersproject/pbkdf2';\nimport { computeHmac, sha256, SupportedAlgorithm } from '@ethersproject/sha2';\nimport { randomBytes } from '@fuel-ts/keystore';\nimport { english } from '@fuel-ts/wordlists';\n\nimport type { MnemonicPhrase } from './utils';\nimport {\n  entropyToMnemonicIndices,\n  getWords,\n  getPhrase,\n  mnemonicWordsToEntropy,\n  toUtf8Bytes,\n} from './utils';\n\n//\n// Constants\n//\n// \"Bitcoin seed\"\nconst MasterSecret = toUtf8Bytes('Bitcoin seed');\n// 4 byte: version bytes (mainnet: 0x0488B21E public, 0x0488ADE4 private; testnet: 0x043587CF public, 0x04358394 private)\nconst MainnetPRV = 0x0488ade4;\nconst TestnetPRV = 0x04358394;\n\nfunction assertWordList(wordlist: Array<string>) {\n  if (wordlist.length !== 2048) {\n    throw new Error('Invalid word list length');\n  }\n}\n\nfunction assertEntropy(entropy: BytesLike) {\n  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {\n    throw new Error('invalid entropy');\n  }\n}\n\nfunction assertMnemonic(words: Array<string>) {\n  if (![12, 15, 18, 21, 24].includes(words.length)) {\n    throw new Error('invalid mnemonic size');\n  }\n}\n\nclass Mnemonic {\n  wordlist: Array<string>;\n\n  /**\n   *\n   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.\n   * @returns Mnemonic instance\n   */\n  constructor(wordlist: Array<string> = english) {\n    this.wordlist = wordlist;\n\n    assertWordList(this.wordlist);\n  }\n\n  /**\n   *\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @returns Entropy hash\n   */\n  mnemonicToEntropy(phrase: MnemonicPhrase) {\n    return Mnemonic.mnemonicToEntropy(phrase, this.wordlist);\n  }\n\n  /**\n   *\n   * @param entropy - Entropy source to the mnemonic phrase.\n   * @returns Mnemonic phrase\n   */\n  entropyToMnemonic(entropy: BytesLike) {\n    return Mnemonic.entropyToMnemonic(entropy, this.wordlist);\n  }\n\n  /**\n   *\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.\n   * @returns Mnemonic phrase\n   */\n  static mnemonicToEntropy(phrase: MnemonicPhrase, wordlist: Array<string> = english): string {\n    const words = getWords(phrase);\n\n    assertMnemonic(words);\n\n    return hexlify(mnemonicWordsToEntropy(words, wordlist));\n  }\n\n  /**\n   * @param entropy - Entropy source to the mnemonic phrase.\n   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).\n   * @returns 64-byte array contains privateKey and chainCode as described on BIP39\n   */\n  static entropyToMnemonic(entropy: BytesLike, wordlist: Array<string> = english): string {\n    const entropyBytes = arrayify(entropy, {\n      allowMissingPrefix: true,\n    });\n\n    assertWordList(wordlist);\n    assertEntropy(entropyBytes);\n\n    return entropyToMnemonicIndices(entropyBytes)\n      .map((i) => wordlist[i])\n      .join(' ');\n  }\n\n  /**\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`\n   * @returns 64-byte array contains privateKey and chainCode as described on BIP39\n   */\n  static mnemonicToSeed(phrase: MnemonicPhrase, passphrase: BytesLike = '') {\n    assertMnemonic(getWords(phrase));\n\n    const phraseBytes = toUtf8Bytes(getPhrase(phrase));\n    const salt = toUtf8Bytes(`mnemonic${passphrase}`);\n\n    return pbkdf2(phraseBytes, salt, 2048, 64, 'sha512');\n  }\n\n  /**\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`\n   * @returns 64-byte array contains privateKey and chainCode as described on BIP39\n   */\n  static mnemonicToMasterKeys(phrase: MnemonicPhrase, passphrase: BytesLike = '') {\n    const seed = Mnemonic.mnemonicToSeed(phrase, passphrase);\n    return Mnemonic.masterKeysFromSeed(seed);\n  }\n\n  /**\n   * @param seed - BIP39 seed\n   * @param testnet - Inform if should use testnet or mainnet prefix, the default value is true (`mainnet`).\n   * @returns 64-byte array contains privateKey and chainCode as described on BIP39\n   */\n  static masterKeysFromSeed(seed: string): Uint8Array {\n    const seedArray = arrayify(seed);\n\n    if (seedArray.length < 16 || seedArray.length > 64) {\n      throw new Error('invalid seed');\n    }\n\n    return arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));\n  }\n\n  /**\n   * Get the extendKey as defined on BIP-32 from the provided seed\n   *\n   * @param seed - BIP39 seed\n   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).\n   * @returns BIP-32 extended private key\n   */\n  static seedToExtendedKey(seed: string, testnet: boolean = false): string {\n    const masterKey = Mnemonic.masterKeysFromSeed(seed);\n    const prefix = arrayify(testnet ? TestnetPRV : MainnetPRV);\n    const depth = '0x00';\n    const fingerprint = '0x00000000';\n    const index = '0x00000000';\n    // last 32 bites from the key\n    const chainCode = masterKey.slice(32);\n    // first 32 bites from the key\n    const privateKey = masterKey.slice(0, 32);\n    const extendedKey = concat([\n      prefix,\n      depth,\n      fingerprint,\n      index,\n      chainCode,\n      concat(['0x00', privateKey]),\n    ]);\n    const checksum = hexDataSlice(sha256(sha256(extendedKey)), 0, 4);\n\n    return Base58.encode(concat([extendedKey, checksum]));\n  }\n\n  /**\n   *  Create a new mnemonic using a randomly generated number as entropy.\n   *  As defined in BIP39, the entropy must be a multiple of 32 bits, and its size must be between 128 and 256 bits.\n   *  Therefore, the possible values for `strength` are 128, 160, 192, 224, and 256.\n   *  If not provided, the default entropy length will be set to 256 bits.\n   *  The return is a list of words that encodes the generated entropy.\n   *\n   *\n   * @param size - Number of bytes used as an entropy\n   * @param extraEntropy - Optional extra entropy to increase randomness\n   * @returns A randomly generated mnemonic\n   */\n  static generate(size: number = 32, extraEntropy: BytesLike = '') {\n    const entropy = extraEntropy\n      ? sha256(concat([randomBytes(size), arrayify(extraEntropy)]))\n      : randomBytes(size);\n    return Mnemonic.entropyToMnemonic(entropy);\n  }\n}\n\nexport default Mnemonic;\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify } from '@ethersproject/bytes';\nimport { sha256 } from '@ethersproject/sha2';\n\n/* Mnemonic phrase composed by words from the provided wordlist it can be a text or a array of words */\nexport type MnemonicPhrase = string | Array<string>;\n\nexport function toUtf8Bytes(stri: string): Uint8Array {\n  const str = stri.normalize('NFKD');\n\n  const result = [];\n  for (let i = 0; i < str.length; i += 1) {\n    const c = str.charCodeAt(i);\n\n    if (c < 0x80) {\n      result.push(c);\n    } else if (c < 0x800) {\n      result.push((c >> 6) | 0xc0);\n      result.push((c & 0x3f) | 0x80);\n    } else if ((c & 0xfc00) === 0xd800) {\n      i += 1;\n      const c2 = str.charCodeAt(i);\n\n      if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n        throw new Error('invalid utf-8 string');\n      }\n\n      // Surrogate Pair\n      const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n      result.push((pair >> 18) | 0xf0);\n      result.push(((pair >> 12) & 0x3f) | 0x80);\n      result.push(((pair >> 6) & 0x3f) | 0x80);\n      result.push((pair & 0x3f) | 0x80);\n    } else {\n      result.push((c >> 12) | 0xe0);\n      result.push(((c >> 6) & 0x3f) | 0x80);\n      result.push((c & 0x3f) | 0x80);\n    }\n  }\n\n  return arrayify(result);\n}\n\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits: number): number {\n  return (1 << bits) - 1;\n}\n\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits: number): number {\n  return ((1 << bits) - 1) << (8 - bits);\n}\n\nexport function getWords(mnemonic: MnemonicPhrase): Array<string> {\n  if (!Array.isArray(mnemonic)) {\n    return mnemonic.split(' ');\n  }\n  return mnemonic;\n}\n\nexport function getPhrase(mnemonic: MnemonicPhrase): string {\n  if (Array.isArray(mnemonic)) {\n    return mnemonic.join(' ');\n  }\n  return mnemonic;\n}\n\nexport function entropyToMnemonicIndices(entropy: Uint8Array): Array<number> {\n  const indices: Array<number> = [0];\n\n  let remainingBits = 11;\n  for (let i = 0; i < entropy.length; i += 1) {\n    if (remainingBits > 8) {\n      indices[indices.length - 1] <<= 8;\n      indices[indices.length - 1] |= entropy[i];\n\n      remainingBits -= 8;\n      // This byte will complete an 11-bit index\n    } else {\n      indices[indices.length - 1] <<= remainingBits;\n      indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n\n      // Start the next word\n      indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n\n      remainingBits += 3;\n    }\n  }\n\n  // Compute the checksum bits\n  const checksumBits = entropy.length / 4;\n  const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);\n\n  // Shift the checksum into the word indices\n  indices[indices.length - 1] <<= checksumBits;\n  indices[indices.length - 1] |= checksum >> (8 - checksumBits);\n\n  return indices;\n}\n\nexport function mnemonicWordsToEntropy(words: Array<string>, wordlist: Array<string>): BytesLike {\n  const size = Math.ceil((11 * words.length) / 8);\n  const entropy = arrayify(new Uint8Array(size));\n\n  let offset = 0;\n  for (let i = 0; i < words.length; i += 1) {\n    const index = wordlist.indexOf(words[i].normalize('NFKD'));\n    if (index === -1) {\n      throw new Error('invalid mnemonic');\n    }\n\n    for (let bit = 0; bit < 11; bit += 1) {\n      if (index & (1 << (10 - bit))) {\n        entropy[offset >> 3] |= 1 << (7 - (offset % 8));\n      }\n      offset += 1;\n    }\n  }\n  const entropyBits = (32 * words.length) / 3;\n  const checksumBits = words.length / 3;\n  const checksumMask = getUpperMask(checksumBits);\n  const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\n  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n    throw new Error('invalid checksum');\n  }\n\n  return entropy.slice(0, entropyBits / 8);\n}\n"],"mappings":"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","names":["src_exports","__export","mnemonic_default","__toCommonJS","import_basex","import_bytes","import_pbkdf2","import_sha2","import_keystore","import_wordlists","import_bytes","import_sha2","toUtf8Bytes","stri","str","result","i","c","c2","pair","getLowerMask","bits","getUpperMask","getWords","mnemonic","getPhrase","entropyToMnemonicIndices","entropy","indices","remainingBits","checksumBits","checksum","mnemonicWordsToEntropy","words","wordlist","size","offset","index","bit","entropyBits","checksumMask","MasterSecret","toUtf8Bytes","MainnetPRV","TestnetPRV","assertWordList","wordlist","assertEntropy","entropy","assertMnemonic","words","Mnemonic","phrase","getWords","mnemonicWordsToEntropy","entropyBytes","entropyToMnemonicIndices","i","passphrase","phraseBytes","getPhrase","salt","seed","seedArray","testnet","masterKey","prefix","depth","fingerprint","index","chainCode","privateKey","extendedKey","checksum","size","extraEntropy","mnemonic_default"]}