{"version":3,"sources":["../src/binaryMerkleTree.ts","../src/types/node.ts"],"sourcesContent":["// A set of useful helper methods for testing binary Merkle trees.\nimport { EMPTY, hash } from '@fuel-ts/merkle-shared';\n\nimport Node from './types/node';\n\n/**\n * Slice off the '0x' on each argument to simulate abi.encodePacked\n */\nexport function hashLeaf(data: string): string {\n  return hash('0x00'.concat(data.slice(2)));\n}\n\n/**\n * Slice off the '0x' on each argument to simulate abi.encodePacked\n * hash(prefix +  left + right)\n */\nexport function hashNode(left: string, right: string): string {\n  return hash('0x01'.concat(left.slice(2)).concat(right.slice(2)));\n}\n\n/**\n * Construct tree\n */\nexport function constructTree(data: string[]): Node[] {\n  const nodes = [];\n  for (let i = 0; i < data.length; i += 1) {\n    const hashed = hashLeaf(data[i]);\n    const leaf = new Node(-1, -1, -1, hashed, data[i]);\n    leaf.index = i;\n    nodes.push(leaf);\n  }\n\n  const nodesList = [...nodes];\n  let pNodes = [...nodes];\n\n  let size = (nodes.length + 1) >> 1;\n  let odd = nodes.length & 1;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let i = 0;\n    for (; i < size - odd; i += 1) {\n      const j = i << 1;\n      const hashed = hashNode(pNodes[j].hash, pNodes[j + 1].hash);\n      nodes[i] = new Node(pNodes[j].index, pNodes[j + 1].index, -1, hashed, '');\n      const nextIndex = nodesList.length;\n      nodes[i].index = nextIndex;\n\n      nodesList[pNodes[j].index].parent = nextIndex;\n      nodesList[pNodes[j + 1].index].parent = nextIndex;\n      nodesList.push(nodes[i]);\n    }\n\n    if (size === 1) {\n      break;\n    }\n\n    if (odd === 1) {\n      nodes[i] = pNodes[i << 1];\n    }\n\n    odd = size & 1;\n    size = (size + 1) >> 1;\n    pNodes = [...nodes];\n  }\n  return nodesList;\n}\n\n/**\n * Compute the merkle root\n */\nexport function calcRoot(data: string[]): string {\n  if (!data.length) {\n    return EMPTY;\n  }\n  const nodes = [];\n  for (let i = 0; i < data.length; i += 1) {\n    const hashed = hashLeaf(data[i]);\n    nodes.push(new Node(-1, -1, -1, hashed, data[i]));\n  }\n  let pNodes = nodes;\n  let size = (nodes.length + 1) >> 1;\n  let odd = nodes.length & 1;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let i = 0;\n    for (; i < size - odd; i += 1) {\n      const j = i << 1;\n      const hashed = hashNode(pNodes[j].hash, pNodes[j + 1].hash);\n      nodes[i] = new Node(pNodes[j].index, pNodes[j + 1].index, -1, hashed, '');\n    }\n    if (odd === 1) {\n      nodes[i] = pNodes[i << 1];\n    }\n    if (size === 1) {\n      break;\n    }\n    odd = size & 1;\n    size = (size + 1) >> 1;\n    pNodes = nodes;\n  }\n  return nodes[0].hash;\n}\n\n/**\n * Get proof for the leaf\n */\nexport function getProof(nodes: Node[], id: number): string[] {\n  const proof: string[] = [];\n  for (let prev = id, cur = nodes[id].parent; cur !== -1; prev = cur, cur = nodes[cur].parent) {\n    if (nodes[cur].left === prev) {\n      proof.push(nodes[nodes[cur].right].hash);\n    } else {\n      proof.push(nodes[nodes[cur].left].hash);\n    }\n  }\n  return proof;\n}\n","class Node {\n  left: number;\n  right: number;\n  parent: number;\n  hash: string;\n  data: string;\n  index: number;\n\n  constructor(\n    left: number,\n    right: number,\n    parent: number,\n    hash: string,\n    data: string,\n    index: number = 0\n  ) {\n    this.left = left;\n    this.right = right;\n    this.parent = parent;\n    this.hash = hash;\n    this.data = data;\n    this.index = index;\n  }\n}\n\nexport default Node;\n"],"mappings":"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","names":["EMPTY","hash","Node","left","right","parent","hash","data","index","node_default","hashLeaf","data","hash","hashNode","left","right","constructTree","nodes","i","hashed","leaf","node_default","nodesList","pNodes","size","odd","j","nextIndex","calcRoot","EMPTY","getProof","id","proof","prev","cur"]}