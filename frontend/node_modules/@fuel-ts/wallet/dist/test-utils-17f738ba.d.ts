import * as _fuel_ts_providers from '@fuel-ts/providers';
import { Provider, CoinQuantityLike, ExcludeResourcesOption, Resource, Coin, Message, CoinQuantity, TransactionRequest, TransactionRequestLike, TransactionResponse, CallResult, BuildPredicateOptions, ScriptTransactionRequest, TransactionResult } from '@fuel-ts/providers';
import { BytesLike } from '@ethersproject/bytes';
import { InputValue } from '@fuel-ts/abi-coder';
import { AbstractWallet, AbstractAddress, AbstractPredicate } from '@fuel-ts/interfaces';
import { BN, BigNumberish } from '@fuel-ts/math';
import { Signer } from '@fuel-ts/signer';

/**
 * BaseWallet
 */
declare class BaseWalletLocked extends AbstractWallet {
    private readonly _address;
    provider: Provider;
    constructor(publicKey: string | AbstractAddress, provider?: string | Provider);
    get address(): AbstractAddress;
    /**
     * Change provider connection
     */
    connect(provider: string | Provider): Provider;
    /**
     * Returns resources satisfying the spend query.
     */
    getResourcesToSpend(quantities: CoinQuantityLike[] /** IDs of coins to exclude */, excludedIds?: ExcludeResourcesOption): Promise<Resource[]>;
    /**
     * Gets coins owned by the wallet address.
     */
    getCoins(): Promise<Coin[]>;
    /**
     * Gets messages owned by the wallet address.
     */
    getMessages(): Promise<Message[]>;
    /**
     * Gets balance for the given asset.
     */
    getBalance(assetId?: BytesLike): Promise<BN>;
    /**
     * Gets balances.
     */
    getBalances(): Promise<CoinQuantity[]>;
    /**
     * Adds resources to the transaction enough to fund it.
     */
    fund<T extends TransactionRequest>(request: T): Promise<void>;
    /**
     * Returns coins satisfying the spend query.
     */
    transfer(
    /** Address of the destination */
    destination: AbstractAddress, 
    /** Amount of coins */
    amount: BigNumberish, 
    /** Asset ID of coins */
    assetId?: BytesLike, 
    /** Tx Params */
    txParams?: Pick<TransactionRequestLike, 'gasLimit' | 'gasPrice' | 'maturity'>): Promise<TransactionResponse>;
    /**
     * Withdraws an amount of the base asset to the base chain.
     */
    withdrawToBaseLayer(
    /** Address of the recipient on the base chain */
    recipient: AbstractAddress, 
    /** Amount of base asset */
    amount: BigNumberish, 
    /** Tx Params */
    txParams?: Pick<TransactionRequestLike, 'gasLimit' | 'gasPrice' | 'maturity'>): Promise<TransactionResponse>;
    /**
     * Populates witnesses signature and send it to the network using `provider.sendTransaction`.
     *
     * @param transactionRequest - TransactionRequest
     * @returns TransactionResponse
     */
    sendTransaction(transactionRequestLike: TransactionRequestLike): Promise<TransactionResponse>;
    /**
     * Populates witnesses signature and send a call it to the network using `provider.call`.
     *
     * @param transactionRequest - TransactionRequest
     * @returns CallResult
     */
    simulateTransaction(transactionRequestLike: TransactionRequestLike): Promise<CallResult>;
    buildPredicateTransaction(predicateAddress: AbstractAddress, amountToPredicate: BigNumberish, assetId?: BytesLike, predicateOptions?: BuildPredicateOptions): Promise<ScriptTransactionRequest>;
    submitPredicate(predicateAddress: AbstractAddress, amountToPredicate: BigNumberish, assetId?: BytesLike, options?: BuildPredicateOptions): Promise<TransactionResult<'success'>>;
    submitSpendPredicate(predicate: AbstractPredicate, amountToSpend: BigNumberish, predicateData?: InputValue[], assetId?: BytesLike, options?: BuildPredicateOptions): Promise<TransactionResult<'success'>>;
}

/**
 * BaseWalletUnlocked
 */
declare class BaseWalletUnlocked extends BaseWalletLocked {
    static defaultPath: string;
    provider: Provider;
    signer: () => Signer;
    constructor(privateKey: BytesLike, provider?: string | Provider);
    get privateKey(): string;
    get publicKey(): string;
    /**
     * Sign message with wallet instance privateKey
     *
     * @param message - Message
     * @returns Promise<string> - Signature a ECDSA 64 bytes
     */
    signMessage(message: string): Promise<string>;
    /**
     * Sign transaction with wallet instance privateKey
     *
     * @param transactionRequestLike - TransactionRequestLike
     * @returns string - Signature a ECDSA 64 bytes
     */
    signTransaction(transactionRequestLike: TransactionRequestLike): Promise<string>;
    populateTransactionWitnessesSignature(transactionRequestLike: TransactionRequestLike): Promise<_fuel_ts_providers.TransactionRequest>;
    /**
     * Populates witnesses signature and send it to the network using `provider.sendTransaction`.
     *
     * @param transactionRequest - TransactionRequest
     * @returns TransactionResponse
     */
    sendTransaction(transactionRequestLike: TransactionRequestLike): Promise<TransactionResponse>;
    /**
     * Populates witnesses signature and send a call it to the network using `provider.call`.
     *
     * @param transactionRequest - TransactionRequest
     * @returns CallResult
     */
    simulateTransaction(transactionRequestLike: TransactionRequestLike): Promise<CallResult>;
}

interface GenerateOptions {
    /** Additional entropy for the random bytes */
    entropy?: BytesLike;
    provider?: string | Provider;
}

/**
 * WalletLocked
 */
declare class WalletLocked extends BaseWalletLocked {
    unlock(privateKey: BytesLike): WalletUnlocked;
}
/**
 * WalletUnlocked
 */
declare class WalletUnlocked extends BaseWalletUnlocked {
    lock(): WalletLocked;
    /**
     * Generate a new Wallet Unlocked with a random keyPair
     *
     * @param options - GenerateOptions
     * @returns wallet - Wallet instance
     */
    static generate(generateOptions?: GenerateOptions): WalletUnlocked;
    /**
     * Create Wallet Unlocked from a seed
     */
    static fromSeed(seed: string, path?: string): WalletUnlocked;
    /**
     * Create Wallet Unlocked from mnemonic phrase
     */
    static fromMnemonic(mnemonic: string, path?: string, passphrase?: BytesLike): WalletUnlocked;
    /**
     * Create Wallet Unlocked from extended key
     */
    static fromExtendedKey(extendedKey: string): WalletUnlocked;
}

declare const seedWallet: (wallet: WalletUnlocked, quantities: CoinQuantityLike[]) => Promise<void>;
declare const generateTestWallet: (provider: Provider, quantities?: CoinQuantityLike[]) => Promise<WalletUnlocked>;

declare const testUtils_seedWallet: typeof seedWallet;
declare const testUtils_generateTestWallet: typeof generateTestWallet;
declare namespace testUtils {
  export {
    testUtils_seedWallet as seedWallet,
    testUtils_generateTestWallet as generateTestWallet,
  };
}

export { BaseWalletLocked as B, WalletLocked as W, WalletUnlocked as a, BaseWalletUnlocked as b, generateTestWallet as g, seedWallet as s, testUtils as t };
