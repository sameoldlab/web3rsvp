{"version":3,"sources":["../../../node_modules/.pnpm/tsup@5.12.9_mwhvu7sfp6vq5ryuwb6hlbjfka/node_modules/tsup/assets/esm_shims.js","../src/test-utils.ts","../../keystore/src/index.ts","../../keystore/src/keystore.ts","../../keystore/src/aes-ctr-node.ts","../../keystore/src/aes-ctr.ts","../../keystore/src/universal-crypto.ts","../../keystore/src/randomBytes.ts","../../keystore/src/aes-ctr-web.ts","../src/wallet.ts","../src/constants.ts","../src/wallets.ts","../src/base-locked-wallet.ts","../src/base-unlocked-wallet.ts"],"sourcesContent":["// Shim globals in esm bundle\nimport { fileURLToPath } from 'url'\nimport path from 'path'\n\nconst getFilename = () => fileURLToPath(import.meta.url)\nconst getDirname = () => path.dirname(getFilename())\n\nexport const __dirname = /* @__PURE__ */ getDirname()\nexport const __filename = /* @__PURE__ */ getFilename()\n","import { randomBytes } from '@fuel-ts/keystore';\nimport type { Provider, CoinQuantityLike } from '@fuel-ts/providers';\nimport { coinQuantityfy, ScriptTransactionRequest } from '@fuel-ts/providers';\n\nimport { Wallet } from './wallet';\nimport { WalletUnlocked } from './wallets';\n\nexport const seedWallet = async (wallet: WalletUnlocked, quantities: CoinQuantityLike[]) => {\n  const genesisWallet = new WalletUnlocked(\n    process.env.GENESIS_SECRET || randomBytes(32),\n    wallet.provider\n  );\n  // Connect to the same Provider as wallet\n  const resources = await genesisWallet.getResourcesToSpend(quantities);\n  // Create transaction\n  const request = new ScriptTransactionRequest({\n    gasLimit: 10000,\n    gasPrice: 1,\n  });\n  request.addResources(resources);\n  quantities\n    .map(coinQuantityfy)\n    .forEach(({ amount, assetId }) => request.addCoinOutput(wallet.address, amount, assetId));\n  const response = await genesisWallet.sendTransaction(request);\n\n  await response.wait();\n};\n\nexport const generateTestWallet = async (\n  provider: Provider,\n  quantities?: CoinQuantityLike[]\n): Promise<WalletUnlocked> => {\n  const wallet = Wallet.generate({ provider });\n  if (quantities) {\n    await seedWallet(wallet, quantities);\n  }\n  return wallet;\n};\n","export * from './keystore';\n","import type { Keystore } from './aes-ctr';\nimport { encrypt as encNode, decrypt as decNode } from './aes-ctr-node';\nimport { encrypt as encWeb, decrypt as decWeb } from './aes-ctr-web';\nimport { strategy } from './universal-crypto';\n\nexport type { Keystore } from './aes-ctr';\nexport { keyFromPassword } from './aes-ctr';\nexport { randomBytes } from './randomBytes';\n\n/**\n * Encrypts a data object that can be any serializable value using\n * a provided password.\n *\n * @returns Promise<Keystore> Keystore object\n */\nexport async function encrypt<T>(password: string, data: T): Promise<Keystore> {\n  return strategy === 'Node' ? encNode<T>(password, data) : encWeb<T>(password, data);\n}\n\n/**\n * Given a password and a keystore object, decrypts the text and returns\n * the resulting value\n *\n *  @returns Promise<T> T object\n */\nexport async function decrypt<T>(password: string, keystore: Keystore): Promise<T> {\n  return strategy === 'Node' ? decNode<T>(password, keystore) : decWeb<T>(password, keystore);\n}\n","import type { Keystore } from './aes-ctr';\nimport { bufferFromString, stringFromBuffer, keyFromPassword } from './aes-ctr';\nimport { randomBytes } from './randomBytes';\nimport { crypto } from './universal-crypto';\n\nconst ALGORITHM = 'aes-256-ctr';\n\n/**\n * Encrypts a data object that can be any serializable value using\n * a provided password.\n *\n * @returns Promise<Keystore> object\n */\nexport async function encrypt<T>(password: string, data: T): Promise<Keystore> {\n  const iv = randomBytes(16);\n  const salt = randomBytes(32);\n  const secret = keyFromPassword(password, salt);\n  const dataBuffer = Uint8Array.from(Buffer.from(JSON.stringify(data), 'utf-8'));\n\n  const cipher = crypto.createCipheriv(ALGORITHM, secret, iv);\n  let cipherData = cipher.update(dataBuffer);\n  cipherData = Buffer.concat([cipherData, cipher.final()]);\n\n  return {\n    data: stringFromBuffer(cipherData),\n    iv: stringFromBuffer(iv),\n    salt: stringFromBuffer(salt),\n  };\n}\n\n/**\n * Given a password and a keystore object, decrypts the text and returns\n * the resulting value\n */\nexport async function decrypt<T>(password: string, keystore: Keystore): Promise<T> {\n  const iv = bufferFromString(keystore.iv);\n  const salt = bufferFromString(keystore.salt);\n  const secret = keyFromPassword(password, salt);\n  const encryptedText = bufferFromString(keystore.data);\n\n  const decipher = crypto.createDecipheriv(ALGORITHM, secret, iv);\n  const decrypted = decipher.update(encryptedText);\n  const deBuff = Buffer.concat([decrypted, decipher.final()]);\n  const decryptedData = Buffer.from(deBuff).toString('utf-8');\n\n  try {\n    return JSON.parse(decryptedData);\n  } catch {\n    throw new Error('Invalid credentials');\n  }\n}\n","import { arrayify } from '@ethersproject/bytes';\nimport { pbkdf2 } from '@ethersproject/pbkdf2';\n\nimport { strategy } from './universal-crypto';\n\nexport interface Keystore {\n  data: string;\n  iv: string;\n  salt: string;\n}\n\nexport function bufferFromString(\n  string: string,\n  encoding: 'utf-8' | 'base64' = 'base64'\n): Uint8Array {\n  if (strategy === 'Node') {\n    return Buffer.from(string, encoding);\n  }\n  if (encoding === 'utf-8') {\n    return new TextEncoder().encode(string);\n  }\n\n  return new Uint8Array(\n    atob(string)\n      .split('')\n      .map((c) => c.charCodeAt(0))\n  );\n}\n\nexport function stringFromBuffer(\n  buffer: Uint8Array,\n  encoding: 'utf-8' | 'base64' = 'base64'\n): string {\n  if (strategy === 'Node') {\n    return Buffer.from(buffer).toString(encoding);\n  }\n\n  return btoa(String.fromCharCode.apply(null, new Uint8Array(buffer) as unknown as number[]));\n}\n\n/**\n * Generate a pbkdf2 key from a password and random salt\n */\nexport function keyFromPassword(password: string, saltBuffer: Uint8Array): Uint8Array {\n  const passBuffer = bufferFromString(String(password).normalize('NFKC'), 'utf-8');\n  const key = pbkdf2(passBuffer, saltBuffer, 100000, 32, 'sha256');\n\n  return arrayify(key);\n}\n","import type { createCipheriv, createDecipheriv } from 'crypto';\n\ntype UniversalCrypto = {\n  getRandomValues: (length: number) => Uint8Array;\n  randomBytes: (length: number) => Uint8Array;\n  subtle: SubtleCrypto;\n  createCipheriv: typeof createCipheriv;\n  createDecipheriv: typeof createDecipheriv;\n};\nlet selectedCrypto;\nlet selectedStrategy: 'Node' | 'Web' = 'Node';\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nif (typeof globalThis !== 'undefined' && globalThis.crypto) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  selectedCrypto = globalThis.crypto;\n  selectedStrategy = 'Web';\n}\n\nif (!selectedCrypto && typeof require === 'function') {\n  try {\n    // eslint-disable-next-line global-require\n    selectedCrypto = require('crypto');\n    selectedStrategy = 'Node';\n  } catch (error) {\n    // eslint-disable-next-line no-console\n    console.error('keystore expects a standard Web browser or Node environment.', error);\n  }\n}\n\nexport const crypto: UniversalCrypto = selectedCrypto;\nexport const strategy = selectedStrategy;\n","import { crypto, strategy } from './universal-crypto';\n\nexport const randomBytes = (length: number) =>\n  strategy === 'Node'\n    ? crypto.randomBytes(length)\n    : crypto.getRandomValues(new Uint8Array(length) as unknown as number);\n","import type { Keystore } from './aes-ctr';\nimport { bufferFromString, stringFromBuffer, keyFromPassword } from './aes-ctr';\nimport { randomBytes } from './randomBytes';\nimport { crypto } from './universal-crypto';\n\nconst ALGORITHM = 'AES-CTR';\n\n/**\n * Encrypts a data object that can be any serializable value using\n * a provided password.\n *\n * @returns Promise<Keystore> object\n */\nexport async function encrypt<T>(password: string, data: T): Promise<Keystore> {\n  const iv = randomBytes(16);\n  const salt = randomBytes(32);\n  const secret = keyFromPassword(password, salt);\n  const dataBuffer = Uint8Array.from(Buffer.from(JSON.stringify(data), 'utf-8'));\n  const alg = {\n    name: ALGORITHM,\n    counter: iv,\n    length: 64,\n  };\n  const key = await crypto.subtle.importKey('raw', secret, alg, false, ['encrypt']);\n  const encBuffer = await crypto.subtle.encrypt(alg, key, dataBuffer);\n\n  return {\n    data: stringFromBuffer(encBuffer),\n    iv: stringFromBuffer(iv),\n    salt: stringFromBuffer(salt),\n  };\n}\n\n/**\n * Given a password and a keystore object, decrypts the text and returns\n * the resulting value\n */\nexport async function decrypt<T>(password: string, keystore: Keystore): Promise<T> {\n  const iv = bufferFromString(keystore.iv);\n  const salt = bufferFromString(keystore.salt);\n  const secret = keyFromPassword(password, salt);\n  const encryptedText = bufferFromString(keystore.data);\n\n  const alg = {\n    name: ALGORITHM,\n    counter: iv,\n    length: 64,\n  };\n  const key = await crypto.subtle.importKey('raw', secret, alg, false, ['decrypt']);\n\n  const ptBuffer = await crypto.subtle.decrypt(alg, key, encryptedText);\n  const decryptedData = new TextDecoder().decode(ptBuffer);\n\n  try {\n    return JSON.parse(decryptedData);\n  } catch {\n    throw new Error('Invalid credentials');\n  }\n}\n","import type { BytesLike } from '@ethersproject/bytes';\nimport type { AbstractAddress } from '@fuel-ts/interfaces';\nimport type { Provider } from '@fuel-ts/providers';\n\nimport { FUEL_NETWORK_URL } from './constants';\nimport { WalletLocked, WalletUnlocked } from './wallets';\n\nexport class Wallet {\n  static fromAddress(\n    address: string | AbstractAddress,\n    provider: string | Provider = FUEL_NETWORK_URL\n  ): WalletLocked {\n    return new WalletLocked(address, provider);\n  }\n\n  static fromPrivateKey(privateKey: BytesLike, provider: string | Provider = FUEL_NETWORK_URL) {\n    return new WalletUnlocked(privateKey, provider);\n  }\n\n  static generate = WalletUnlocked.generate;\n  static fromSeed = WalletUnlocked.fromSeed;\n  static fromMnemonic = WalletUnlocked.fromMnemonic;\n  static fromExtendedKey = WalletUnlocked.fromExtendedKey;\n}\n","// TODO: import using .env file\nexport const FUEL_NETWORK_URL = 'http://127.0.0.1:4000/graphql';\n","//\n// Because WalletLocked and WalletUnlocked has a cycle dependency\n// it's not possible to split the two classes in different files\n//\n/* eslint-disable max-classes-per-file */\nimport type { BytesLike } from '@ethersproject/bytes';\nimport { HDWallet } from '@fuel-ts/hdwallet';\nimport { Mnemonic } from '@fuel-ts/mnemonic';\nimport { Signer } from '@fuel-ts/signer';\n\nimport { BaseWalletLocked } from './base-locked-wallet';\nimport { BaseWalletUnlocked } from './base-unlocked-wallet';\nimport type { GenerateOptions } from './types/GenerateOptions';\n\n/**\n * WalletLocked\n */\nexport class WalletLocked extends BaseWalletLocked {\n  unlock(privateKey: BytesLike) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new WalletUnlocked(privateKey, this.provider);\n  }\n}\n\n/**\n * WalletUnlocked\n */\nexport class WalletUnlocked extends BaseWalletUnlocked {\n  lock(): WalletLocked {\n    this.signer = () => new Signer('0x00');\n    return new WalletLocked(this.address, this.provider);\n  }\n\n  /**\n   * Generate a new Wallet Unlocked with a random keyPair\n   *\n   * @param options - GenerateOptions\n   * @returns wallet - Wallet instance\n   */\n  static generate(generateOptions?: GenerateOptions): WalletUnlocked {\n    const privateKey = Signer.generatePrivateKey(generateOptions?.entropy);\n\n    return new WalletUnlocked(privateKey, generateOptions?.provider);\n  }\n\n  /**\n   * Create Wallet Unlocked from a seed\n   */\n  static fromSeed(seed: string, path?: string): WalletUnlocked {\n    const hdWallet = HDWallet.fromSeed(seed);\n    const childWallet = hdWallet.derivePath(path || WalletUnlocked.defaultPath);\n\n    return new WalletUnlocked(<string>childWallet.privateKey);\n  }\n\n  /**\n   * Create Wallet Unlocked from mnemonic phrase\n   */\n  static fromMnemonic(mnemonic: string, path?: string, passphrase?: BytesLike): WalletUnlocked {\n    const seed = Mnemonic.mnemonicToSeed(mnemonic, passphrase);\n    const hdWallet = HDWallet.fromSeed(seed);\n    const childWallet = hdWallet.derivePath(path || WalletUnlocked.defaultPath);\n\n    return new WalletUnlocked(<string>childWallet.privateKey);\n  }\n\n  /**\n   * Create Wallet Unlocked from extended key\n   */\n  static fromExtendedKey(extendedKey: string): WalletUnlocked {\n    const hdWallet = HDWallet.fromExtendedKey(extendedKey);\n\n    return new WalletUnlocked(<string>hdWallet.privateKey);\n  }\n}\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport type { InputValue } from '@fuel-ts/abi-coder';\nimport { Address, addressify } from '@fuel-ts/address';\nimport { NativeAssetId } from '@fuel-ts/constants';\nimport { AbstractWallet } from '@fuel-ts/interfaces';\nimport type { AbstractAddress, AbstractPredicate } from '@fuel-ts/interfaces';\nimport type { BigNumberish, BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport type {\n  TransactionResponse,\n  TransactionRequestLike,\n  CallResult,\n  TransactionRequest,\n  Coin,\n  CoinQuantityLike,\n  CoinQuantity,\n  BuildPredicateOptions,\n  TransactionResult,\n  Message,\n  Resource,\n  ExcludeResourcesOption,\n} from '@fuel-ts/providers';\nimport {\n  withdrawScript,\n  ScriptTransactionRequest,\n  Provider,\n  transactionRequestify,\n} from '@fuel-ts/providers';\nimport { MAX_GAS_PER_TX } from '@fuel-ts/transactions';\n\nimport { FUEL_NETWORK_URL } from './constants';\n\n/**\n * BaseWallet\n */\nexport class BaseWalletLocked extends AbstractWallet {\n  private readonly _address: AbstractAddress;\n\n  provider: Provider;\n\n  constructor(publicKey: string | AbstractAddress, provider: string | Provider = FUEL_NETWORK_URL) {\n    super();\n    this.provider = this.connect(provider);\n    if (typeof publicKey === 'string') {\n      this._address = Address.fromString(publicKey);\n    } else {\n      this._address = addressify(publicKey);\n    }\n  }\n\n  get address(): AbstractAddress {\n    return this._address;\n  }\n\n  /**\n   * Change provider connection\n   */\n  connect(provider: string | Provider) {\n    if (!provider) {\n      throw new Error('Provider is required');\n    } else if (typeof provider === 'string') {\n      this.provider = new Provider(provider);\n    } else {\n      this.provider = provider;\n    }\n    return this.provider;\n  }\n\n  /**\n   * Returns resources satisfying the spend query.\n   */\n  async getResourcesToSpend(\n    quantities: CoinQuantityLike[] /** IDs of coins to exclude */,\n    excludedIds?: ExcludeResourcesOption\n  ): Promise<Resource[]> {\n    return this.provider.getResourcesToSpend(this.address, quantities, excludedIds);\n  }\n\n  /**\n   * Gets coins owned by the wallet address.\n   */\n  async getCoins(): Promise<Coin[]> {\n    const coins = [];\n\n    const pageSize = 9999;\n    let cursor;\n    // eslint-disable-next-line no-unreachable-loop\n    for (;;) {\n      const pageCoins = await this.provider.getCoins(this.address, undefined, {\n        first: pageSize,\n        after: cursor,\n      });\n\n      coins.push(...pageCoins);\n\n      const hasNextPage = pageCoins.length >= pageSize;\n      if (!hasNextPage) {\n        break;\n      }\n\n      // TODO: implement pagination\n      throw new Error(`Wallets with more than ${pageSize} coins are not yet supported`);\n    }\n\n    return coins;\n  }\n\n  /**\n   * Gets messages owned by the wallet address.\n   */\n  async getMessages(): Promise<Message[]> {\n    const messages = [];\n\n    const pageSize = 9999;\n    let cursor;\n    // eslint-disable-next-line no-unreachable-loop\n    for (;;) {\n      const pageMessages = await this.provider.getMessages(this.address, {\n        first: pageSize,\n        after: cursor,\n      });\n\n      messages.push(...pageMessages);\n\n      const hasNextPage = pageMessages.length >= pageSize;\n      if (!hasNextPage) {\n        break;\n      }\n\n      // TODO: implement pagination\n      throw new Error(`Wallets with more than ${pageSize} messages are not yet supported`);\n    }\n\n    return messages;\n  }\n\n  /**\n   * Gets balance for the given asset.\n   */\n  async getBalance(assetId: BytesLike = NativeAssetId): Promise<BN> {\n    const amount = await this.provider.getBalance(this.address, assetId);\n    return amount;\n  }\n\n  /**\n   * Gets balances.\n   */\n  async getBalances(): Promise<CoinQuantity[]> {\n    const balances = [];\n\n    const pageSize = 9999;\n    let cursor;\n    // eslint-disable-next-line no-unreachable-loop\n    for (;;) {\n      const pageBalances = await this.provider.getBalances(this.address, {\n        first: pageSize,\n        after: cursor,\n      });\n\n      balances.push(...pageBalances);\n\n      const hasNextPage = pageBalances.length >= pageSize;\n      if (!hasNextPage) {\n        break;\n      }\n\n      // TODO: implement pagination\n      throw new Error(`Wallets with more than ${pageSize} balances are not yet supported`);\n    }\n\n    return balances;\n  }\n\n  /**\n   * Adds resources to the transaction enough to fund it.\n   */\n  async fund<T extends TransactionRequest>(request: T): Promise<void> {\n    const fee = request.calculateFee();\n    const resources = await this.getResourcesToSpend([fee]);\n\n    request.addResources(resources);\n  }\n\n  /**\n   * Returns coins satisfying the spend query.\n   */\n  async transfer(\n    /** Address of the destination */\n    destination: AbstractAddress,\n    /** Amount of coins */\n    amount: BigNumberish,\n    /** Asset ID of coins */\n    assetId: BytesLike = NativeAssetId,\n    /** Tx Params */\n    txParams: Pick<TransactionRequestLike, 'gasLimit' | 'gasPrice' | 'maturity'> = {}\n  ): Promise<TransactionResponse> {\n    const params = { gasLimit: MAX_GAS_PER_TX, ...txParams };\n    const request = new ScriptTransactionRequest(params);\n    request.addCoinOutput(destination, amount, assetId);\n    const fee = request.calculateFee();\n    let quantities: CoinQuantityLike[] = [];\n    if (fee.assetId === hexlify(assetId)) {\n      fee.amount.add(amount);\n      quantities = [fee];\n    } else {\n      quantities = [[amount, assetId], fee];\n    }\n    const resources = await this.getResourcesToSpend(quantities);\n    request.addResources(resources);\n\n    return this.sendTransaction(request);\n  }\n\n  /**\n   * Withdraws an amount of the base asset to the base chain.\n   */\n  async withdrawToBaseLayer(\n    /** Address of the recipient on the base chain */\n    recipient: AbstractAddress,\n    /** Amount of base asset */\n    amount: BigNumberish,\n    /** Tx Params */\n    txParams: Pick<TransactionRequestLike, 'gasLimit' | 'gasPrice' | 'maturity'> = {}\n  ): Promise<TransactionResponse> {\n    // add recipient and amount to the transaction script code\n    const recipientDataArray = arrayify(\n      '0x'.concat(recipient.toHexString().substring(2).padStart(64, '0'))\n    );\n    const amountDataArray = arrayify(\n      '0x'.concat(bn(amount).toHex().substring(2).padStart(16, '0'))\n    );\n    const script = new Uint8Array([\n      ...arrayify(withdrawScript.bytes),\n      ...recipientDataArray,\n      ...amountDataArray,\n    ]);\n\n    // build the transaction\n    const params = { script, gasLimit: MAX_GAS_PER_TX, ...txParams };\n    const request = new ScriptTransactionRequest(params);\n    request.addMessageOutputs();\n    const fee = request.calculateFee();\n    let quantities: CoinQuantityLike[] = [];\n    fee.amount.add(amount);\n    quantities = [fee];\n    const resources = await this.getResourcesToSpend(quantities);\n    request.addResources(resources);\n\n    return this.sendTransaction(request);\n  }\n\n  /**\n   * Populates witnesses signature and send it to the network using `provider.sendTransaction`.\n   *\n   * @param transactionRequest - TransactionRequest\n   * @returns TransactionResponse\n   */\n  async sendTransaction(\n    transactionRequestLike: TransactionRequestLike\n  ): Promise<TransactionResponse> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    await this.provider.addMissingVariables(transactionRequest);\n    return this.provider.sendTransaction(transactionRequest);\n  }\n\n  /**\n   * Populates witnesses signature and send a call it to the network using `provider.call`.\n   *\n   * @param transactionRequest - TransactionRequest\n   * @returns CallResult\n   */\n  async simulateTransaction(transactionRequestLike: TransactionRequestLike): Promise<CallResult> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    await this.provider.addMissingVariables(transactionRequest);\n    return this.provider.simulate(transactionRequest);\n  }\n\n  async buildPredicateTransaction(\n    predicateAddress: AbstractAddress,\n    amountToPredicate: BigNumberish,\n    assetId: BytesLike = NativeAssetId,\n    predicateOptions?: BuildPredicateOptions\n  ): Promise<ScriptTransactionRequest> {\n    const options = {\n      fundTransaction: true,\n      ...predicateOptions,\n    };\n    const request = new ScriptTransactionRequest({\n      gasLimit: MAX_GAS_PER_TX,\n      ...options,\n    });\n\n    // output is locked behind predicate\n    request.addCoinOutput(predicateAddress, amountToPredicate, assetId);\n\n    const requiredCoinQuantities: CoinQuantityLike[] = [];\n    if (options.fundTransaction) {\n      requiredCoinQuantities.push(request.calculateFee());\n    }\n\n    if (requiredCoinQuantities.length) {\n      const resources = await this.getResourcesToSpend(requiredCoinQuantities);\n      request.addResources(resources);\n    }\n\n    return request;\n  }\n\n  async submitPredicate(\n    predicateAddress: AbstractAddress,\n    amountToPredicate: BigNumberish,\n    assetId: BytesLike = NativeAssetId,\n    options?: BuildPredicateOptions\n  ): Promise<TransactionResult<'success'>> {\n    const request = await this.buildPredicateTransaction(\n      predicateAddress,\n      amountToPredicate,\n      assetId,\n      options\n    );\n    const response = await this.sendTransaction(request);\n    return response.waitForResult();\n  }\n\n  async submitSpendPredicate(\n    predicate: AbstractPredicate,\n    amountToSpend: BigNumberish,\n    predicateData?: InputValue[],\n    assetId: BytesLike = NativeAssetId,\n    options?: BuildPredicateOptions\n  ): Promise<TransactionResult<'success'>> {\n    return this.provider.submitSpendPredicate(\n      predicate,\n      amountToSpend,\n      this.address,\n      predicateData,\n      assetId,\n      options\n    );\n  }\n}\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { hashMessage, hashTransaction } from '@fuel-ts/hasher';\nimport type {\n  TransactionResponse,\n  TransactionRequestLike,\n  CallResult,\n  Provider,\n} from '@fuel-ts/providers';\nimport { transactionRequestify } from '@fuel-ts/providers';\nimport { Signer } from '@fuel-ts/signer';\n\nimport { BaseWalletLocked } from './base-locked-wallet';\nimport { FUEL_NETWORK_URL } from './constants';\n\n/**\n * BaseWalletUnlocked\n */\nexport class BaseWalletUnlocked extends BaseWalletLocked {\n  /* default HDWallet path */\n  static defaultPath = \"m/44'/1179993420'/0'/0/0\";\n\n  provider: Provider;\n\n  signer: () => Signer;\n\n  constructor(privateKey: BytesLike, provider: string | Provider = FUEL_NETWORK_URL) {\n    const signer = new Signer(privateKey);\n    super(signer.address, provider);\n    this.signer = () => signer;\n    this.provider = this.connect(provider);\n  }\n\n  get privateKey(): string {\n    return this.signer().privateKey;\n  }\n\n  get publicKey(): string {\n    return this.signer().publicKey;\n  }\n\n  /**\n   * Sign message with wallet instance privateKey\n   *\n   * @param message - Message\n   * @returns Promise<string> - Signature a ECDSA 64 bytes\n   */\n  async signMessage(message: string): Promise<string> {\n    return this.signer().sign(hashMessage(message));\n  }\n\n  /**\n   * Sign transaction with wallet instance privateKey\n   *\n   * @param transactionRequestLike - TransactionRequestLike\n   * @returns string - Signature a ECDSA 64 bytes\n   */\n  async signTransaction(transactionRequestLike: TransactionRequestLike): Promise<string> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    const hashedTransaction = hashTransaction(transactionRequest);\n    const signature = this.signer().sign(hashedTransaction);\n\n    return signature;\n  }\n\n  async populateTransactionWitnessesSignature(transactionRequestLike: TransactionRequestLike) {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    const signedTransaction = await this.signTransaction(transactionRequest);\n\n    transactionRequest.updateWitnessByOwner(this.address, signedTransaction);\n\n    return transactionRequest;\n  }\n\n  /**\n   * Populates witnesses signature and send it to the network using `provider.sendTransaction`.\n   *\n   * @param transactionRequest - TransactionRequest\n   * @returns TransactionResponse\n   */\n  async sendTransaction(\n    transactionRequestLike: TransactionRequestLike\n  ): Promise<TransactionResponse> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    await this.provider.addMissingVariables(transactionRequest);\n    return this.provider.sendTransaction(\n      await this.populateTransactionWitnessesSignature(transactionRequest)\n    );\n  }\n\n  /**\n   * Populates witnesses signature and send a call it to the network using `provider.call`.\n   *\n   * @param transactionRequest - TransactionRequest\n   * @returns CallResult\n   */\n  async simulateTransaction(transactionRequestLike: TransactionRequestLike): Promise<CallResult> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    await this.provider.addMissingVariables(transactionRequest);\n    return this.provider.call(\n      await this.populateTransactionWitnessesSignature(transactionRequest),\n      {\n        utxoValidation: true,\n      }\n    );\n  }\n}\n"],"mappings":"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","names":["init_esm_shims","__esmMin","init_esm_shims","init_esm_shims","init_esm_shims","init_esm_shims","init_esm_shims","arrayify","init_esm_shims","selectedCrypto","selectedStrategy","__require","error","crypto","strategy","init_esm_shims","randomBytes","length","strategy","crypto","init_esm_shims","coinQuantityfy","ScriptTransactionRequest","init_esm_shims","init_esm_shims","FUEL_NETWORK_URL","init_esm_shims","HDWallet","Mnemonic","Signer","init_esm_shims","arrayify","hexlify","Address","addressify","NativeAssetId","AbstractWallet","bn","withdrawScript","ScriptTransactionRequest","Provider","transactionRequestify","MAX_GAS_PER_TX","BaseWalletLocked","AbstractWallet","publicKey","provider","FUEL_NETWORK_URL","Address","addressify","Provider","quantities","excludedIds","coins","cursor","pageCoins","messages","pageMessages","assetId","NativeAssetId","balances","pageBalances","request","fee","resources","destination","amount","txParams","params","MAX_GAS_PER_TX","ScriptTransactionRequest","hexlify","recipient","recipientDataArray","arrayify","amountDataArray","bn","withdrawScript","transactionRequestLike","transactionRequest","transactionRequestify","predicateAddress","amountToPredicate","predicateOptions","options","requiredCoinQuantities","predicate","amountToSpend","predicateData","init_esm_shims","hashMessage","hashTransaction","transactionRequestify","Signer","BaseWalletUnlocked","BaseWalletLocked","privateKey","provider","FUEL_NETWORK_URL","signer","Signer","message","hashMessage","transactionRequestLike","transactionRequest","transactionRequestify","hashedTransaction","hashTransaction","signedTransaction","WalletLocked","BaseWalletLocked","privateKey","WalletUnlocked","BaseWalletUnlocked","Signer","generateOptions","seed","path","childWallet","HDWallet","mnemonic","passphrase","Mnemonic","extendedKey","hdWallet","Wallet","address","provider","FUEL_NETWORK_URL","WalletLocked","privateKey","WalletUnlocked","seedWallet","wallet","quantities","genesisWallet","WalletUnlocked","randomBytes","resources","request","ScriptTransactionRequest","coinQuantityfy","amount","assetId","generateTestWallet","provider","Wallet"]}