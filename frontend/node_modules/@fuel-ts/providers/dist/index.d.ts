import { BytesLike } from '@ethersproject/bytes';
import { BigNumberish, BN } from '@fuel-ts/math';
import { AbstractAddress, AbstractScript, ContractIdLike, AddressLike, AbstractPredicate } from '@fuel-ts/interfaces';
import { GraphQLClient } from 'graphql-request';
import * as Dom from 'graphql-request/dist/types.dom';
import { Network } from '@ethersproject/networks';
import { InputValue } from '@fuel-ts/abi-coder';
import { InputType, Input, OutputType, Output, TransactionType, Transaction, ReceiptCall, ReceiptReturn, ReceiptReturnData, ReceiptPanic, ReceiptRevert, ReceiptLog, ReceiptLogData, ReceiptTransfer, ReceiptTransferOut, ReceiptScriptResult, ReceiptMessageOut } from '@fuel-ts/transactions';
export { TransactionType } from '@fuel-ts/transactions';

declare type CoinQuantityLike = [amount: BigNumberish, assetId?: BytesLike, max?: BigNumberish] | {
    amount: BigNumberish;
    assetId?: BytesLike;
    max?: BigNumberish;
};
declare type CoinQuantity = {
    amount: BN;
    assetId: string;
    max?: BN;
};
declare const coinQuantityfy: (coinQuantityLike: CoinQuantityLike) => CoinQuantity;

declare type Maybe<T> = T | null;
declare type InputMaybe<T> = Maybe<T>;
declare type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
/** All built-in and custom scalars, mapped to their actual values */
declare type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    Address: string;
    AssetId: string;
    BlockId: string;
    Bytes32: string;
    ContractId: string;
    /**
     * Implement the DateTime<Utc> scalar
     *
     * The input/output is a string in RFC3339 format.
     */
    DateTime: string;
    HexString: string;
    MessageId: any;
    Salt: string;
    Signature: any;
    TransactionId: string;
    TxPointer: any;
    U64: string;
    UtxoId: string;
};
declare type GqlBalanceFilterInput = {
    /** Filter coins based on the `owner` field */
    owner: Scalars['Address'];
};
declare type GqlCoinFilterInput = {
    /** Asset ID of the coins */
    assetId?: InputMaybe<Scalars['AssetId']>;
    /** Address of the owner */
    owner: Scalars['Address'];
};
declare enum GqlCoinStatus {
    Spent = "SPENT",
    Unspent = "UNSPENT"
}
declare type GqlExcludeInput = {
    /** Messages to exclude from the selection. */
    messages: Array<Scalars['MessageId']>;
    /** Utxos to exclude from the selection. */
    utxos: Array<Scalars['UtxoId']>;
};
declare enum GqlReturnType {
    Return = "RETURN",
    ReturnData = "RETURN_DATA",
    Revert = "REVERT"
}
declare type GqlSpendQueryElementInput = {
    /** Target amount for the query. */
    amount: Scalars['U64'];
    /** Identifier of the asset to spend. */
    assetId: Scalars['AssetId'];
    /** The maximum number of currencies for selection. */
    max?: InputMaybe<Scalars['U64']>;
};
declare type GqlGetVersionQueryVariables = Exact<{
    [key: string]: never;
}>;
declare type GqlGetVersionQuery = {
    __typename: 'Query';
    nodeInfo: {
        __typename: 'NodeInfo';
        nodeVersion: string;
    };
};
declare type GqlGetInfoQueryVariables = Exact<{
    [key: string]: never;
}>;
declare type GqlGetInfoQuery = {
    __typename: 'Query';
    nodeInfo: {
        __typename: 'NodeInfo';
        nodeVersion: string;
        minGasPrice: string;
    };
};
declare type GqlGetChainQueryVariables = Exact<{
    [key: string]: never;
}>;
declare type GqlGetChainQuery = {
    __typename: 'Query';
    chain: {
        __typename: 'ChainInfo';
        name: string;
        baseChainHeight: string;
        peerCount: number;
        consensusParameters: {
            __typename: 'ConsensusParameters';
            gasPriceFactor: string;
            maxGasPerTx: string;
            maxScriptLength: string;
        };
        latestBlock: {
            __typename: 'Block';
            id: string;
            header: {
                __typename: 'Header';
                height: string;
                time: string;
            };
            transactions: Array<{
                __typename: 'Transaction';
                id: string;
            }>;
        };
    };
};
declare type GqlGetTransactionQueryVariables = Exact<{
    transactionId: Scalars['TransactionId'];
}>;
declare type GqlGetTransactionQuery = {
    __typename: 'Query';
    transaction?: {
        __typename: 'Transaction';
        id: string;
        rawPayload: string;
        gasPrice?: string | null;
        status?: {
            __typename: 'FailureStatus';
            time: string;
            reason: string;
            type: 'FailureStatus';
            block: {
                __typename: 'Block';
                id: string;
            };
        } | {
            __typename: 'SubmittedStatus';
            time: string;
            type: 'SubmittedStatus';
        } | {
            __typename: 'SuccessStatus';
            time: string;
            type: 'SuccessStatus';
            block: {
                __typename: 'Block';
                id: string;
            };
            programState?: {
                __typename: 'ProgramState';
                returnType: GqlReturnType;
                data: string;
            } | null;
        } | null;
    } | null;
};
declare type GqlGetTransactionWithReceiptsQueryVariables = Exact<{
    transactionId: Scalars['TransactionId'];
}>;
declare type GqlGetTransactionWithReceiptsQuery = {
    __typename: 'Query';
    transaction?: {
        __typename: 'Transaction';
        id: string;
        rawPayload: string;
        gasPrice?: string | null;
        receipts?: Array<{
            __typename: 'Receipt';
            data?: string | null;
            rawPayload: string;
        }> | null;
        status?: {
            __typename: 'FailureStatus';
            time: string;
            reason: string;
            type: 'FailureStatus';
            block: {
                __typename: 'Block';
                id: string;
            };
        } | {
            __typename: 'SubmittedStatus';
            time: string;
            type: 'SubmittedStatus';
        } | {
            __typename: 'SuccessStatus';
            time: string;
            type: 'SuccessStatus';
            block: {
                __typename: 'Block';
                id: string;
            };
            programState?: {
                __typename: 'ProgramState';
                returnType: GqlReturnType;
                data: string;
            } | null;
        } | null;
    } | null;
};
declare type GqlGetTransactionsQueryVariables = Exact<{
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
}>;
declare type GqlGetTransactionsQuery = {
    __typename: 'Query';
    transactions: {
        __typename: 'TransactionConnection';
        edges: Array<{
            __typename: 'TransactionEdge';
            node: {
                __typename: 'Transaction';
                id: string;
                rawPayload: string;
                gasPrice?: string | null;
                status?: {
                    __typename: 'FailureStatus';
                    time: string;
                    reason: string;
                    type: 'FailureStatus';
                    block: {
                        __typename: 'Block';
                        id: string;
                    };
                } | {
                    __typename: 'SubmittedStatus';
                    time: string;
                    type: 'SubmittedStatus';
                } | {
                    __typename: 'SuccessStatus';
                    time: string;
                    type: 'SuccessStatus';
                    block: {
                        __typename: 'Block';
                        id: string;
                    };
                    programState?: {
                        __typename: 'ProgramState';
                        returnType: GqlReturnType;
                        data: string;
                    } | null;
                } | null;
            };
        }>;
    };
};
declare type GqlGetTransactionsByOwnerQueryVariables = Exact<{
    owner: Scalars['Address'];
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
}>;
declare type GqlGetTransactionsByOwnerQuery = {
    __typename: 'Query';
    transactionsByOwner: {
        __typename: 'TransactionConnection';
        edges: Array<{
            __typename: 'TransactionEdge';
            node: {
                __typename: 'Transaction';
                id: string;
                rawPayload: string;
                gasPrice?: string | null;
                status?: {
                    __typename: 'FailureStatus';
                    time: string;
                    reason: string;
                    type: 'FailureStatus';
                    block: {
                        __typename: 'Block';
                        id: string;
                    };
                } | {
                    __typename: 'SubmittedStatus';
                    time: string;
                    type: 'SubmittedStatus';
                } | {
                    __typename: 'SuccessStatus';
                    time: string;
                    type: 'SuccessStatus';
                    block: {
                        __typename: 'Block';
                        id: string;
                    };
                    programState?: {
                        __typename: 'ProgramState';
                        returnType: GqlReturnType;
                        data: string;
                    } | null;
                } | null;
            };
        }>;
    };
};
declare type GqlGetBlockQueryVariables = Exact<{
    blockId?: InputMaybe<Scalars['BlockId']>;
    blockHeight?: InputMaybe<Scalars['U64']>;
}>;
declare type GqlGetBlockQuery = {
    __typename: 'Query';
    block?: {
        __typename: 'Block';
        id: string;
        header: {
            __typename: 'Header';
            height: string;
            time: string;
        };
        transactions: Array<{
            __typename: 'Transaction';
            id: string;
        }>;
    } | null;
};
declare type GqlGetBlockWithTransactionsQueryVariables = Exact<{
    blockId?: InputMaybe<Scalars['BlockId']>;
    blockHeight?: InputMaybe<Scalars['U64']>;
}>;
declare type GqlGetBlockWithTransactionsQuery = {
    __typename: 'Query';
    block?: {
        __typename: 'Block';
        id: string;
        transactions: Array<{
            __typename: 'Transaction';
            id: string;
            rawPayload: string;
            gasPrice?: string | null;
            status?: {
                __typename: 'FailureStatus';
                time: string;
                reason: string;
                type: 'FailureStatus';
                block: {
                    __typename: 'Block';
                    id: string;
                };
            } | {
                __typename: 'SubmittedStatus';
                time: string;
                type: 'SubmittedStatus';
            } | {
                __typename: 'SuccessStatus';
                time: string;
                type: 'SuccessStatus';
                block: {
                    __typename: 'Block';
                    id: string;
                };
                programState?: {
                    __typename: 'ProgramState';
                    returnType: GqlReturnType;
                    data: string;
                } | null;
            } | null;
        }>;
        header: {
            __typename: 'Header';
            height: string;
            time: string;
        };
    } | null;
};
declare type GqlGetBlocksQueryVariables = Exact<{
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
}>;
declare type GqlGetBlocksQuery = {
    __typename: 'Query';
    blocks: {
        __typename: 'BlockConnection';
        edges: Array<{
            __typename: 'BlockEdge';
            node: {
                __typename: 'Block';
                id: string;
                header: {
                    __typename: 'Header';
                    height: string;
                    time: string;
                };
                transactions: Array<{
                    __typename: 'Transaction';
                    id: string;
                }>;
            };
        }>;
    };
};
declare type GqlGetCoinQueryVariables = Exact<{
    coinId: Scalars['UtxoId'];
}>;
declare type GqlGetCoinQuery = {
    __typename: 'Query';
    coin?: {
        __typename: 'Coin';
        utxoId: string;
        owner: string;
        amount: string;
        assetId: string;
        maturity: string;
        status: GqlCoinStatus;
        blockCreated: string;
    } | null;
};
declare type GqlGetCoinsQueryVariables = Exact<{
    filter: GqlCoinFilterInput;
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
}>;
declare type GqlGetCoinsQuery = {
    __typename: 'Query';
    coins: {
        __typename: 'CoinConnection';
        edges: Array<{
            __typename: 'CoinEdge';
            node: {
                __typename: 'Coin';
                utxoId: string;
                owner: string;
                amount: string;
                assetId: string;
                maturity: string;
                status: GqlCoinStatus;
                blockCreated: string;
            };
        }>;
    };
};
declare type GqlGetResourcesToSpendQueryVariables = Exact<{
    owner: Scalars['Address'];
    queryPerAsset: Array<GqlSpendQueryElementInput> | GqlSpendQueryElementInput;
    excludedIds?: InputMaybe<GqlExcludeInput>;
}>;
declare type GqlGetResourcesToSpendQuery = {
    __typename: 'Query';
    resourcesToSpend: Array<Array<{
        __typename: 'Coin';
        utxoId: string;
        owner: string;
        amount: string;
        assetId: string;
        maturity: string;
        status: GqlCoinStatus;
        blockCreated: string;
    } | {
        __typename: 'Message';
        amount: string;
        sender: string;
        recipient: string;
        data: string;
        nonce: string;
        daHeight: string;
        fuelBlockSpend?: string | null;
    }>>;
};
declare type GqlGetContractQueryVariables = Exact<{
    contractId: Scalars['ContractId'];
}>;
declare type GqlGetContractQuery = {
    __typename: 'Query';
    contract?: {
        __typename: 'Contract';
        bytecode: string;
        id: string;
    } | null;
};
declare type GqlGetBalanceQueryVariables = Exact<{
    owner: Scalars['Address'];
    assetId: Scalars['AssetId'];
}>;
declare type GqlGetBalanceQuery = {
    __typename: 'Query';
    balance: {
        __typename: 'Balance';
        owner: string;
        amount: string;
        assetId: string;
    };
};
declare type GqlGetBalancesQueryVariables = Exact<{
    filter: GqlBalanceFilterInput;
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
}>;
declare type GqlGetBalancesQuery = {
    __typename: 'Query';
    balances: {
        __typename: 'BalanceConnection';
        edges: Array<{
            __typename: 'BalanceEdge';
            node: {
                __typename: 'Balance';
                owner: string;
                amount: string;
                assetId: string;
            };
        }>;
    };
};
declare type GqlGetMessagesQueryVariables = Exact<{
    owner: Scalars['Address'];
    after?: InputMaybe<Scalars['String']>;
    before?: InputMaybe<Scalars['String']>;
    first?: InputMaybe<Scalars['Int']>;
    last?: InputMaybe<Scalars['Int']>;
}>;
declare type GqlGetMessagesQuery = {
    __typename: 'Query';
    messages: {
        __typename: 'MessageConnection';
        edges: Array<{
            __typename: 'MessageEdge';
            node: {
                __typename: 'Message';
                amount: string;
                sender: string;
                recipient: string;
                data: string;
                nonce: string;
                daHeight: string;
                fuelBlockSpend?: string | null;
            };
        }>;
    };
};
declare type GqlGetMessageProofQueryVariables = Exact<{
    transactionId: Scalars['TransactionId'];
    messageId: Scalars['MessageId'];
}>;
declare type GqlGetMessageProofQuery = {
    __typename: 'Query';
    messageProof?: {
        __typename: 'MessageProof';
        proofSet: Array<string>;
        proofIndex: string;
        sender: string;
        recipient: string;
        nonce: string;
        amount: string;
        data: string;
        signature: any;
        header: {
            __typename: 'Header';
            id: string;
            daHeight: string;
            transactionsCount: string;
            outputMessagesCount: string;
            transactionsRoot: string;
            outputMessagesRoot: string;
            height: string;
            prevRoot: string;
            time: string;
            applicationHash: string;
        };
    } | null;
};
declare type GqlDryRunMutationVariables = Exact<{
    encodedTransaction: Scalars['HexString'];
    utxoValidation?: InputMaybe<Scalars['Boolean']>;
}>;
declare type GqlDryRunMutation = {
    __typename: 'Mutation';
    dryRun: Array<{
        __typename: 'Receipt';
        data?: string | null;
        rawPayload: string;
    }>;
};
declare type GqlSubmitMutationVariables = Exact<{
    encodedTransaction: Scalars['HexString'];
}>;
declare type GqlSubmitMutation = {
    __typename: 'Mutation';
    submit: {
        __typename: 'Transaction';
        id: string;
    };
};
declare type GqlStartSessionMutationVariables = Exact<{
    [key: string]: never;
}>;
declare type GqlStartSessionMutation = {
    __typename: 'Mutation';
    startSession: string;
};
declare type GqlEndSessionMutationVariables = Exact<{
    sessionId: Scalars['ID'];
}>;
declare type GqlEndSessionMutation = {
    __typename: 'Mutation';
    endSession: boolean;
};
declare type GqlExecuteMutationVariables = Exact<{
    sessionId: Scalars['ID'];
    op: Scalars['String'];
}>;
declare type GqlExecuteMutation = {
    __typename: 'Mutation';
    execute: boolean;
};
declare type GqlResetMutationVariables = Exact<{
    sessionId: Scalars['ID'];
}>;
declare type GqlResetMutation = {
    __typename: 'Mutation';
    reset: boolean;
};
declare type SdkFunctionWrapper = <T>(action: (requestHeaders?: Record<string, string>) => Promise<T>, operationName: string, operationType?: string) => Promise<T>;
declare function getSdk(client: GraphQLClient, withWrapper?: SdkFunctionWrapper): {
    getVersion(variables?: GqlGetVersionQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetVersionQuery>;
    getInfo(variables?: GqlGetInfoQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetInfoQuery>;
    getChain(variables?: GqlGetChainQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetChainQuery>;
    getTransaction(variables: GqlGetTransactionQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetTransactionQuery>;
    getTransactionWithReceipts(variables: GqlGetTransactionWithReceiptsQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetTransactionWithReceiptsQuery>;
    getTransactions(variables?: GqlGetTransactionsQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetTransactionsQuery>;
    getTransactionsByOwner(variables: GqlGetTransactionsByOwnerQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetTransactionsByOwnerQuery>;
    getBlock(variables?: GqlGetBlockQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetBlockQuery>;
    getBlockWithTransactions(variables?: GqlGetBlockWithTransactionsQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetBlockWithTransactionsQuery>;
    getBlocks(variables?: GqlGetBlocksQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetBlocksQuery>;
    getCoin(variables: GqlGetCoinQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetCoinQuery>;
    getCoins(variables: GqlGetCoinsQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetCoinsQuery>;
    getResourcesToSpend(variables: GqlGetResourcesToSpendQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetResourcesToSpendQuery>;
    getContract(variables: GqlGetContractQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetContractQuery>;
    getBalance(variables: GqlGetBalanceQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetBalanceQuery>;
    getBalances(variables: GqlGetBalancesQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetBalancesQuery>;
    getMessages(variables: GqlGetMessagesQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetMessagesQuery>;
    getMessageProof(variables: GqlGetMessageProofQueryVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlGetMessageProofQuery>;
    dryRun(variables: GqlDryRunMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlDryRunMutation>;
    submit(variables: GqlSubmitMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlSubmitMutation>;
    startSession(variables?: GqlStartSessionMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlStartSessionMutation>;
    endSession(variables: GqlEndSessionMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlEndSessionMutation>;
    execute(variables: GqlExecuteMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlExecuteMutation>;
    reset(variables: GqlResetMutationVariables, requestHeaders?: Dom.RequestInit['headers']): Promise<GqlResetMutation>;
};

/**
 * A Fuel coin
 */
declare type Coin = {
    id: string;
    assetId: string;
    amount: BN;
    owner: AbstractAddress;
    status: GqlCoinStatus;
    maturity: number;
    blockCreated: BN;
};

/**
 * A Fuel message
 */
declare type Message = {
    sender: AbstractAddress;
    recipient: AbstractAddress;
    nonce: BN;
    amount: BN;
    data: BytesLike;
    daHeight: BN;
    fuelBlockSpend: BN;
};
/**
 * Message Proof
 */
declare type MessageProof = {
    proofSet: Array<string>;
    proofIndex: BN;
    sender: AbstractAddress;
    recipient: AbstractAddress;
    nonce: string;
    amount: BN;
    data: string;
    signature: string;
    header: {
        id: string;
        daHeight: BN;
        transactionsCount: BN;
        outputMessagesCount: BN;
        transactionsRoot: string;
        outputMessagesRoot: string;
        height: BN;
        prevRoot: string;
        time: string;
        applicationHash: string;
    };
};

declare type RawCoin = {
    utxoId: string;
    owner: string;
    amount: string;
    assetId: string;
    maturity: string;
    status: GqlCoinStatus;
    blockCreated: string;
};
declare type RawMessage = {
    amount: string;
    sender: string;
    recipient: string;
    data: string;
    nonce: string;
    daHeight: string;
};
declare type RawResource = RawCoin | RawMessage;
declare type Resource = Coin | Message;
declare type Resources = GqlGetResourcesToSpendQuery['resourcesToSpend'];
declare type ExcludeResourcesOption = {
    utxos?: BytesLike[];
    messages?: BytesLike[];
};
declare const isRawCoin: (resource: RawResource) => resource is RawCoin;
declare const isRawMessage: (resource: RawResource) => resource is RawMessage;
declare const isCoin: (resource: Resource) => resource is Coin;
declare const isMessage: (resource: Resource) => resource is Message;

declare type CoinTransactionRequestInput = {
    type: InputType.Coin;
    /** UTXO ID */
    id: BytesLike;
    /** Owning address or script hash */
    owner: BytesLike;
    /** Amount of coins */
    amount: BigNumberish;
    /** Asset ID of the coins */
    assetId: BytesLike;
    /** Points to the TX whose output is being spent. (TxPointer) */
    txPointer: BytesLike;
    /** Index of witness that authorizes spending the coin */
    witnessIndex: number;
    /** UTXO being spent must have been created at least this many blocks ago */
    maturity?: number;
    /** Predicate bytecode */
    predicate?: BytesLike;
    /** Predicate input data (parameters) */
    predicateData?: BytesLike;
};
declare type MessageTransactionRequestInput = {
    type: InputType.Message;
    /** Amount of coins */
    amount: BigNumberish;
    /** Address of sender */
    sender: BytesLike;
    /** Address of sender */
    recipient: BytesLike;
    /** Index of witness that authorizes the message */
    witnessIndex: number;
    /** data of message */
    data: BytesLike;
    /** Unique nonce of message */
    nonce: BigNumberish;
    /** Predicate bytecode */
    predicate?: BytesLike;
    /** Predicate input data (parameters) */
    predicateData?: BytesLike;
};
declare type ContractTransactionRequestInput = {
    type: InputType.Contract;
    /** Points to the TX whose output is being spent. (TxPointer) */
    txPointer: BytesLike;
    /** Contract ID */
    contractId: BytesLike;
};
declare type TransactionRequestInput = CoinTransactionRequestInput | ContractTransactionRequestInput | MessageTransactionRequestInput;
declare const inputify: (value: TransactionRequestInput) => Input;

declare type CoinTransactionRequestOutput = {
    type: OutputType.Coin;
    /** Receiving address or script hash */
    to: BytesLike;
    /** Amount of coins to send */
    amount: BigNumberish;
    /** Asset ID of coins */
    assetId: BytesLike;
};
declare type ContractTransactionRequestOutput = {
    type: OutputType.Contract;
    /** Index of input contract */
    inputIndex: number;
};
declare type MessageTransactionRequestOutput = {
    type: OutputType.Message;
    /** Receiving address */
    recipient: BytesLike;
    /** Amount of coins sent with message */
    amount: BigNumberish;
};
declare type ChangeTransactionRequestOutput = {
    type: OutputType.Change;
    /** Receiving address or script hash */
    to: BytesLike;
    /** Asset ID of coins */
    assetId: BytesLike;
};
declare type VariableTransactionRequestOutput = {
    type: OutputType.Variable;
};
declare type ContractCreatedTransactionRequestOutput = {
    type: OutputType.ContractCreated;
    /** Contract ID */
    contractId: BytesLike;
    /** State Root */
    stateRoot: BytesLike;
};
declare type TransactionRequestOutput = CoinTransactionRequestOutput | ContractTransactionRequestOutput | MessageTransactionRequestOutput | ChangeTransactionRequestOutput | VariableTransactionRequestOutput | ContractCreatedTransactionRequestOutput;
declare const outputify: (value: TransactionRequestOutput) => Output;

declare type TransactionRequestStorageSlot = {
    /** Key */
    key: BytesLike;
    /** Value */
    value: BytesLike;
} | [key: BytesLike, value: BytesLike];

declare type TransactionRequestWitness = BytesLike;

declare const returnZeroScript: AbstractScript<void>;
declare const withdrawScript: AbstractScript<void>;
interface BaseTransactionRequestLike {
    /** Gas price for transaction */
    gasPrice?: BigNumberish;
    /** Gas limit for transaction */
    gasLimit?: BigNumberish;
    /** Block until which tx cannot be included */
    maturity?: number;
    /** List of inputs */
    inputs?: TransactionRequestInput[];
    /** List of outputs */
    outputs?: TransactionRequestOutput[];
    /** List of witnesses */
    witnesses?: TransactionRequestWitness[];
}
declare class ChangeOutputCollisionError extends Error {
    name: string;
    message: string;
}
declare class NoWitnessAtIndexError extends Error {
    readonly index: number;
    name: string;
    constructor(index: number);
}
declare class NoWitnessByOwnerError extends Error {
    readonly owner: AbstractAddress;
    name: string;
    constructor(owner: AbstractAddress);
}
declare abstract class BaseTransactionRequest implements BaseTransactionRequestLike {
    /** Type of the transaction */
    abstract type: TransactionType;
    /** Gas price for transaction */
    gasPrice: BN;
    /** Gas limit for transaction */
    gasLimit: BN;
    /** Block until which tx cannot be included */
    maturity: number;
    /** List of inputs */
    inputs: TransactionRequestInput[];
    /** List of outputs */
    outputs: TransactionRequestOutput[];
    /** List of witnesses */
    witnesses: TransactionRequestWitness[];
    constructor({ gasPrice, gasLimit, maturity, inputs, outputs, witnesses, }?: BaseTransactionRequestLike);
    protected getBaseTransaction(): Pick<Transaction, keyof BaseTransactionRequestLike | 'inputsCount' | 'outputsCount' | 'witnessesCount'>;
    abstract toTransaction(): Transaction;
    toTransactionBytes(): Uint8Array;
    /**
     * Pushes an input to the list without any side effects and returns the index
     */
    protected pushInput(input: TransactionRequestInput): number;
    /**
     * Pushes an output to the list without any side effects and returns the index
     */
    protected pushOutput(output: TransactionRequestOutput): number;
    /**
     * Creates an empty witness without any side effects and returns the index
     */
    protected createWitness(): number;
    updateWitnessByOwner(address: AbstractAddress, signature: BytesLike): void;
    /**
     * Updates an existing witness without any side effects
     */
    updateWitness(index: number, witness: TransactionRequestWitness): void;
    getCoinInputs(): CoinTransactionRequestInput[];
    getCoinOutputs(): CoinTransactionRequestOutput[];
    getChangeOutputs(): ChangeTransactionRequestOutput[];
    /**
     * Returns the witnessIndex of the found CoinInput
     */
    getCoinInputWitnessIndexByOwner(owner: AddressLike): number | null;
    /**
     * Updates the witness for the given CoinInput owner
     */
    updateWitnessByCoinInputOwner(owner: AddressLike, witness: BytesLike): void;
    /**
     * Converts the given Resource to a ResourceInput with the appropriate witnessIndex and pushes it
     */
    addResource(resource: Resource): void;
    addResources(resources: ReadonlyArray<Resource>): void;
    /**
     * Converts the given Coin to a CoinInput with the appropriate witnessIndex and pushes it
     */
    addCoin(coin: Coin): void;
    addCoins(coins: ReadonlyArray<Coin>): void;
    addCoinOutput(
    /** Address of the destination */
    to: AddressLike, 
    /** Amount of coins */
    amount: BigNumberish, 
    /** Asset ID of coins */
    assetId?: BytesLike): void;
    addCoinOutputs(
    /** Address of the destination */
    to: AddressLike, 
    /** Quantities of coins */
    quantities: CoinQuantityLike[]): void;
    byteSize(): number;
    chargeableByteSize(): BN;
    /**
     * Return the minimum amount in native coins required to create
     * a transaction.
     *
     * Note: this is required even gasPrice = 0
     */
    calculateFee(): CoinQuantity;
    /**
     * Converts the given Message to a MessageInput
     */
    addMessage(message: Message): void;
    addMessages(messages: ReadonlyArray<Message>): void;
}
interface ScriptTransactionRequestLike extends BaseTransactionRequestLike {
    /** Script to execute */
    script?: BytesLike;
    /** Script input data (parameters) */
    scriptData?: BytesLike;
}
declare class ScriptTransactionRequest extends BaseTransactionRequest {
    static from(obj: ScriptTransactionRequestLike): ScriptTransactionRequest;
    /** Type of the transaction */
    type: TransactionType.Script;
    /** Script to execute */
    script: Uint8Array;
    /** Script input data (parameters) */
    scriptData: Uint8Array;
    /** determined bytes offset for start of script data */
    bytesOffset: number | undefined;
    constructor({ script, scriptData, ...rest }?: ScriptTransactionRequestLike);
    toTransaction(): Transaction;
    getContractInputs(): ContractTransactionRequestInput[];
    getContractOutputs(): ContractTransactionRequestOutput[];
    getVariableOutputs(): VariableTransactionRequestOutput[];
    setScript<T>(script: AbstractScript<T>, data: T): void;
    addVariableOutputs(numberOfVariables?: number): number;
    addMessageOutputs(numberOfMessages?: number): number;
    addContract(contract: ContractIdLike): void;
}
interface CreateTransactionRequestLike extends BaseTransactionRequestLike {
    /** Witness index of contract bytecode to create */
    bytecodeWitnessIndex?: number;
    /** Salt */
    salt?: BytesLike;
    /** List of storage slots to initialize */
    storageSlots?: TransactionRequestStorageSlot[];
}
declare class CreateTransactionRequest extends BaseTransactionRequest {
    static from(obj: CreateTransactionRequestLike): CreateTransactionRequest;
    /** Type of the transaction */
    type: TransactionType.Create;
    /** Witness index of contract bytecode to create */
    bytecodeWitnessIndex: number;
    /** Salt */
    salt: string;
    /** List of storage slots to initialize */
    storageSlots: TransactionRequestStorageSlot[];
    constructor({ bytecodeWitnessIndex, salt, storageSlots, ...rest }?: CreateTransactionRequestLike);
    toTransaction(): Transaction;
    getContractCreatedOutputs(): ContractCreatedTransactionRequestOutput[];
    addContractCreatedOutput(
    /** Contract ID */
    contractId: BytesLike, 
    /** State Root */
    stateRoot: BytesLike): void;
}
declare type TransactionRequest = ScriptTransactionRequest | CreateTransactionRequest;
declare type TransactionRequestLike = ({
    type: TransactionType.Script;
} & ScriptTransactionRequestLike) | ({
    type: TransactionType.Create;
} & CreateTransactionRequestLike);
declare const transactionRequestify: (obj: TransactionRequestLike) => TransactionRequest;

declare type TransactionResultCallReceipt = ReceiptCall;
declare type TransactionResultReturnReceipt = ReceiptReturn;
declare type TransactionResultReturnDataReceipt = ReceiptReturnData & {
    data: string;
};
declare type TransactionResultPanicReceipt = ReceiptPanic;
declare type TransactionResultRevertReceipt = ReceiptRevert;
declare type TransactionResultLogReceipt = ReceiptLog;
declare type TransactionResultLogDataReceipt = ReceiptLogData & {
    data: string;
};
declare type TransactionResultTransferReceipt = ReceiptTransfer;
declare type TransactionResultTransferOutReceipt = ReceiptTransferOut;
declare type TransactionResultScriptResultReceipt = ReceiptScriptResult;
declare type TransactionResultMessageOutReceipt = ReceiptMessageOut;
declare type TransactionResultReceipt = TransactionResultCallReceipt | TransactionResultReturnReceipt | TransactionResultReturnDataReceipt | TransactionResultPanicReceipt | TransactionResultRevertReceipt | TransactionResultLogReceipt | TransactionResultLogDataReceipt | TransactionResultTransferReceipt | TransactionResultTransferOutReceipt | TransactionResultScriptResultReceipt | TransactionResultMessageOutReceipt;
declare type TransactionResult<TStatus extends 'success' | 'failure'> = {
    status: TStatus extends 'success' ? {
        type: 'success';
        programState: any;
    } : {
        type: 'failure';
        reason: any;
    };
    /** Receipts produced during the execution of the transaction */
    receipts: TransactionResultReceipt[];
    transactionId: string;
    blockId: any;
    time: any;
    gasUsed: BN;
    fee: BN;
    transaction: Transaction;
};
declare class TransactionResponse {
    #private;
    /** Transaction ID */
    id: string;
    /** Current provider */
    provider: Provider;
    /** Gas used on the transaction */
    gasUsed: BN;
    /** Number off attempts to get the committed tx */
    attempts: number;
    constructor(id: string, provider: Provider);
    /** Waits for transaction to succeed or fail and returns the result */
    waitForResult(): Promise<TransactionResult<any>>;
    /** Waits for transaction to succeed and returns the result */
    wait(): Promise<TransactionResult<'success'>>;
}

declare type CallResult = {
    receipts: TransactionResultReceipt[];
};
/**
 * A Fuel block
 */
declare type Block = {
    id: string;
    height: BN;
    time: string;
    transactionIds: string[];
};
/**
 * Deployed Contract bytecode and contract id
 */
declare type ContractResult = {
    id: string;
    bytecode: string;
};
/**
 * Chain information
 */
declare type ChainInfo = {
    name: string;
    baseChainHeight: BN;
    peerCount: number;
    consensusParameters: {
        gasPriceFactor: BN;
        maxGasPerTx: BN;
        maxScriptLength: BN;
    };
    latestBlock: {
        id: string;
        height: BN;
        time: string;
        transactions: Array<{
            id: string;
        }>;
    };
};
/**
 * Node information
 */
declare type NodeInfo = {
    minGasPrice: BN;
    nodeVersion: string;
};
declare type TransactionCost = {
    minGasPrice: BN;
    gasPrice: BN;
    gasUsed: BN;
    fee: BN;
};
/**
 * Cursor pagination arguments
 *
 * https://relay.dev/graphql/connections.htm#sec-Arguments
 */
declare type CursorPaginationArgs = {
    /** Forward pagination limit */
    first?: number | null;
    /** Forward pagination cursor */
    after?: string | null;
    /** Backward pagination limit  */
    last?: number | null;
    /** Backward pagination cursor */
    before?: string | null;
};
declare type BuildPredicateOptions = {
    fundTransaction?: boolean;
} & Pick<TransactionRequestLike, 'gasLimit' | 'gasPrice' | 'maturity'>;
/**
 * Provider Call transaction params
 */
declare type ProviderCallParams = {
    utxoValidation?: boolean;
};
/**
 * A provider for connecting to a Fuel node
 */
declare class Provider {
    /** GraphQL endpoint of the Fuel node */
    url: string;
    operations: ReturnType<typeof getSdk>;
    constructor(
    /** GraphQL endpoint of the Fuel node */
    url: string);
    /**
     * Returns the version of the connected Fuel node
     */
    getVersion(): Promise<string>;
    /**
     * Returns the network configuration of the connected Fuel node
     */
    getNetwork(): Promise<Network>;
    /**
     * Returns the current block number
     */
    getBlockNumber(): Promise<BN>;
    /**
     * Returns node information
     */
    getNodeInfo(): Promise<NodeInfo>;
    /**
     * Returns chain information
     */
    getChain(): Promise<ChainInfo>;
    /**
     * Submits a transaction to the chain to be executed
     * If the transaction is missing VariableOuputs
     * the transaction will be mutate and VariableOuputs will be added
     */
    sendTransaction(transactionRequestLike: TransactionRequestLike): Promise<TransactionResponse>;
    /**
     * Executes a transaction without actually submitting it to the chain
     * If the transaction is missing VariableOuputs
     * the transaction will be mutate and VariableOuputs will be added
     */
    call(transactionRequestLike: TransactionRequestLike, { utxoValidation }?: ProviderCallParams): Promise<CallResult>;
    /**
     * Will dryRun a transaction and check for missing VariableOutputs
     *
     * If there are missing VariableOutputs
     * `addVariableOutputs` is called on the transaction.
     * This process is done at most 10 times
     */
    addMissingVariables: (transactionRequest: TransactionRequest) => Promise<void>;
    /**
     * Executes a signed transaction without applying the states changes
     * on the chain.
     * If the transaction is missing VariableOuputs
     * the transaction will be mutate and VariableOuputs will be added
     */
    simulate(transactionRequestLike: TransactionRequestLike): Promise<CallResult>;
    /**
     * Returns a transaction cost to enable user
     * to set gasLimit and also reserve balance amounts
     * on the the transaction.
     *
     * The tolerance is add on top of the gasUsed calculated
     * from the node, this create a safe margin costs like
     * change states on transfer that don't occur on the dryRun
     * transaction. The default value is 0.2 or 20%
     */
    getTransactionCost(transactionRequestLike: TransactionRequestLike, tolerance?: number): Promise<TransactionCost>;
    /**
     * Returns coins for the given owner
     */
    getCoins(
    /** The address to get coins for */
    owner: AbstractAddress, 
    /** The asset ID of coins to get */
    assetId?: BytesLike, 
    /** Pagination arguments */
    paginationArgs?: CursorPaginationArgs): Promise<Coin[]>;
    /**
     * Returns resources for the given owner satisfying the spend query
     */
    getResourcesToSpend(
    /** The address to get coins for */
    owner: AbstractAddress, 
    /** The quantities to get */
    quantities: CoinQuantityLike[], 
    /** IDs of excluded resources from the selection. */
    excludedIds?: ExcludeResourcesOption): Promise<Resource[]>;
    /**
     * Returns block matching the given ID or type
     */
    getBlock(
    /** ID or height of the block */
    idOrHeight: string | number | 'latest'): Promise<Block | null>;
    /**
     * Returns block matching the given ID or type, including transaction data
     */
    getBlockWithTransactions(
    /** ID or height of the block */
    idOrHeight: string | number | 'latest'): Promise<(Block & {
        transactions: Transaction[];
    }) | null>;
    /**
     * Get transaction with the given ID
     */
    getTransaction(transactionId: string): Promise<Transaction | null>;
    /**
     * Get deployed contract with the given ID
     *
     * @returns contract bytecode and contract id
     */
    getContract(contractId: string): Promise<ContractResult | null>;
    /**
     * Returns the balance for the given owner for the given asset ID
     */
    getBalance(
    /** The address to get coins for */
    owner: AbstractAddress, 
    /** The asset ID of coins to get */
    assetId: BytesLike): Promise<BN>;
    /**
     * Returns balances for the given owner
     */
    getBalances(
    /** The address to get coins for */
    owner: AbstractAddress, 
    /** Pagination arguments */
    paginationArgs?: CursorPaginationArgs): Promise<CoinQuantity[]>;
    /**
     * Returns message for the given address
     */
    getMessages(
    /** The address to get message from */
    address: AbstractAddress, 
    /** Pagination arguments */
    paginationArgs?: CursorPaginationArgs): Promise<Message[]>;
    /**
     * Returns Message Proof for given transaction id and the message id from MessageOut receipt
     */
    getMessageProof(
    /** The transaction to get message from */
    transactionId: string, 
    /** The message id from MessageOut receipt */
    messageId: string): Promise<MessageProof | null>;
    buildSpendPredicate(predicate: AbstractPredicate, amountToSpend: BigNumberish, receiverAddress: AbstractAddress, predicateData?: InputValue[], assetId?: BytesLike, predicateOptions?: BuildPredicateOptions, walletAddress?: AbstractAddress): Promise<ScriptTransactionRequest>;
    submitSpendPredicate(predicate: AbstractPredicate, amountToSpend: BigNumberish, receiverAddress: AbstractAddress, predicateData?: InputValue[], assetId?: BytesLike, options?: BuildPredicateOptions, walletAddress?: AbstractAddress): Promise<TransactionResult<'success'>>;
}

declare const arraifyFromUint8Array: (bytes: BytesLike) => Uint8Array;
declare const calculatePriceWithFactor: (gasUsed: BN, gasPrice: BN, priceFactor: BN) => BN;
declare const getGasUsedFromReceipts: (receipts: Array<TransactionResultReceipt>) => BN;
declare function sleep(time?: number): Promise<unknown>;
declare const getReceiptsWithMissingData: (receipts: Array<TransactionResultReceipt>) => {
    missingOutputVariables: Array<ReceiptRevert>;
    missingOutputContractIds: Array<ReceiptPanic>;
};
declare const calculateTransactionFee: ({ receipts, gasPrice, margin, }: {
    receipts: TransactionResultReceipt[];
    gasPrice: BN;
    margin?: number | undefined;
}) => {
    gasUsed: BN;
    fee: BN;
};

export { Block, BuildPredicateOptions, CallResult, ChainInfo, ChangeOutputCollisionError, ChangeTransactionRequestOutput, Coin, CoinQuantity, CoinQuantityLike, GqlCoinStatus as CoinStatus, CoinTransactionRequestInput, CoinTransactionRequestOutput, ContractCreatedTransactionRequestOutput, ContractResult, ContractTransactionRequestInput, ContractTransactionRequestOutput, CreateTransactionRequest, CreateTransactionRequestLike, CursorPaginationArgs, ExcludeResourcesOption, Message, MessageProof, MessageTransactionRequestInput, MessageTransactionRequestOutput, NoWitnessAtIndexError, NoWitnessByOwnerError, NodeInfo, Provider, ProviderCallParams, RawCoin, RawMessage, RawResource, Resource, Resources, ScriptTransactionRequest, ScriptTransactionRequestLike, TransactionCost, TransactionRequest, TransactionRequestInput, TransactionRequestLike, TransactionRequestOutput, TransactionResponse, TransactionResult, TransactionResultCallReceipt, TransactionResultLogDataReceipt, TransactionResultLogReceipt, TransactionResultMessageOutReceipt, TransactionResultPanicReceipt, TransactionResultReceipt, TransactionResultReturnDataReceipt, TransactionResultReturnReceipt, TransactionResultRevertReceipt, TransactionResultScriptResultReceipt, TransactionResultTransferOutReceipt, TransactionResultTransferReceipt, VariableTransactionRequestOutput, arraifyFromUint8Array, calculatePriceWithFactor, calculateTransactionFee, coinQuantityfy, getGasUsedFromReceipts, getReceiptsWithMissingData, inputify, isCoin, isMessage, isRawCoin, isRawMessage, outputify, returnZeroScript, sleep, transactionRequestify, withdrawScript };
