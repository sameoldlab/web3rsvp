{"version":3,"sources":["../src/coin-quantity.ts","../src/__generated__/operations.ts","../src/provider.ts","../src/resource.ts","../src/transaction-request/input.ts","../src/transaction-request/output.ts","../src/transaction-request/transaction-request.ts","../src/util.ts","../src/transaction-request/storage-slot.ts","../src/transaction-request/witness.ts","../src/transaction-response/transaction-response.ts"],"sourcesContent":["import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify } from '@ethersproject/bytes';\nimport { NativeAssetId } from '@fuel-ts/constants';\nimport type { BigNumberish, BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\n\nexport type CoinQuantityLike =\n  | [amount: BigNumberish, assetId?: BytesLike, max?: BigNumberish]\n  | { amount: BigNumberish; assetId?: BytesLike; max?: BigNumberish };\nexport type CoinQuantity = { amount: BN; assetId: string; max?: BN };\n\nexport const coinQuantityfy = (coinQuantityLike: CoinQuantityLike): CoinQuantity => {\n  let assetId;\n  let amount;\n  let max;\n  if (Array.isArray(coinQuantityLike)) {\n    amount = coinQuantityLike[0];\n    assetId = coinQuantityLike[1] ?? NativeAssetId;\n    max = coinQuantityLike[2] ?? undefined;\n  } else {\n    amount = coinQuantityLike.amount;\n    assetId = coinQuantityLike.assetId ?? NativeAssetId;\n    max = coinQuantityLike.max ?? undefined;\n  }\n\n  return {\n    assetId: hexlify(assetId),\n    amount: bn(amount),\n    max: max ? bn(max) : undefined,\n  };\n};\n","import type { GraphQLClient } from 'graphql-request';\nimport type * as Dom from 'graphql-request/dist/types.dom';\nimport gql from 'graphql-tag';\n\nexport type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n  Address: string;\n  AssetId: string;\n  BlockId: string;\n  Bytes32: string;\n  ContractId: string;\n  /**\n   * Implement the DateTime<Utc> scalar\n   *\n   * The input/output is a string in RFC3339 format.\n   */\n  DateTime: string;\n  HexString: string;\n  MessageId: any;\n  Salt: string;\n  Signature: any;\n  TransactionId: string;\n  TxPointer: any;\n  U64: string;\n  UtxoId: string;\n};\n\nexport type GqlBalance = {\n  __typename: 'Balance';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  owner: Scalars['Address'];\n};\n\nexport type GqlBalanceConnection = {\n  __typename: 'BalanceConnection';\n  /** A list of edges. */\n  edges: Array<GqlBalanceEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlBalance>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlBalanceEdge = {\n  __typename: 'BalanceEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlBalance;\n};\n\nexport type GqlBalanceFilterInput = {\n  /** Filter coins based on the `owner` field */\n  owner: Scalars['Address'];\n};\n\nexport type GqlBlock = {\n  __typename: 'Block';\n  header: GqlHeader;\n  id: Scalars['BlockId'];\n  transactions: Array<GqlTransaction>;\n};\n\nexport type GqlBlockConnection = {\n  __typename: 'BlockConnection';\n  /** A list of edges. */\n  edges: Array<GqlBlockEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlBlock>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlBlockEdge = {\n  __typename: 'BlockEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlBlock;\n};\n\nexport type GqlBreakpoint = {\n  contract: Scalars['ContractId'];\n  pc: Scalars['U64'];\n};\n\nexport type GqlChainInfo = {\n  __typename: 'ChainInfo';\n  baseChainHeight: Scalars['U64'];\n  consensusParameters: GqlConsensusParameters;\n  latestBlock: GqlBlock;\n  name: Scalars['String'];\n  peerCount: Scalars['Int'];\n};\n\nexport type GqlChangeOutput = {\n  __typename: 'ChangeOutput';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  to: Scalars['Address'];\n};\n\nexport type GqlCoin = {\n  __typename: 'Coin';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  blockCreated: Scalars['U64'];\n  maturity: Scalars['U64'];\n  owner: Scalars['Address'];\n  status: GqlCoinStatus;\n  utxoId: Scalars['UtxoId'];\n};\n\nexport type GqlCoinConnection = {\n  __typename: 'CoinConnection';\n  /** A list of edges. */\n  edges: Array<GqlCoinEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlCoin>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlCoinEdge = {\n  __typename: 'CoinEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlCoin;\n};\n\nexport type GqlCoinFilterInput = {\n  /** Asset ID of the coins */\n  assetId?: InputMaybe<Scalars['AssetId']>;\n  /** Address of the owner */\n  owner: Scalars['Address'];\n};\n\nexport type GqlCoinOutput = {\n  __typename: 'CoinOutput';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  to: Scalars['Address'];\n};\n\nexport enum GqlCoinStatus {\n  Spent = 'SPENT',\n  Unspent = 'UNSPENT',\n}\n\nexport type GqlConsensusParameters = {\n  __typename: 'ConsensusParameters';\n  contractMaxSize: Scalars['U64'];\n  gasPerByte: Scalars['U64'];\n  gasPriceFactor: Scalars['U64'];\n  maxGasPerTx: Scalars['U64'];\n  maxInputs: Scalars['U64'];\n  maxMessageDataLength: Scalars['U64'];\n  maxOutputs: Scalars['U64'];\n  maxPredicateDataLength: Scalars['U64'];\n  maxPredicateLength: Scalars['U64'];\n  maxScriptDataLength: Scalars['U64'];\n  maxScriptLength: Scalars['U64'];\n  maxStorageSlots: Scalars['U64'];\n  maxWitnesses: Scalars['U64'];\n};\n\nexport type GqlContract = {\n  __typename: 'Contract';\n  bytecode: Scalars['HexString'];\n  id: Scalars['ContractId'];\n  salt: Scalars['Salt'];\n};\n\nexport type GqlContractBalance = {\n  __typename: 'ContractBalance';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  contract: Scalars['ContractId'];\n};\n\nexport type GqlContractBalanceConnection = {\n  __typename: 'ContractBalanceConnection';\n  /** A list of edges. */\n  edges: Array<GqlContractBalanceEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlContractBalance>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlContractBalanceEdge = {\n  __typename: 'ContractBalanceEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlContractBalance;\n};\n\nexport type GqlContractBalanceFilterInput = {\n  /** Filter assets based on the `contractId` field */\n  contract: Scalars['ContractId'];\n};\n\nexport type GqlContractCreated = {\n  __typename: 'ContractCreated';\n  contract: GqlContract;\n  stateRoot: Scalars['Bytes32'];\n};\n\nexport type GqlContractOutput = {\n  __typename: 'ContractOutput';\n  balanceRoot: Scalars['Bytes32'];\n  inputIndex: Scalars['Int'];\n  stateRoot: Scalars['Bytes32'];\n};\n\nexport type GqlExcludeInput = {\n  /** Messages to exclude from the selection. */\n  messages: Array<Scalars['MessageId']>;\n  /** Utxos to exclude from the selection. */\n  utxos: Array<Scalars['UtxoId']>;\n};\n\nexport type GqlFailureStatus = {\n  __typename: 'FailureStatus';\n  block: GqlBlock;\n  programState?: Maybe<GqlProgramState>;\n  reason: Scalars['String'];\n  time: Scalars['DateTime'];\n};\n\nexport type GqlHeader = {\n  __typename: 'Header';\n  /** Hash of the application header. */\n  applicationHash: Scalars['Bytes32'];\n  /** The layer 1 height of messages and events to include since the last layer 1 block number. */\n  daHeight: Scalars['U64'];\n  /** Fuel block height. */\n  height: Scalars['U64'];\n  /** Hash of the header */\n  id: Scalars['BlockId'];\n  /** Number of output messages in this block. */\n  outputMessagesCount: Scalars['U64'];\n  /** Merkle root of messages in this block. */\n  outputMessagesRoot: Scalars['Bytes32'];\n  /** Merkle root of all previous block header hashes. */\n  prevRoot: Scalars['Bytes32'];\n  /** The block producer time. */\n  time: Scalars['DateTime'];\n  /** Number of transactions in this block. */\n  transactionsCount: Scalars['U64'];\n  /** Merkle root of transactions. */\n  transactionsRoot: Scalars['Bytes32'];\n};\n\nexport type GqlInput = GqlInputCoin | GqlInputContract | GqlInputMessage;\n\nexport type GqlInputCoin = {\n  __typename: 'InputCoin';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  maturity: Scalars['U64'];\n  owner: Scalars['Address'];\n  predicate: Scalars['HexString'];\n  predicateData: Scalars['HexString'];\n  txPointer: Scalars['TxPointer'];\n  utxoId: Scalars['UtxoId'];\n  witnessIndex: Scalars['Int'];\n};\n\nexport type GqlInputContract = {\n  __typename: 'InputContract';\n  balanceRoot: Scalars['Bytes32'];\n  contract: GqlContract;\n  stateRoot: Scalars['Bytes32'];\n  txPointer: Scalars['TxPointer'];\n  utxoId: Scalars['UtxoId'];\n};\n\nexport type GqlInputMessage = {\n  __typename: 'InputMessage';\n  amount: Scalars['U64'];\n  data: Scalars['HexString'];\n  messageId: Scalars['MessageId'];\n  nonce: Scalars['U64'];\n  predicate: Scalars['HexString'];\n  predicateData: Scalars['HexString'];\n  recipient: Scalars['Address'];\n  sender: Scalars['Address'];\n  witnessIndex: Scalars['Int'];\n};\n\nexport type GqlMessage = {\n  __typename: 'Message';\n  amount: Scalars['U64'];\n  daHeight: Scalars['U64'];\n  data: Scalars['HexString'];\n  fuelBlockSpend?: Maybe<Scalars['U64']>;\n  messageId: Scalars['MessageId'];\n  nonce: Scalars['U64'];\n  recipient: Scalars['Address'];\n  sender: Scalars['Address'];\n};\n\nexport type GqlMessageConnection = {\n  __typename: 'MessageConnection';\n  /** A list of edges. */\n  edges: Array<GqlMessageEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlMessage>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlMessageEdge = {\n  __typename: 'MessageEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlMessage;\n};\n\nexport type GqlMessageOutput = {\n  __typename: 'MessageOutput';\n  amount: Scalars['U64'];\n  recipient: Scalars['Address'];\n};\n\nexport type GqlMessageProof = {\n  __typename: 'MessageProof';\n  amount: Scalars['U64'];\n  data: Scalars['HexString'];\n  header: GqlHeader;\n  nonce: Scalars['Bytes32'];\n  proofIndex: Scalars['U64'];\n  proofSet: Array<Scalars['Bytes32']>;\n  recipient: Scalars['Address'];\n  sender: Scalars['Address'];\n  signature: Scalars['Signature'];\n};\n\nexport type GqlMutation = {\n  __typename: 'Mutation';\n  continueTx: GqlRunResult;\n  /** Execute a dry-run of the transaction using a fork of current state, no changes are committed. */\n  dryRun: Array<GqlReceipt>;\n  endSession: Scalars['Boolean'];\n  execute: Scalars['Boolean'];\n  produceBlocks: Scalars['U64'];\n  reset: Scalars['Boolean'];\n  setBreakpoint: Scalars['Boolean'];\n  setSingleStepping: Scalars['Boolean'];\n  startSession: Scalars['ID'];\n  startTx: GqlRunResult;\n  /** Submits transaction to the txpool */\n  submit: GqlTransaction;\n};\n\nexport type GqlMutationContinueTxArgs = {\n  id: Scalars['ID'];\n};\n\nexport type GqlMutationDryRunArgs = {\n  tx: Scalars['HexString'];\n  utxoValidation?: InputMaybe<Scalars['Boolean']>;\n};\n\nexport type GqlMutationEndSessionArgs = {\n  id: Scalars['ID'];\n};\n\nexport type GqlMutationExecuteArgs = {\n  id: Scalars['ID'];\n  op: Scalars['String'];\n};\n\nexport type GqlMutationProduceBlocksArgs = {\n  blocksToProduce: Scalars['U64'];\n  time?: InputMaybe<GqlTimeParameters>;\n};\n\nexport type GqlMutationResetArgs = {\n  id: Scalars['ID'];\n};\n\nexport type GqlMutationSetBreakpointArgs = {\n  breakpoint: GqlBreakpoint;\n  id: Scalars['ID'];\n};\n\nexport type GqlMutationSetSingleSteppingArgs = {\n  enable: Scalars['Boolean'];\n  id: Scalars['ID'];\n};\n\nexport type GqlMutationStartTxArgs = {\n  id: Scalars['ID'];\n  txJson: Scalars['String'];\n};\n\nexport type GqlMutationSubmitArgs = {\n  tx: Scalars['HexString'];\n};\n\nexport type GqlNodeInfo = {\n  __typename: 'NodeInfo';\n  maxDepth: Scalars['U64'];\n  maxTx: Scalars['U64'];\n  minGasPrice: Scalars['U64'];\n  nodeVersion: Scalars['String'];\n  utxoValidation: Scalars['Boolean'];\n  vmBacktrace: Scalars['Boolean'];\n};\n\nexport type GqlOutput =\n  | GqlChangeOutput\n  | GqlCoinOutput\n  | GqlContractCreated\n  | GqlContractOutput\n  | GqlMessageOutput\n  | GqlVariableOutput;\n\n/**\n * A separate `Breakpoint` type to be used as an output, as a single\n * type cannot act as both input and output type in async-graphql\n */\nexport type GqlOutputBreakpoint = {\n  __typename: 'OutputBreakpoint';\n  contract: Scalars['ContractId'];\n  pc: Scalars['U64'];\n};\n\n/** Information about pagination in a connection */\nexport type GqlPageInfo = {\n  __typename: 'PageInfo';\n  /** When paginating forwards, the cursor to continue. */\n  endCursor?: Maybe<Scalars['String']>;\n  /** When paginating forwards, are there more items? */\n  hasNextPage: Scalars['Boolean'];\n  /** When paginating backwards, are there more items? */\n  hasPreviousPage: Scalars['Boolean'];\n  /** When paginating backwards, the cursor to continue. */\n  startCursor?: Maybe<Scalars['String']>;\n};\n\nexport type GqlProgramState = {\n  __typename: 'ProgramState';\n  data: Scalars['HexString'];\n  returnType: GqlReturnType;\n};\n\nexport type GqlQuery = {\n  __typename: 'Query';\n  balance: GqlBalance;\n  balances: GqlBalanceConnection;\n  block?: Maybe<GqlBlock>;\n  blocks: GqlBlockConnection;\n  chain: GqlChainInfo;\n  coin?: Maybe<GqlCoin>;\n  coins: GqlCoinConnection;\n  contract?: Maybe<GqlContract>;\n  contractBalance: GqlContractBalance;\n  contractBalances: GqlContractBalanceConnection;\n  /** Returns true when the GraphQL API is serving requests. */\n  health: Scalars['Boolean'];\n  memory: Scalars['String'];\n  messageProof?: Maybe<GqlMessageProof>;\n  messages: GqlMessageConnection;\n  nodeInfo: GqlNodeInfo;\n  register: Scalars['U64'];\n  /**\n   * For each `query_per_asset`, get some spendable resources(of asset specified by the query) owned by\n   * `owner` that add up at least the query amount. The returned resources are actual resources\n   * that can be spent. The number of resources is optimized to prevent dust accumulation.\n   * Max number of resources and excluded resources can also be specified.\n   *\n   * Returns:\n   * The list of spendable resources per asset from the query. The length of the result is\n   * the same as the length of `query_per_asset`. The ordering of assets and `query_per_asset`\n   * is the same.\n   */\n  resourcesToSpend: Array<Array<GqlResource>>;\n  transaction?: Maybe<GqlTransaction>;\n  transactions: GqlTransactionConnection;\n  transactionsByOwner: GqlTransactionConnection;\n};\n\nexport type GqlQueryBalanceArgs = {\n  assetId: Scalars['AssetId'];\n  owner: Scalars['Address'];\n};\n\nexport type GqlQueryBalancesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filter: GqlBalanceFilterInput;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\nexport type GqlQueryBlockArgs = {\n  height?: InputMaybe<Scalars['U64']>;\n  id?: InputMaybe<Scalars['BlockId']>;\n};\n\nexport type GqlQueryBlocksArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\nexport type GqlQueryCoinArgs = {\n  utxoId: Scalars['UtxoId'];\n};\n\nexport type GqlQueryCoinsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filter: GqlCoinFilterInput;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\nexport type GqlQueryContractArgs = {\n  id: Scalars['ContractId'];\n};\n\nexport type GqlQueryContractBalanceArgs = {\n  asset: Scalars['AssetId'];\n  contract: Scalars['ContractId'];\n};\n\nexport type GqlQueryContractBalancesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filter: GqlContractBalanceFilterInput;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\nexport type GqlQueryMemoryArgs = {\n  id: Scalars['ID'];\n  size: Scalars['U64'];\n  start: Scalars['U64'];\n};\n\nexport type GqlQueryMessageProofArgs = {\n  messageId: Scalars['MessageId'];\n  transactionId: Scalars['TransactionId'];\n};\n\nexport type GqlQueryMessagesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  owner?: InputMaybe<Scalars['Address']>;\n};\n\nexport type GqlQueryRegisterArgs = {\n  id: Scalars['ID'];\n  register: Scalars['U64'];\n};\n\nexport type GqlQueryResourcesToSpendArgs = {\n  excludedIds?: InputMaybe<GqlExcludeInput>;\n  owner: Scalars['Address'];\n  queryPerAsset: Array<GqlSpendQueryElementInput>;\n};\n\nexport type GqlQueryTransactionArgs = {\n  id: Scalars['TransactionId'];\n};\n\nexport type GqlQueryTransactionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\nexport type GqlQueryTransactionsByOwnerArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  owner: Scalars['Address'];\n};\n\nexport type GqlReceipt = {\n  __typename: 'Receipt';\n  amount?: Maybe<Scalars['U64']>;\n  assetId?: Maybe<Scalars['AssetId']>;\n  contract?: Maybe<GqlContract>;\n  contractId?: Maybe<Scalars['ContractId']>;\n  data?: Maybe<Scalars['HexString']>;\n  digest?: Maybe<Scalars['Bytes32']>;\n  gas?: Maybe<Scalars['U64']>;\n  gasUsed?: Maybe<Scalars['U64']>;\n  is?: Maybe<Scalars['U64']>;\n  len?: Maybe<Scalars['U64']>;\n  messageId?: Maybe<Scalars['MessageId']>;\n  nonce?: Maybe<Scalars['Bytes32']>;\n  param1?: Maybe<Scalars['U64']>;\n  param2?: Maybe<Scalars['U64']>;\n  pc?: Maybe<Scalars['U64']>;\n  ptr?: Maybe<Scalars['U64']>;\n  ra?: Maybe<Scalars['U64']>;\n  rawPayload: Scalars['HexString'];\n  rb?: Maybe<Scalars['U64']>;\n  rc?: Maybe<Scalars['U64']>;\n  rd?: Maybe<Scalars['U64']>;\n  reason?: Maybe<Scalars['U64']>;\n  receiptType: GqlReceiptType;\n  recipient?: Maybe<Scalars['Address']>;\n  result?: Maybe<Scalars['U64']>;\n  sender?: Maybe<Scalars['Address']>;\n  to?: Maybe<GqlContract>;\n  toAddress?: Maybe<Scalars['Address']>;\n  val?: Maybe<Scalars['U64']>;\n};\n\nexport enum GqlReceiptType {\n  Call = 'CALL',\n  Log = 'LOG',\n  LogData = 'LOG_DATA',\n  MessageOut = 'MESSAGE_OUT',\n  Panic = 'PANIC',\n  Return = 'RETURN',\n  ReturnData = 'RETURN_DATA',\n  Revert = 'REVERT',\n  ScriptResult = 'SCRIPT_RESULT',\n  Transfer = 'TRANSFER',\n  TransferOut = 'TRANSFER_OUT',\n}\n\n/** The schema analog of the [`crate::database::utils::Resource`]. */\nexport type GqlResource = GqlCoin | GqlMessage;\n\nexport enum GqlReturnType {\n  Return = 'RETURN',\n  ReturnData = 'RETURN_DATA',\n  Revert = 'REVERT',\n}\n\nexport type GqlRunResult = {\n  __typename: 'RunResult';\n  breakpoint?: Maybe<GqlOutputBreakpoint>;\n  jsonReceipts: Array<Scalars['String']>;\n  state: GqlRunState;\n};\n\nexport enum GqlRunState {\n  /** Stopped on a breakpoint */\n  Breakpoint = 'BREAKPOINT',\n  /** All breakpoints have been processed, and the program has terminated */\n  Completed = 'COMPLETED',\n}\n\nexport type GqlSpendQueryElementInput = {\n  /** Target amount for the query. */\n  amount: Scalars['U64'];\n  /** Identifier of the asset to spend. */\n  assetId: Scalars['AssetId'];\n  /** The maximum number of currencies for selection. */\n  max?: InputMaybe<Scalars['U64']>;\n};\n\nexport type GqlSubmittedStatus = {\n  __typename: 'SubmittedStatus';\n  time: Scalars['DateTime'];\n};\n\nexport type GqlSuccessStatus = {\n  __typename: 'SuccessStatus';\n  block: GqlBlock;\n  programState?: Maybe<GqlProgramState>;\n  time: Scalars['DateTime'];\n};\n\nexport type GqlTimeParameters = {\n  /** The time interval between subsequent blocks */\n  blockTimeInterval: Scalars['U64'];\n  /** The time to set on the first block */\n  startTime: Scalars['U64'];\n};\n\nexport type GqlTransaction = {\n  __typename: 'Transaction';\n  bytecodeLength?: Maybe<Scalars['U64']>;\n  bytecodeWitnessIndex?: Maybe<Scalars['Int']>;\n  gasLimit?: Maybe<Scalars['U64']>;\n  gasPrice?: Maybe<Scalars['U64']>;\n  id: Scalars['TransactionId'];\n  inputAssetIds?: Maybe<Array<Scalars['AssetId']>>;\n  inputContracts?: Maybe<Array<GqlContract>>;\n  inputs?: Maybe<Array<GqlInput>>;\n  isCreate: Scalars['Boolean'];\n  isMint: Scalars['Boolean'];\n  isScript: Scalars['Boolean'];\n  maturity?: Maybe<Scalars['U64']>;\n  outputs: Array<GqlOutput>;\n  /** Return the transaction bytes using canonical encoding */\n  rawPayload: Scalars['HexString'];\n  receipts?: Maybe<Array<GqlReceipt>>;\n  receiptsRoot?: Maybe<Scalars['Bytes32']>;\n  salt?: Maybe<Scalars['Salt']>;\n  script?: Maybe<Scalars['HexString']>;\n  scriptData?: Maybe<Scalars['HexString']>;\n  status?: Maybe<GqlTransactionStatus>;\n  storageSlots?: Maybe<Array<Scalars['HexString']>>;\n  txPointer?: Maybe<Scalars['TxPointer']>;\n  witnesses?: Maybe<Array<Scalars['HexString']>>;\n};\n\nexport type GqlTransactionConnection = {\n  __typename: 'TransactionConnection';\n  /** A list of edges. */\n  edges: Array<GqlTransactionEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlTransaction>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlTransactionEdge = {\n  __typename: 'TransactionEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlTransaction;\n};\n\nexport type GqlTransactionStatus = GqlFailureStatus | GqlSubmittedStatus | GqlSuccessStatus;\n\nexport type GqlVariableOutput = {\n  __typename: 'VariableOutput';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  to: Scalars['Address'];\n};\n\nexport type GqlTransactionFragmentFragment = {\n  __typename: 'Transaction';\n  id: string;\n  rawPayload: string;\n  gasPrice?: string | null;\n  status?:\n    | {\n        __typename: 'FailureStatus';\n        time: string;\n        reason: string;\n        type: 'FailureStatus';\n        block: { __typename: 'Block'; id: string };\n      }\n    | { __typename: 'SubmittedStatus'; time: string; type: 'SubmittedStatus' }\n    | {\n        __typename: 'SuccessStatus';\n        time: string;\n        type: 'SuccessStatus';\n        block: { __typename: 'Block'; id: string };\n        programState?: {\n          __typename: 'ProgramState';\n          returnType: GqlReturnType;\n          data: string;\n        } | null;\n      }\n    | null;\n};\n\nexport type GqlReceiptFragmentFragment = {\n  __typename: 'Receipt';\n  data?: string | null;\n  rawPayload: string;\n};\n\nexport type GqlBlockFragmentFragment = {\n  __typename: 'Block';\n  id: string;\n  header: { __typename: 'Header'; height: string; time: string };\n  transactions: Array<{ __typename: 'Transaction'; id: string }>;\n};\n\nexport type GqlCoinFragmentFragment = {\n  __typename: 'Coin';\n  utxoId: string;\n  owner: string;\n  amount: string;\n  assetId: string;\n  maturity: string;\n  status: GqlCoinStatus;\n  blockCreated: string;\n};\n\nexport type GqlMessageFragmentFragment = {\n  __typename: 'Message';\n  amount: string;\n  sender: string;\n  recipient: string;\n  data: string;\n  nonce: string;\n  daHeight: string;\n  fuelBlockSpend?: string | null;\n};\n\nexport type GqlMessageProofFragmentFragment = {\n  __typename: 'MessageProof';\n  proofSet: Array<string>;\n  proofIndex: string;\n  sender: string;\n  recipient: string;\n  nonce: string;\n  amount: string;\n  data: string;\n  signature: any;\n  header: {\n    __typename: 'Header';\n    id: string;\n    daHeight: string;\n    transactionsCount: string;\n    outputMessagesCount: string;\n    transactionsRoot: string;\n    outputMessagesRoot: string;\n    height: string;\n    prevRoot: string;\n    time: string;\n    applicationHash: string;\n  };\n};\n\nexport type GqlBalanceFragmentFragment = {\n  __typename: 'Balance';\n  owner: string;\n  amount: string;\n  assetId: string;\n};\n\nexport type GqlChainInfoFragmentFragment = {\n  __typename: 'ChainInfo';\n  name: string;\n  baseChainHeight: string;\n  peerCount: number;\n  consensusParameters: {\n    __typename: 'ConsensusParameters';\n    gasPriceFactor: string;\n    maxGasPerTx: string;\n    maxScriptLength: string;\n  };\n  latestBlock: {\n    __typename: 'Block';\n    id: string;\n    header: { __typename: 'Header'; height: string; time: string };\n    transactions: Array<{ __typename: 'Transaction'; id: string }>;\n  };\n};\n\nexport type GqlGetVersionQueryVariables = Exact<{ [key: string]: never }>;\n\nexport type GqlGetVersionQuery = {\n  __typename: 'Query';\n  nodeInfo: { __typename: 'NodeInfo'; nodeVersion: string };\n};\n\nexport type GqlGetInfoQueryVariables = Exact<{ [key: string]: never }>;\n\nexport type GqlGetInfoQuery = {\n  __typename: 'Query';\n  nodeInfo: { __typename: 'NodeInfo'; nodeVersion: string; minGasPrice: string };\n};\n\nexport type GqlGetChainQueryVariables = Exact<{ [key: string]: never }>;\n\nexport type GqlGetChainQuery = {\n  __typename: 'Query';\n  chain: {\n    __typename: 'ChainInfo';\n    name: string;\n    baseChainHeight: string;\n    peerCount: number;\n    consensusParameters: {\n      __typename: 'ConsensusParameters';\n      gasPriceFactor: string;\n      maxGasPerTx: string;\n      maxScriptLength: string;\n    };\n    latestBlock: {\n      __typename: 'Block';\n      id: string;\n      header: { __typename: 'Header'; height: string; time: string };\n      transactions: Array<{ __typename: 'Transaction'; id: string }>;\n    };\n  };\n};\n\nexport type GqlGetTransactionQueryVariables = Exact<{\n  transactionId: Scalars['TransactionId'];\n}>;\n\nexport type GqlGetTransactionQuery = {\n  __typename: 'Query';\n  transaction?: {\n    __typename: 'Transaction';\n    id: string;\n    rawPayload: string;\n    gasPrice?: string | null;\n    status?:\n      | {\n          __typename: 'FailureStatus';\n          time: string;\n          reason: string;\n          type: 'FailureStatus';\n          block: { __typename: 'Block'; id: string };\n        }\n      | { __typename: 'SubmittedStatus'; time: string; type: 'SubmittedStatus' }\n      | {\n          __typename: 'SuccessStatus';\n          time: string;\n          type: 'SuccessStatus';\n          block: { __typename: 'Block'; id: string };\n          programState?: {\n            __typename: 'ProgramState';\n            returnType: GqlReturnType;\n            data: string;\n          } | null;\n        }\n      | null;\n  } | null;\n};\n\nexport type GqlGetTransactionWithReceiptsQueryVariables = Exact<{\n  transactionId: Scalars['TransactionId'];\n}>;\n\nexport type GqlGetTransactionWithReceiptsQuery = {\n  __typename: 'Query';\n  transaction?: {\n    __typename: 'Transaction';\n    id: string;\n    rawPayload: string;\n    gasPrice?: string | null;\n    receipts?: Array<{ __typename: 'Receipt'; data?: string | null; rawPayload: string }> | null;\n    status?:\n      | {\n          __typename: 'FailureStatus';\n          time: string;\n          reason: string;\n          type: 'FailureStatus';\n          block: { __typename: 'Block'; id: string };\n        }\n      | { __typename: 'SubmittedStatus'; time: string; type: 'SubmittedStatus' }\n      | {\n          __typename: 'SuccessStatus';\n          time: string;\n          type: 'SuccessStatus';\n          block: { __typename: 'Block'; id: string };\n          programState?: {\n            __typename: 'ProgramState';\n            returnType: GqlReturnType;\n            data: string;\n          } | null;\n        }\n      | null;\n  } | null;\n};\n\nexport type GqlGetTransactionsQueryVariables = Exact<{\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetTransactionsQuery = {\n  __typename: 'Query';\n  transactions: {\n    __typename: 'TransactionConnection';\n    edges: Array<{\n      __typename: 'TransactionEdge';\n      node: {\n        __typename: 'Transaction';\n        id: string;\n        rawPayload: string;\n        gasPrice?: string | null;\n        status?:\n          | {\n              __typename: 'FailureStatus';\n              time: string;\n              reason: string;\n              type: 'FailureStatus';\n              block: { __typename: 'Block'; id: string };\n            }\n          | { __typename: 'SubmittedStatus'; time: string; type: 'SubmittedStatus' }\n          | {\n              __typename: 'SuccessStatus';\n              time: string;\n              type: 'SuccessStatus';\n              block: { __typename: 'Block'; id: string };\n              programState?: {\n                __typename: 'ProgramState';\n                returnType: GqlReturnType;\n                data: string;\n              } | null;\n            }\n          | null;\n      };\n    }>;\n  };\n};\n\nexport type GqlGetTransactionsByOwnerQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetTransactionsByOwnerQuery = {\n  __typename: 'Query';\n  transactionsByOwner: {\n    __typename: 'TransactionConnection';\n    edges: Array<{\n      __typename: 'TransactionEdge';\n      node: {\n        __typename: 'Transaction';\n        id: string;\n        rawPayload: string;\n        gasPrice?: string | null;\n        status?:\n          | {\n              __typename: 'FailureStatus';\n              time: string;\n              reason: string;\n              type: 'FailureStatus';\n              block: { __typename: 'Block'; id: string };\n            }\n          | { __typename: 'SubmittedStatus'; time: string; type: 'SubmittedStatus' }\n          | {\n              __typename: 'SuccessStatus';\n              time: string;\n              type: 'SuccessStatus';\n              block: { __typename: 'Block'; id: string };\n              programState?: {\n                __typename: 'ProgramState';\n                returnType: GqlReturnType;\n                data: string;\n              } | null;\n            }\n          | null;\n      };\n    }>;\n  };\n};\n\nexport type GqlGetBlockQueryVariables = Exact<{\n  blockId?: InputMaybe<Scalars['BlockId']>;\n  blockHeight?: InputMaybe<Scalars['U64']>;\n}>;\n\nexport type GqlGetBlockQuery = {\n  __typename: 'Query';\n  block?: {\n    __typename: 'Block';\n    id: string;\n    header: { __typename: 'Header'; height: string; time: string };\n    transactions: Array<{ __typename: 'Transaction'; id: string }>;\n  } | null;\n};\n\nexport type GqlGetBlockWithTransactionsQueryVariables = Exact<{\n  blockId?: InputMaybe<Scalars['BlockId']>;\n  blockHeight?: InputMaybe<Scalars['U64']>;\n}>;\n\nexport type GqlGetBlockWithTransactionsQuery = {\n  __typename: 'Query';\n  block?: {\n    __typename: 'Block';\n    id: string;\n    transactions: Array<{\n      __typename: 'Transaction';\n      id: string;\n      rawPayload: string;\n      gasPrice?: string | null;\n      status?:\n        | {\n            __typename: 'FailureStatus';\n            time: string;\n            reason: string;\n            type: 'FailureStatus';\n            block: { __typename: 'Block'; id: string };\n          }\n        | { __typename: 'SubmittedStatus'; time: string; type: 'SubmittedStatus' }\n        | {\n            __typename: 'SuccessStatus';\n            time: string;\n            type: 'SuccessStatus';\n            block: { __typename: 'Block'; id: string };\n            programState?: {\n              __typename: 'ProgramState';\n              returnType: GqlReturnType;\n              data: string;\n            } | null;\n          }\n        | null;\n    }>;\n    header: { __typename: 'Header'; height: string; time: string };\n  } | null;\n};\n\nexport type GqlGetBlocksQueryVariables = Exact<{\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetBlocksQuery = {\n  __typename: 'Query';\n  blocks: {\n    __typename: 'BlockConnection';\n    edges: Array<{\n      __typename: 'BlockEdge';\n      node: {\n        __typename: 'Block';\n        id: string;\n        header: { __typename: 'Header'; height: string; time: string };\n        transactions: Array<{ __typename: 'Transaction'; id: string }>;\n      };\n    }>;\n  };\n};\n\nexport type GqlGetCoinQueryVariables = Exact<{\n  coinId: Scalars['UtxoId'];\n}>;\n\nexport type GqlGetCoinQuery = {\n  __typename: 'Query';\n  coin?: {\n    __typename: 'Coin';\n    utxoId: string;\n    owner: string;\n    amount: string;\n    assetId: string;\n    maturity: string;\n    status: GqlCoinStatus;\n    blockCreated: string;\n  } | null;\n};\n\nexport type GqlGetCoinsQueryVariables = Exact<{\n  filter: GqlCoinFilterInput;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetCoinsQuery = {\n  __typename: 'Query';\n  coins: {\n    __typename: 'CoinConnection';\n    edges: Array<{\n      __typename: 'CoinEdge';\n      node: {\n        __typename: 'Coin';\n        utxoId: string;\n        owner: string;\n        amount: string;\n        assetId: string;\n        maturity: string;\n        status: GqlCoinStatus;\n        blockCreated: string;\n      };\n    }>;\n  };\n};\n\nexport type GqlGetResourcesToSpendQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  queryPerAsset: Array<GqlSpendQueryElementInput> | GqlSpendQueryElementInput;\n  excludedIds?: InputMaybe<GqlExcludeInput>;\n}>;\n\nexport type GqlGetResourcesToSpendQuery = {\n  __typename: 'Query';\n  resourcesToSpend: Array<\n    Array<\n      | {\n          __typename: 'Coin';\n          utxoId: string;\n          owner: string;\n          amount: string;\n          assetId: string;\n          maturity: string;\n          status: GqlCoinStatus;\n          blockCreated: string;\n        }\n      | {\n          __typename: 'Message';\n          amount: string;\n          sender: string;\n          recipient: string;\n          data: string;\n          nonce: string;\n          daHeight: string;\n          fuelBlockSpend?: string | null;\n        }\n    >\n  >;\n};\n\nexport type GqlGetContractQueryVariables = Exact<{\n  contractId: Scalars['ContractId'];\n}>;\n\nexport type GqlGetContractQuery = {\n  __typename: 'Query';\n  contract?: { __typename: 'Contract'; bytecode: string; id: string } | null;\n};\n\nexport type GqlGetBalanceQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  assetId: Scalars['AssetId'];\n}>;\n\nexport type GqlGetBalanceQuery = {\n  __typename: 'Query';\n  balance: { __typename: 'Balance'; owner: string; amount: string; assetId: string };\n};\n\nexport type GqlGetBalancesQueryVariables = Exact<{\n  filter: GqlBalanceFilterInput;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetBalancesQuery = {\n  __typename: 'Query';\n  balances: {\n    __typename: 'BalanceConnection';\n    edges: Array<{\n      __typename: 'BalanceEdge';\n      node: { __typename: 'Balance'; owner: string; amount: string; assetId: string };\n    }>;\n  };\n};\n\nexport type GqlGetMessagesQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\nexport type GqlGetMessagesQuery = {\n  __typename: 'Query';\n  messages: {\n    __typename: 'MessageConnection';\n    edges: Array<{\n      __typename: 'MessageEdge';\n      node: {\n        __typename: 'Message';\n        amount: string;\n        sender: string;\n        recipient: string;\n        data: string;\n        nonce: string;\n        daHeight: string;\n        fuelBlockSpend?: string | null;\n      };\n    }>;\n  };\n};\n\nexport type GqlGetMessageProofQueryVariables = Exact<{\n  transactionId: Scalars['TransactionId'];\n  messageId: Scalars['MessageId'];\n}>;\n\nexport type GqlGetMessageProofQuery = {\n  __typename: 'Query';\n  messageProof?: {\n    __typename: 'MessageProof';\n    proofSet: Array<string>;\n    proofIndex: string;\n    sender: string;\n    recipient: string;\n    nonce: string;\n    amount: string;\n    data: string;\n    signature: any;\n    header: {\n      __typename: 'Header';\n      id: string;\n      daHeight: string;\n      transactionsCount: string;\n      outputMessagesCount: string;\n      transactionsRoot: string;\n      outputMessagesRoot: string;\n      height: string;\n      prevRoot: string;\n      time: string;\n      applicationHash: string;\n    };\n  } | null;\n};\n\nexport type GqlDryRunMutationVariables = Exact<{\n  encodedTransaction: Scalars['HexString'];\n  utxoValidation?: InputMaybe<Scalars['Boolean']>;\n}>;\n\nexport type GqlDryRunMutation = {\n  __typename: 'Mutation';\n  dryRun: Array<{ __typename: 'Receipt'; data?: string | null; rawPayload: string }>;\n};\n\nexport type GqlSubmitMutationVariables = Exact<{\n  encodedTransaction: Scalars['HexString'];\n}>;\n\nexport type GqlSubmitMutation = {\n  __typename: 'Mutation';\n  submit: { __typename: 'Transaction'; id: string };\n};\n\nexport type GqlStartSessionMutationVariables = Exact<{ [key: string]: never }>;\n\nexport type GqlStartSessionMutation = { __typename: 'Mutation'; startSession: string };\n\nexport type GqlEndSessionMutationVariables = Exact<{\n  sessionId: Scalars['ID'];\n}>;\n\nexport type GqlEndSessionMutation = { __typename: 'Mutation'; endSession: boolean };\n\nexport type GqlExecuteMutationVariables = Exact<{\n  sessionId: Scalars['ID'];\n  op: Scalars['String'];\n}>;\n\nexport type GqlExecuteMutation = { __typename: 'Mutation'; execute: boolean };\n\nexport type GqlResetMutationVariables = Exact<{\n  sessionId: Scalars['ID'];\n}>;\n\nexport type GqlResetMutation = { __typename: 'Mutation'; reset: boolean };\n\nexport const TransactionFragmentFragmentDoc = gql`\n  fragment transactionFragment on Transaction {\n    id\n    rawPayload\n    gasPrice\n    status {\n      type: __typename\n      ... on SubmittedStatus {\n        time\n      }\n      ... on SuccessStatus {\n        block {\n          id\n        }\n        time\n        programState {\n          returnType\n          data\n        }\n      }\n      ... on FailureStatus {\n        block {\n          id\n        }\n        time\n        reason\n      }\n    }\n  }\n`;\nexport const ReceiptFragmentFragmentDoc = gql`\n  fragment receiptFragment on Receipt {\n    data\n    rawPayload\n  }\n`;\nexport const CoinFragmentFragmentDoc = gql`\n  fragment coinFragment on Coin {\n    utxoId\n    owner\n    amount\n    assetId\n    maturity\n    status\n    blockCreated\n  }\n`;\nexport const MessageFragmentFragmentDoc = gql`\n  fragment messageFragment on Message {\n    amount\n    sender\n    recipient\n    data\n    nonce\n    daHeight\n    fuelBlockSpend\n  }\n`;\nexport const MessageProofFragmentFragmentDoc = gql`\n  fragment messageProofFragment on MessageProof {\n    proofSet\n    proofIndex\n    sender\n    recipient\n    nonce\n    amount\n    data\n    signature\n    header {\n      id\n      daHeight\n      transactionsCount\n      outputMessagesCount\n      transactionsRoot\n      outputMessagesRoot\n      height\n      prevRoot\n      time\n      applicationHash\n    }\n  }\n`;\nexport const BalanceFragmentFragmentDoc = gql`\n  fragment balanceFragment on Balance {\n    owner\n    amount\n    assetId\n  }\n`;\nexport const BlockFragmentFragmentDoc = gql`\n  fragment blockFragment on Block {\n    id\n    header {\n      height\n      time\n    }\n    transactions {\n      id\n    }\n  }\n`;\nexport const ChainInfoFragmentFragmentDoc = gql`\n  fragment chainInfoFragment on ChainInfo {\n    name\n    baseChainHeight\n    peerCount\n    consensusParameters {\n      gasPriceFactor\n      maxGasPerTx\n      maxGasPerTx\n      maxScriptLength\n    }\n    latestBlock {\n      ...blockFragment\n    }\n  }\n  ${BlockFragmentFragmentDoc}\n`;\nexport const GetVersionDocument = gql`\n  query getVersion {\n    nodeInfo {\n      nodeVersion\n    }\n  }\n`;\nexport const GetInfoDocument = gql`\n  query getInfo {\n    nodeInfo {\n      nodeVersion\n      minGasPrice\n    }\n  }\n`;\nexport const GetChainDocument = gql`\n  query getChain {\n    chain {\n      ...chainInfoFragment\n    }\n  }\n  ${ChainInfoFragmentFragmentDoc}\n`;\nexport const GetTransactionDocument = gql`\n  query getTransaction($transactionId: TransactionId!) {\n    transaction(id: $transactionId) {\n      ...transactionFragment\n    }\n  }\n  ${TransactionFragmentFragmentDoc}\n`;\nexport const GetTransactionWithReceiptsDocument = gql`\n  query getTransactionWithReceipts($transactionId: TransactionId!) {\n    transaction(id: $transactionId) {\n      ...transactionFragment\n      receipts {\n        ...receiptFragment\n      }\n    }\n  }\n  ${TransactionFragmentFragmentDoc}\n  ${ReceiptFragmentFragmentDoc}\n`;\nexport const GetTransactionsDocument = gql`\n  query getTransactions($after: String, $before: String, $first: Int, $last: Int) {\n    transactions(after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...transactionFragment\n        }\n      }\n    }\n  }\n  ${TransactionFragmentFragmentDoc}\n`;\nexport const GetTransactionsByOwnerDocument = gql`\n  query getTransactionsByOwner(\n    $owner: Address!\n    $after: String\n    $before: String\n    $first: Int\n    $last: Int\n  ) {\n    transactionsByOwner(owner: $owner, after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...transactionFragment\n        }\n      }\n    }\n  }\n  ${TransactionFragmentFragmentDoc}\n`;\nexport const GetBlockDocument = gql`\n  query getBlock($blockId: BlockId, $blockHeight: U64) {\n    block(id: $blockId, height: $blockHeight) {\n      ...blockFragment\n    }\n  }\n  ${BlockFragmentFragmentDoc}\n`;\nexport const GetBlockWithTransactionsDocument = gql`\n  query getBlockWithTransactions($blockId: BlockId, $blockHeight: U64) {\n    block(id: $blockId, height: $blockHeight) {\n      ...blockFragment\n      transactions {\n        ...transactionFragment\n      }\n    }\n  }\n  ${BlockFragmentFragmentDoc}\n  ${TransactionFragmentFragmentDoc}\n`;\nexport const GetBlocksDocument = gql`\n  query getBlocks($after: String, $before: String, $first: Int, $last: Int) {\n    blocks(after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...blockFragment\n        }\n      }\n    }\n  }\n  ${BlockFragmentFragmentDoc}\n`;\nexport const GetCoinDocument = gql`\n  query getCoin($coinId: UtxoId!) {\n    coin(utxoId: $coinId) {\n      ...coinFragment\n    }\n  }\n  ${CoinFragmentFragmentDoc}\n`;\nexport const GetCoinsDocument = gql`\n  query getCoins(\n    $filter: CoinFilterInput!\n    $after: String\n    $before: String\n    $first: Int\n    $last: Int\n  ) {\n    coins(filter: $filter, after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...coinFragment\n        }\n      }\n    }\n  }\n  ${CoinFragmentFragmentDoc}\n`;\nexport const GetResourcesToSpendDocument = gql`\n  query getResourcesToSpend(\n    $owner: Address!\n    $queryPerAsset: [SpendQueryElementInput!]!\n    $excludedIds: ExcludeInput\n  ) {\n    resourcesToSpend(owner: $owner, queryPerAsset: $queryPerAsset, excludedIds: $excludedIds) {\n      ...coinFragment\n      ...messageFragment\n    }\n  }\n  ${CoinFragmentFragmentDoc}\n  ${MessageFragmentFragmentDoc}\n`;\nexport const GetContractDocument = gql`\n  query getContract($contractId: ContractId!) {\n    contract(id: $contractId) {\n      bytecode\n      id\n    }\n  }\n`;\nexport const GetBalanceDocument = gql`\n  query getBalance($owner: Address!, $assetId: AssetId!) {\n    balance(owner: $owner, assetId: $assetId) {\n      ...balanceFragment\n    }\n  }\n  ${BalanceFragmentFragmentDoc}\n`;\nexport const GetBalancesDocument = gql`\n  query getBalances(\n    $filter: BalanceFilterInput!\n    $after: String\n    $before: String\n    $first: Int\n    $last: Int\n  ) {\n    balances(filter: $filter, after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...balanceFragment\n        }\n      }\n    }\n  }\n  ${BalanceFragmentFragmentDoc}\n`;\nexport const GetMessagesDocument = gql`\n  query getMessages($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {\n    messages(owner: $owner, after: $after, before: $before, first: $first, last: $last) {\n      edges {\n        node {\n          ...messageFragment\n        }\n      }\n    }\n  }\n  ${MessageFragmentFragmentDoc}\n`;\nexport const GetMessageProofDocument = gql`\n  query getMessageProof($transactionId: TransactionId!, $messageId: MessageId!) {\n    messageProof(transactionId: $transactionId, messageId: $messageId) {\n      ...messageProofFragment\n    }\n  }\n  ${MessageProofFragmentFragmentDoc}\n`;\nexport const DryRunDocument = gql`\n  mutation dryRun($encodedTransaction: HexString!, $utxoValidation: Boolean) {\n    dryRun(tx: $encodedTransaction, utxoValidation: $utxoValidation) {\n      ...receiptFragment\n    }\n  }\n  ${ReceiptFragmentFragmentDoc}\n`;\nexport const SubmitDocument = gql`\n  mutation submit($encodedTransaction: HexString!) {\n    submit(tx: $encodedTransaction) {\n      id\n    }\n  }\n`;\nexport const StartSessionDocument = gql`\n  mutation startSession {\n    startSession\n  }\n`;\nexport const EndSessionDocument = gql`\n  mutation endSession($sessionId: ID!) {\n    endSession(id: $sessionId)\n  }\n`;\nexport const ExecuteDocument = gql`\n  mutation execute($sessionId: ID!, $op: String!) {\n    execute(id: $sessionId, op: $op)\n  }\n`;\nexport const ResetDocument = gql`\n  mutation reset($sessionId: ID!) {\n    reset(id: $sessionId)\n  }\n`;\n\nexport type SdkFunctionWrapper = <T>(\n  action: (requestHeaders?: Record<string, string>) => Promise<T>,\n  operationName: string,\n  operationType?: string\n) => Promise<T>;\n\nconst defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType) => action();\n\nexport function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {\n  return {\n    getVersion(\n      variables?: GqlGetVersionQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetVersionQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetVersionQuery>(GetVersionDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getVersion',\n        'query'\n      );\n    },\n    getInfo(\n      variables?: GqlGetInfoQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetInfoQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetInfoQuery>(GetInfoDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getInfo',\n        'query'\n      );\n    },\n    getChain(\n      variables?: GqlGetChainQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetChainQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetChainQuery>(GetChainDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getChain',\n        'query'\n      );\n    },\n    getTransaction(\n      variables: GqlGetTransactionQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetTransactionQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetTransactionQuery>(GetTransactionDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getTransaction',\n        'query'\n      );\n    },\n    getTransactionWithReceipts(\n      variables: GqlGetTransactionWithReceiptsQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetTransactionWithReceiptsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetTransactionWithReceiptsQuery>(\n            GetTransactionWithReceiptsDocument,\n            variables,\n            { ...requestHeaders, ...wrappedRequestHeaders }\n          ),\n        'getTransactionWithReceipts',\n        'query'\n      );\n    },\n    getTransactions(\n      variables?: GqlGetTransactionsQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetTransactionsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetTransactionsQuery>(GetTransactionsDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getTransactions',\n        'query'\n      );\n    },\n    getTransactionsByOwner(\n      variables: GqlGetTransactionsByOwnerQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetTransactionsByOwnerQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetTransactionsByOwnerQuery>(\n            GetTransactionsByOwnerDocument,\n            variables,\n            { ...requestHeaders, ...wrappedRequestHeaders }\n          ),\n        'getTransactionsByOwner',\n        'query'\n      );\n    },\n    getBlock(\n      variables?: GqlGetBlockQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetBlockQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetBlockQuery>(GetBlockDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getBlock',\n        'query'\n      );\n    },\n    getBlockWithTransactions(\n      variables?: GqlGetBlockWithTransactionsQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetBlockWithTransactionsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetBlockWithTransactionsQuery>(\n            GetBlockWithTransactionsDocument,\n            variables,\n            { ...requestHeaders, ...wrappedRequestHeaders }\n          ),\n        'getBlockWithTransactions',\n        'query'\n      );\n    },\n    getBlocks(\n      variables?: GqlGetBlocksQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetBlocksQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetBlocksQuery>(GetBlocksDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getBlocks',\n        'query'\n      );\n    },\n    getCoin(\n      variables: GqlGetCoinQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetCoinQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetCoinQuery>(GetCoinDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getCoin',\n        'query'\n      );\n    },\n    getCoins(\n      variables: GqlGetCoinsQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetCoinsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetCoinsQuery>(GetCoinsDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getCoins',\n        'query'\n      );\n    },\n    getResourcesToSpend(\n      variables: GqlGetResourcesToSpendQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetResourcesToSpendQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetResourcesToSpendQuery>(GetResourcesToSpendDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getResourcesToSpend',\n        'query'\n      );\n    },\n    getContract(\n      variables: GqlGetContractQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetContractQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetContractQuery>(GetContractDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getContract',\n        'query'\n      );\n    },\n    getBalance(\n      variables: GqlGetBalanceQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetBalanceQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetBalanceQuery>(GetBalanceDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getBalance',\n        'query'\n      );\n    },\n    getBalances(\n      variables: GqlGetBalancesQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetBalancesQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetBalancesQuery>(GetBalancesDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getBalances',\n        'query'\n      );\n    },\n    getMessages(\n      variables: GqlGetMessagesQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetMessagesQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetMessagesQuery>(GetMessagesDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getMessages',\n        'query'\n      );\n    },\n    getMessageProof(\n      variables: GqlGetMessageProofQueryVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlGetMessageProofQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlGetMessageProofQuery>(GetMessageProofDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'getMessageProof',\n        'query'\n      );\n    },\n    dryRun(\n      variables: GqlDryRunMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlDryRunMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlDryRunMutation>(DryRunDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'dryRun',\n        'mutation'\n      );\n    },\n    submit(\n      variables: GqlSubmitMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlSubmitMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlSubmitMutation>(SubmitDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'submit',\n        'mutation'\n      );\n    },\n    startSession(\n      variables?: GqlStartSessionMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlStartSessionMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlStartSessionMutation>(StartSessionDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'startSession',\n        'mutation'\n      );\n    },\n    endSession(\n      variables: GqlEndSessionMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlEndSessionMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlEndSessionMutation>(EndSessionDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'endSession',\n        'mutation'\n      );\n    },\n    execute(\n      variables: GqlExecuteMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlExecuteMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlExecuteMutation>(ExecuteDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'execute',\n        'mutation'\n      );\n    },\n    reset(\n      variables: GqlResetMutationVariables,\n      requestHeaders?: Dom.RequestInit['headers']\n    ): Promise<GqlResetMutation> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<GqlResetMutation>(ResetDocument, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        'reset',\n        'mutation'\n      );\n    },\n  };\n}\nexport type Sdk = ReturnType<typeof getSdk>;\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport type { Network } from '@ethersproject/networks';\nimport type { InputValue } from '@fuel-ts/abi-coder';\nimport { AbiCoder } from '@fuel-ts/abi-coder';\nimport { Address } from '@fuel-ts/address';\nimport { NativeAssetId } from '@fuel-ts/constants';\nimport type { AbstractAddress, AbstractPredicate } from '@fuel-ts/interfaces';\nimport type { BigNumberish, BN } from '@fuel-ts/math';\nimport { max, bn } from '@fuel-ts/math';\nimport type { Transaction } from '@fuel-ts/transactions';\nimport {\n  TransactionType,\n  InputMessageCoder,\n  MAX_GAS_PER_TX,\n  ReceiptType,\n  ReceiptCoder,\n  TransactionCoder,\n} from '@fuel-ts/transactions';\nimport { GraphQLClient } from 'graphql-request';\nimport cloneDeep from 'lodash.clonedeep';\n\nimport type {\n  GqlChainInfoFragmentFragment,\n  GqlGetInfoQuery,\n  GqlReceiptFragmentFragment,\n} from './__generated__/operations';\nimport { getSdk as getOperationsSdk } from './__generated__/operations';\nimport type { Coin } from './coin';\nimport type { CoinQuantity, CoinQuantityLike } from './coin-quantity';\nimport { coinQuantityfy } from './coin-quantity';\nimport type { Message, MessageProof } from './message';\nimport type { ExcludeResourcesOption, Resource } from './resource';\nimport { isRawCoin } from './resource';\nimport { ScriptTransactionRequest, transactionRequestify } from './transaction-request';\nimport type { TransactionRequestLike, TransactionRequest } from './transaction-request';\nimport type {\n  TransactionResult,\n  TransactionResultReceipt,\n} from './transaction-response/transaction-response';\nimport { TransactionResponse } from './transaction-response/transaction-response';\nimport { calculateTransactionFee, getReceiptsWithMissingData } from './util';\n\nconst MAX_RETRIES = 10;\n\nexport type CallResult = {\n  receipts: TransactionResultReceipt[];\n};\n\n/**\n * A Fuel block\n */\nexport type Block = {\n  id: string;\n  height: BN;\n  time: string;\n  transactionIds: string[];\n};\n\n/**\n * Deployed Contract bytecode and contract id\n */\nexport type ContractResult = {\n  id: string;\n  bytecode: string;\n};\n\n/**\n * Chain information\n */\nexport type ChainInfo = {\n  name: string;\n  baseChainHeight: BN;\n  peerCount: number;\n  consensusParameters: {\n    gasPriceFactor: BN;\n    maxGasPerTx: BN;\n    maxScriptLength: BN;\n  };\n  latestBlock: {\n    id: string;\n    height: BN;\n    time: string;\n    transactions: Array<{ id: string }>;\n  };\n};\n\n/**\n * Node information\n */\nexport type NodeInfo = {\n  minGasPrice: BN;\n  nodeVersion: string;\n};\n\nexport type TransactionCost = {\n  minGasPrice: BN;\n  gasPrice: BN;\n  gasUsed: BN;\n  fee: BN;\n};\n\nconst processGqlReceipt = (gqlReceipt: GqlReceiptFragmentFragment): TransactionResultReceipt => {\n  const receipt = new ReceiptCoder().decode(arrayify(gqlReceipt.rawPayload), 0)[0];\n\n  switch (receipt.type) {\n    case ReceiptType.ReturnData: {\n      return {\n        ...receipt,\n        data: gqlReceipt.data!,\n      };\n    }\n    case ReceiptType.LogData: {\n      return {\n        ...receipt,\n        data: gqlReceipt.data!,\n      };\n    }\n    default:\n      return receipt;\n  }\n};\n\nconst processGqlChain = (chain: GqlChainInfoFragmentFragment): ChainInfo => ({\n  name: chain.name,\n  baseChainHeight: bn(chain.baseChainHeight),\n  peerCount: chain.peerCount,\n  consensusParameters: {\n    gasPriceFactor: bn(chain.consensusParameters.gasPriceFactor),\n    maxGasPerTx: bn(chain.consensusParameters.maxGasPerTx),\n    maxScriptLength: bn(chain.consensusParameters.maxScriptLength),\n  },\n  latestBlock: {\n    id: chain.latestBlock.id,\n    height: bn(chain.latestBlock.header.height),\n    time: chain.latestBlock.header.time,\n    transactions: chain.latestBlock.transactions.map((i) => ({\n      id: i.id,\n    })),\n  },\n});\n\nconst processNodeInfo = (nodeInfo: GqlGetInfoQuery['nodeInfo']) => ({\n  minGasPrice: bn(nodeInfo.minGasPrice),\n  nodeVersion: nodeInfo.nodeVersion,\n});\n\n/**\n * Cursor pagination arguments\n *\n * https://relay.dev/graphql/connections.htm#sec-Arguments\n */\nexport type CursorPaginationArgs = {\n  /** Forward pagination limit */\n  first?: number | null;\n  /** Forward pagination cursor */\n  after?: string | null;\n  /** Backward pagination limit  */\n  last?: number | null;\n  /** Backward pagination cursor */\n  before?: string | null;\n};\n\nexport type BuildPredicateOptions = {\n  fundTransaction?: boolean;\n} & Pick<TransactionRequestLike, 'gasLimit' | 'gasPrice' | 'maturity'>;\n\n/**\n * Provider Call transaction params\n */\nexport type ProviderCallParams = {\n  utxoValidation?: boolean;\n};\n/**\n * A provider for connecting to a Fuel node\n */\nexport default class Provider {\n  operations: ReturnType<typeof getOperationsSdk>;\n\n  constructor(\n    /** GraphQL endpoint of the Fuel node */\n    public url: string\n  ) {\n    const gqlClient = new GraphQLClient(url);\n    this.operations = getOperationsSdk(gqlClient);\n  }\n\n  /**\n   * Returns the version of the connected Fuel node\n   */\n  async getVersion(): Promise<string> {\n    const {\n      nodeInfo: { nodeVersion },\n    } = await this.operations.getVersion();\n    return nodeVersion;\n  }\n\n  /**\n   * Returns the network configuration of the connected Fuel node\n   */\n  async getNetwork(): Promise<Network> {\n    return {\n      name: 'fuelv2',\n      chainId: 0xdeadbeef,\n    };\n  }\n\n  /**\n   * Returns the current block number\n   */\n  async getBlockNumber(): Promise<BN> {\n    const { chain } = await this.operations.getChain();\n    return bn(chain.latestBlock.header.height, 10);\n  }\n\n  /**\n   * Returns node information\n   */\n  async getNodeInfo(): Promise<NodeInfo> {\n    const { nodeInfo } = await this.operations.getInfo();\n    return processNodeInfo(nodeInfo);\n  }\n\n  /**\n   * Returns chain information\n   */\n  async getChain(): Promise<ChainInfo> {\n    const { chain } = await this.operations.getChain();\n    return processGqlChain(chain);\n  }\n\n  /**\n   * Submits a transaction to the chain to be executed\n   * If the transaction is missing VariableOuputs\n   * the transaction will be mutate and VariableOuputs will be added\n   */\n  async sendTransaction(\n    transactionRequestLike: TransactionRequestLike\n  ): Promise<TransactionResponse> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    await this.addMissingVariables(transactionRequest);\n\n    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());\n    const { gasUsed, minGasPrice } = await this.getTransactionCost(transactionRequest, 0);\n\n    // Fail transaction before submit to avoid submit failure\n    // Resulting in lost of funds on a OutOfGas situation.\n    if (bn(gasUsed).gt(bn(transactionRequest.gasLimit))) {\n      throw new Error(\n        `gasLimit(${transactionRequest.gasLimit}) is lower than the required (${gasUsed})`\n      );\n    } else if (bn(minGasPrice).gt(bn(transactionRequest.gasPrice))) {\n      throw new Error(\n        `gasPrice(${transactionRequest.gasPrice}) is lower than the required ${minGasPrice}`\n      );\n    }\n\n    const {\n      submit: { id: transactionId },\n    } = await this.operations.submit({ encodedTransaction });\n\n    const response = new TransactionResponse(transactionId, this);\n    return response;\n  }\n\n  /**\n   * Executes a transaction without actually submitting it to the chain\n   * If the transaction is missing VariableOuputs\n   * the transaction will be mutate and VariableOuputs will be added\n   */\n  async call(\n    transactionRequestLike: TransactionRequestLike,\n    { utxoValidation }: ProviderCallParams = {}\n  ): Promise<CallResult> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    await this.addMissingVariables(transactionRequest);\n\n    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());\n    const { dryRun: gqlReceipts } = await this.operations.dryRun({\n      encodedTransaction,\n      utxoValidation: utxoValidation || false,\n    });\n    const receipts = gqlReceipts.map(processGqlReceipt);\n    return {\n      receipts,\n    };\n  }\n\n  /**\n   * Will dryRun a transaction and check for missing VariableOutputs\n   *\n   * If there are missing VariableOutputs\n   * `addVariableOutputs` is called on the transaction.\n   * This process is done at most 10 times\n   */\n  addMissingVariables = async (transactionRequest: TransactionRequest): Promise<void> => {\n    let missingOutputVariableCount = 0;\n    let missingOutputContractIdsCount = 0;\n    let tries = 0;\n\n    if (transactionRequest.type === TransactionType.Create) {\n      return;\n    }\n\n    do {\n      const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());\n      const { dryRun: gqlReceipts } = await this.operations.dryRun({\n        encodedTransaction,\n        utxoValidation: false,\n      });\n      const receipts = gqlReceipts.map(processGqlReceipt);\n      const { missingOutputVariables, missingOutputContractIds } =\n        getReceiptsWithMissingData(receipts);\n\n      missingOutputVariableCount = missingOutputVariables.length;\n      missingOutputContractIdsCount = missingOutputContractIds.length;\n\n      if (missingOutputVariableCount === 0 && missingOutputContractIdsCount === 0) {\n        return;\n      }\n\n      transactionRequest.addVariableOutputs(missingOutputVariableCount);\n\n      missingOutputContractIds.forEach(({ contractId }) =>\n        transactionRequest.addContract(Address.fromString(contractId))\n      );\n      tries += 1;\n    } while (tries < MAX_RETRIES);\n  };\n\n  /**\n   * Executes a signed transaction without applying the states changes\n   * on the chain.\n   * If the transaction is missing VariableOuputs\n   * the transaction will be mutate and VariableOuputs will be added\n   */\n  async simulate(transactionRequestLike: TransactionRequestLike): Promise<CallResult> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    await this.addMissingVariables(transactionRequest);\n    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());\n    const { dryRun: gqlReceipts } = await this.operations.dryRun({\n      encodedTransaction,\n      utxoValidation: true,\n    });\n    const receipts = gqlReceipts.map(processGqlReceipt);\n    return {\n      receipts,\n    };\n  }\n\n  /**\n   * Returns a transaction cost to enable user\n   * to set gasLimit and also reserve balance amounts\n   * on the the transaction.\n   *\n   * The tolerance is add on top of the gasUsed calculated\n   * from the node, this create a safe margin costs like\n   * change states on transfer that don't occur on the dryRun\n   * transaction. The default value is 0.2 or 20%\n   */\n  async getTransactionCost(\n    transactionRequestLike: TransactionRequestLike,\n    tolerance: number = 0.2\n  ): Promise<TransactionCost> {\n    const transactionRequest = transactionRequestify(cloneDeep(transactionRequestLike));\n    const { minGasPrice } = await this.getNodeInfo();\n    const gasPrice = max(transactionRequest.gasPrice, minGasPrice);\n    const margin = 1 + tolerance;\n\n    // Set gasLimit to the maximum of the chain\n    // and gasPrice to 0 for measure\n    // Transaction without arrive to OutOfGas\n    transactionRequest.gasLimit = MAX_GAS_PER_TX;\n    transactionRequest.gasPrice = bn(0);\n\n    // Execute dryRun not validated transaction to query gasUsed\n    const { receipts } = await this.call(transactionRequest);\n    const { gasUsed, fee } = calculateTransactionFee({\n      gasPrice,\n      receipts,\n      margin,\n    });\n\n    return {\n      minGasPrice,\n      gasPrice,\n      gasUsed,\n      fee,\n    };\n  }\n\n  /**\n   * Returns coins for the given owner\n   */\n  async getCoins(\n    /** The address to get coins for */\n    owner: AbstractAddress,\n    /** The asset ID of coins to get */\n    assetId?: BytesLike,\n    /** Pagination arguments */\n    paginationArgs?: CursorPaginationArgs\n  ): Promise<Coin[]> {\n    const result = await this.operations.getCoins({\n      first: 10,\n      ...paginationArgs,\n      filter: { owner: owner.toB256(), assetId: assetId && hexlify(assetId) },\n    });\n\n    const coins = result.coins.edges!.map((edge) => edge!.node!);\n\n    return coins.map((coin) => ({\n      id: coin.utxoId,\n      assetId: coin.assetId,\n      amount: bn(coin.amount),\n      owner: Address.fromAddressOrString(coin.owner),\n      status: coin.status,\n      maturity: bn(coin.maturity).toNumber(),\n      blockCreated: bn(coin.blockCreated),\n    }));\n  }\n\n  /**\n   * Returns resources for the given owner satisfying the spend query\n   */\n  async getResourcesToSpend(\n    /** The address to get coins for */\n    owner: AbstractAddress,\n    /** The quantities to get */\n    quantities: CoinQuantityLike[],\n    /** IDs of excluded resources from the selection. */\n    excludedIds?: ExcludeResourcesOption\n  ): Promise<Resource[]> {\n    const excludeInput = {\n      messages: excludedIds?.messages?.map((id) => hexlify(id)) || [],\n      utxos: excludedIds?.utxos?.map((id) => hexlify(id)) || [],\n    };\n    const result = await this.operations.getResourcesToSpend({\n      owner: owner.toB256(),\n      queryPerAsset: quantities\n        .map(coinQuantityfy)\n        .map(({ assetId, amount, max: maxPerAsset }) => ({\n          assetId: hexlify(assetId),\n          amount: amount.toString(10),\n          max: maxPerAsset ? maxPerAsset.toString(10) : undefined,\n        })),\n      excludedIds: excludeInput,\n    });\n\n    return result.resourcesToSpend.flat().map((resource) => {\n      if (isRawCoin(resource)) {\n        return {\n          id: resource.utxoId,\n          amount: bn(resource.amount),\n          status: resource.status,\n          assetId: resource.assetId,\n          owner: Address.fromAddressOrString(resource.owner),\n          maturity: bn(resource.maturity).toNumber(),\n          blockCreated: bn(resource.blockCreated),\n        };\n      }\n\n      return {\n        sender: Address.fromAddressOrString(resource.sender),\n        recipient: Address.fromAddressOrString(resource.recipient),\n        nonce: bn(resource.nonce),\n        amount: bn(resource.amount),\n        data: InputMessageCoder.decodeData(resource.data),\n        daHeight: bn(resource.daHeight),\n        fuelBlockSpend: bn(resource.fuelBlockSpend),\n      };\n    });\n  }\n\n  /**\n   * Returns block matching the given ID or type\n   */\n  async getBlock(\n    /** ID or height of the block */\n    idOrHeight: string | number | 'latest'\n  ): Promise<Block | null> {\n    let variables;\n    if (typeof idOrHeight === 'number') {\n      variables = { blockHeight: bn(idOrHeight).toString(10) };\n    } else if (idOrHeight === 'latest') {\n      variables = { blockHeight: (await this.getBlockNumber()).toString(10) };\n    } else {\n      variables = { blockId: bn(idOrHeight).toString(10) };\n    }\n\n    const { block } = await this.operations.getBlock(variables);\n\n    if (!block) {\n      return null;\n    }\n\n    return {\n      id: block.id,\n      height: bn(block.header.height),\n      time: block.header.time,\n      transactionIds: block.transactions.map((tx) => tx.id),\n    };\n  }\n\n  /**\n   * Returns block matching the given ID or type, including transaction data\n   */\n  async getBlockWithTransactions(\n    /** ID or height of the block */\n    idOrHeight: string | number | 'latest'\n  ): Promise<(Block & { transactions: Transaction[] }) | null> {\n    let variables;\n    if (typeof idOrHeight === 'number') {\n      variables = { blockHeight: bn(idOrHeight).toString(10) };\n    } else if (idOrHeight === 'latest') {\n      variables = { blockHeight: (await this.getBlockNumber()).toString() };\n    } else {\n      variables = { blockId: idOrHeight };\n    }\n\n    const { block } = await this.operations.getBlockWithTransactions(variables);\n\n    if (!block) {\n      return null;\n    }\n\n    return {\n      id: block.id,\n      height: bn(block.header.height, 10),\n      time: block.header.time,\n      transactionIds: block.transactions.map((tx) => tx.id),\n      transactions: block.transactions.map(\n        (tx) => new TransactionCoder().decode(arrayify(tx.rawPayload), 0)?.[0]\n      ),\n    };\n  }\n\n  /**\n   * Get transaction with the given ID\n   */\n  async getTransaction(transactionId: string): Promise<Transaction | null> {\n    const { transaction } = await this.operations.getTransaction({ transactionId });\n    if (!transaction) {\n      return null;\n    }\n    return new TransactionCoder().decode(arrayify(transaction.rawPayload), 0)?.[0];\n  }\n\n  /**\n   * Get deployed contract with the given ID\n   *\n   * @returns contract bytecode and contract id\n   */\n  async getContract(contractId: string): Promise<ContractResult | null> {\n    const { contract } = await this.operations.getContract({ contractId });\n    if (!contract) {\n      return null;\n    }\n    return contract;\n  }\n\n  /**\n   * Returns the balance for the given owner for the given asset ID\n   */\n  async getBalance(\n    /** The address to get coins for */\n    owner: AbstractAddress,\n    /** The asset ID of coins to get */\n    assetId: BytesLike\n  ): Promise<BN> {\n    const { balance } = await this.operations.getBalance({\n      owner: owner.toB256(),\n      assetId: hexlify(assetId),\n    });\n    return bn(balance.amount, 10);\n  }\n\n  /**\n   * Returns balances for the given owner\n   */\n  async getBalances(\n    /** The address to get coins for */\n    owner: AbstractAddress,\n    /** Pagination arguments */\n    paginationArgs?: CursorPaginationArgs\n  ): Promise<CoinQuantity[]> {\n    const result = await this.operations.getBalances({\n      first: 10,\n      ...paginationArgs,\n      filter: { owner: owner.toB256() },\n    });\n\n    const balances = result.balances.edges!.map((edge) => edge!.node!);\n\n    return balances.map((balance) => ({\n      assetId: balance.assetId,\n      amount: bn(balance.amount),\n    }));\n  }\n\n  /**\n   * Returns message for the given address\n   */\n  async getMessages(\n    /** The address to get message from */\n    address: AbstractAddress,\n    /** Pagination arguments */\n    paginationArgs?: CursorPaginationArgs\n  ): Promise<Message[]> {\n    const result = await this.operations.getMessages({\n      first: 10,\n      ...paginationArgs,\n      owner: address.toB256(),\n    });\n\n    const messages = result.messages.edges!.map((edge) => edge!.node!);\n\n    return messages.map((message) => ({\n      sender: Address.fromAddressOrString(message.sender),\n      recipient: Address.fromAddressOrString(message.recipient),\n      nonce: bn(message.nonce),\n      amount: bn(message.amount),\n      data: InputMessageCoder.decodeData(message.data),\n      daHeight: bn(message.daHeight),\n      fuelBlockSpend: bn(message.fuelBlockSpend),\n    }));\n  }\n\n  /**\n   * Returns Message Proof for given transaction id and the message id from MessageOut receipt\n   */\n  async getMessageProof(\n    /** The transaction to get message from */\n    transactionId: string,\n    /** The message id from MessageOut receipt */\n    messageId: string\n  ): Promise<MessageProof | null> {\n    const result = await this.operations.getMessageProof({\n      transactionId,\n      messageId,\n    });\n\n    if (!result.messageProof) {\n      return null;\n    }\n\n    return {\n      proofSet: result.messageProof.proofSet,\n      proofIndex: bn(result.messageProof.proofIndex),\n      sender: Address.fromAddressOrString(result.messageProof.sender),\n      recipient: Address.fromAddressOrString(result.messageProof.recipient),\n      nonce: result.messageProof.nonce,\n      amount: bn(result.messageProof.amount),\n      data: result.messageProof.data,\n      signature: result.messageProof.signature,\n      header: {\n        id: result.messageProof.header.id,\n        daHeight: bn(result.messageProof.header.daHeight),\n        transactionsCount: bn(result.messageProof.header.transactionsCount),\n        outputMessagesCount: bn(result.messageProof.header.outputMessagesCount),\n        transactionsRoot: result.messageProof.header.transactionsRoot,\n        outputMessagesRoot: result.messageProof.header.outputMessagesRoot,\n        height: bn(result.messageProof.header.height),\n        prevRoot: result.messageProof.header.prevRoot,\n        time: result.messageProof.header.time,\n        applicationHash: result.messageProof.header.applicationHash,\n      },\n    };\n  }\n\n  async buildSpendPredicate(\n    predicate: AbstractPredicate,\n    amountToSpend: BigNumberish,\n    receiverAddress: AbstractAddress,\n    predicateData?: InputValue[],\n    assetId: BytesLike = NativeAssetId,\n    predicateOptions?: BuildPredicateOptions,\n    walletAddress?: AbstractAddress\n  ): Promise<ScriptTransactionRequest> {\n    const predicateResources: Resource[] = await this.getResourcesToSpend(predicate.address, [\n      [amountToSpend, assetId],\n    ]);\n    const options = {\n      fundTransaction: true,\n      ...predicateOptions,\n    };\n    const request = new ScriptTransactionRequest({\n      gasLimit: MAX_GAS_PER_TX,\n      ...options,\n    });\n\n    let encoded: undefined | Uint8Array;\n    if (predicateData && predicate.types) {\n      const abiCoder = new AbiCoder();\n      encoded = abiCoder.encode(predicate.types, predicateData);\n    }\n\n    const totalInPredicate: BN = predicateResources.reduce((prev: BN, coin: Resource) => {\n      request.addResource({\n        ...coin,\n        predicate: predicate.bytes,\n        predicateData: encoded,\n      } as unknown as Resource);\n      request.outputs = [];\n\n      return prev.add(coin.amount);\n    }, bn(0));\n\n    // output sent to receiver\n    request.addCoinOutput(receiverAddress, totalInPredicate, assetId);\n\n    const requiredCoinQuantities: CoinQuantityLike[] = [];\n    if (options.fundTransaction) {\n      requiredCoinQuantities.push(request.calculateFee());\n    }\n\n    if (requiredCoinQuantities.length && walletAddress) {\n      const resources = await this.getResourcesToSpend(walletAddress, requiredCoinQuantities);\n      request.addResources(resources);\n    }\n\n    return request;\n  }\n\n  async submitSpendPredicate(\n    predicate: AbstractPredicate,\n    amountToSpend: BigNumberish,\n    receiverAddress: AbstractAddress,\n    predicateData?: InputValue[],\n    assetId: BytesLike = NativeAssetId,\n    options?: BuildPredicateOptions,\n    walletAddress?: AbstractAddress\n  ): Promise<TransactionResult<'success'>> {\n    const request = await this.buildSpendPredicate(\n      predicate,\n      amountToSpend,\n      receiverAddress,\n      predicateData,\n      assetId,\n      options,\n      walletAddress\n    );\n\n    try {\n      const response = await this.sendTransaction(request);\n      return await response.waitForResult();\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (error: any) {\n      const errors: { message: string }[] = error?.response?.errors || [];\n      if (\n        errors.some(({ message }) =>\n          message.includes('unexpected block execution error TransactionValidity(InvalidPredicate')\n        )\n      ) {\n        throw new Error('Invalid Predicate');\n      }\n\n      throw error;\n    }\n  }\n}\n","import type { BytesLike } from '@ethersproject/bytes';\n\nimport type { GqlGetResourcesToSpendQuery, GqlCoinStatus } from './__generated__/operations';\nimport type { Coin } from './coin';\nimport type { Message } from './message';\n\nexport type RawCoin = {\n  utxoId: string;\n  owner: string;\n  amount: string;\n  assetId: string;\n  maturity: string;\n  status: GqlCoinStatus;\n  blockCreated: string;\n};\n\nexport type RawMessage = {\n  amount: string;\n  sender: string;\n  recipient: string;\n  data: string;\n  nonce: string;\n  daHeight: string;\n};\n\nexport type RawResource = RawCoin | RawMessage;\nexport type Resource = Coin | Message;\n\nexport type Resources = GqlGetResourcesToSpendQuery['resourcesToSpend'];\n\nexport type ExcludeResourcesOption = {\n  utxos?: BytesLike[];\n  messages?: BytesLike[];\n};\n\nexport const isRawCoin = (resource: RawResource): resource is RawCoin => 'utxoId' in resource;\nexport const isRawMessage = (resource: RawResource): resource is RawMessage =>\n  'recipient' in resource;\n\nexport const isCoin = (resource: Resource): resource is Coin => 'id' in resource;\nexport const isMessage = (resource: Resource): resource is Message => 'recipient' in resource;\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport { ZeroBytes32 } from '@fuel-ts/constants';\nimport type { BigNumberish } from '@fuel-ts/math';\nimport { bn, toNumber } from '@fuel-ts/math';\nimport type { Input } from '@fuel-ts/transactions';\nimport { InputType } from '@fuel-ts/transactions';\n\nexport type CoinTransactionRequestInput = {\n  type: InputType.Coin;\n\n  /** UTXO ID */\n  id: BytesLike;\n\n  /** Owning address or script hash */\n  owner: BytesLike;\n\n  /** Amount of coins */\n  amount: BigNumberish;\n\n  /** Asset ID of the coins */\n  assetId: BytesLike;\n\n  /** Points to the TX whose output is being spent. (TxPointer) */\n  txPointer: BytesLike;\n\n  /** Index of witness that authorizes spending the coin */\n  witnessIndex: number;\n\n  /** UTXO being spent must have been created at least this many blocks ago */\n  maturity?: number;\n\n  /** Predicate bytecode */\n  predicate?: BytesLike;\n\n  /** Predicate input data (parameters) */\n  predicateData?: BytesLike;\n};\nexport type MessageTransactionRequestInput = {\n  type: InputType.Message;\n\n  /** Amount of coins */\n  amount: BigNumberish;\n\n  /** Address of sender */\n  sender: BytesLike;\n\n  /** Address of sender */\n  recipient: BytesLike;\n\n  /** Index of witness that authorizes the message */\n  witnessIndex: number;\n\n  /** data of message */\n  data: BytesLike;\n\n  /** Unique nonce of message */\n  nonce: BigNumberish;\n\n  /** Predicate bytecode */\n  predicate?: BytesLike;\n\n  /** Predicate input data (parameters) */\n  predicateData?: BytesLike;\n};\nexport type ContractTransactionRequestInput = {\n  type: InputType.Contract;\n\n  /** Points to the TX whose output is being spent. (TxPointer) */\n  txPointer: BytesLike;\n\n  /** Contract ID */\n  contractId: BytesLike;\n};\nexport type TransactionRequestInput =\n  | CoinTransactionRequestInput\n  | ContractTransactionRequestInput\n  | MessageTransactionRequestInput;\n\nexport const inputify = (value: TransactionRequestInput): Input => {\n  switch (value.type) {\n    case InputType.Coin: {\n      const predicate = arrayify(value.predicate ?? '0x');\n      const predicateData = arrayify(value.predicateData ?? '0x');\n      return {\n        type: InputType.Coin,\n        utxoID: {\n          transactionId: hexlify(arrayify(value.id).slice(0, 32)),\n          outputIndex: arrayify(value.id)[32],\n        },\n        owner: hexlify(value.owner),\n        amount: bn(value.amount),\n        assetId: hexlify(value.assetId),\n        txPointer: {\n          blockHeight: toNumber(arrayify(value.txPointer).slice(0, 8)),\n          txIndex: toNumber(arrayify(value.txPointer).slice(8, 16)),\n        },\n        witnessIndex: value.witnessIndex,\n        maturity: value.maturity ?? 0,\n        predicateLength: predicate.length,\n        predicateDataLength: predicateData.length,\n        predicate: hexlify(predicate),\n        predicateData: hexlify(predicateData),\n      };\n    }\n    case InputType.Contract: {\n      return {\n        type: InputType.Contract,\n        utxoID: {\n          transactionId: ZeroBytes32,\n          outputIndex: 0,\n        },\n        balanceRoot: ZeroBytes32,\n        stateRoot: ZeroBytes32,\n        txPointer: {\n          blockHeight: toNumber(arrayify(value.txPointer).slice(0, 8)),\n          txIndex: toNumber(arrayify(value.txPointer).slice(8, 16)),\n        },\n        contractID: hexlify(value.contractId),\n      };\n    }\n    case InputType.Message: {\n      const predicate = arrayify(value.predicate ?? '0x');\n      const predicateData = arrayify(value.predicateData ?? '0x');\n      return {\n        type: InputType.Message,\n        sender: hexlify(value.sender),\n        recipient: hexlify(value.recipient),\n        amount: bn(value.amount),\n        nonce: bn(value.nonce),\n        witnessIndex: value.witnessIndex,\n        dataLength: value.data.length,\n        predicateLength: predicate.length,\n        predicateDataLength: predicateData.length,\n        data: hexlify(value.data),\n        predicate: hexlify(predicate),\n        predicateData: hexlify(predicateData),\n      };\n    }\n    default: {\n      throw new Error('Invalid Input type');\n    }\n  }\n};\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify } from '@ethersproject/bytes';\nimport { ZeroBytes32 } from '@fuel-ts/constants';\nimport type { BigNumberish } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport type { Output } from '@fuel-ts/transactions';\nimport { OutputType } from '@fuel-ts/transactions';\n\nexport type CoinTransactionRequestOutput = {\n  type: OutputType.Coin;\n  /** Receiving address or script hash */\n  to: BytesLike;\n  /** Amount of coins to send */\n  amount: BigNumberish;\n  /** Asset ID of coins */\n  assetId: BytesLike;\n};\nexport type ContractTransactionRequestOutput = {\n  type: OutputType.Contract;\n  /** Index of input contract */\n  inputIndex: number;\n};\nexport type MessageTransactionRequestOutput = {\n  type: OutputType.Message;\n  /** Receiving address */\n  recipient: BytesLike;\n  /** Amount of coins sent with message */\n  amount: BigNumberish;\n};\nexport type ChangeTransactionRequestOutput = {\n  type: OutputType.Change;\n  /** Receiving address or script hash */\n  to: BytesLike;\n  /** Asset ID of coins */\n  assetId: BytesLike;\n};\nexport type VariableTransactionRequestOutput = {\n  type: OutputType.Variable;\n};\nexport type ContractCreatedTransactionRequestOutput = {\n  type: OutputType.ContractCreated;\n  /** Contract ID */\n  contractId: BytesLike;\n  /** State Root */\n  stateRoot: BytesLike;\n};\nexport type TransactionRequestOutput =\n  | CoinTransactionRequestOutput\n  | ContractTransactionRequestOutput\n  | MessageTransactionRequestOutput\n  | ChangeTransactionRequestOutput\n  | VariableTransactionRequestOutput\n  | ContractCreatedTransactionRequestOutput;\n\nexport const outputify = (value: TransactionRequestOutput): Output => {\n  switch (value.type) {\n    case OutputType.Coin: {\n      return {\n        type: OutputType.Coin,\n        to: hexlify(value.to),\n        amount: bn(value.amount),\n        assetId: hexlify(value.assetId),\n      };\n    }\n    case OutputType.Contract: {\n      return {\n        type: OutputType.Contract,\n        inputIndex: value.inputIndex,\n        balanceRoot: ZeroBytes32,\n        stateRoot: ZeroBytes32,\n      };\n    }\n    case OutputType.Message: {\n      return {\n        type: OutputType.Message,\n        recipient: hexlify(value.recipient),\n        amount: bn(value.amount),\n      };\n    }\n    case OutputType.Change: {\n      return {\n        type: OutputType.Change,\n        to: hexlify(value.to),\n        amount: bn(0),\n        assetId: hexlify(value.assetId),\n      };\n    }\n    case OutputType.Variable: {\n      return {\n        type: OutputType.Variable,\n        to: ZeroBytes32,\n        amount: bn(0),\n        assetId: ZeroBytes32,\n      };\n    }\n    case OutputType.ContractCreated: {\n      return {\n        type: OutputType.ContractCreated,\n        contractId: hexlify(value.contractId),\n        stateRoot: hexlify(value.stateRoot),\n      };\n    }\n    default: {\n      throw new Error('Invalid Output type');\n    }\n  }\n};\n","/* eslint-disable max-classes-per-file */\nimport type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport { addressify } from '@fuel-ts/address';\nimport { NativeAssetId, ZeroBytes32 } from '@fuel-ts/constants';\nimport type {\n  AddressLike,\n  AbstractAddress,\n  ContractIdLike,\n  AbstractScript,\n} from '@fuel-ts/interfaces';\nimport type { BigNumberish, BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport type { Transaction } from '@fuel-ts/transactions';\nimport {\n  TransactionType,\n  TransactionCoder,\n  InputType,\n  OutputType,\n  GAS_PRICE_FACTOR,\n} from '@fuel-ts/transactions';\n\nimport type { Coin } from '../coin';\nimport type { CoinQuantity, CoinQuantityLike } from '../coin-quantity';\nimport { coinQuantityfy } from '../coin-quantity';\nimport type { Message } from '../message';\nimport type { Resource } from '../resource';\nimport { isCoin } from '../resource';\nimport { arraifyFromUint8Array, calculatePriceWithFactor } from '../util';\n\nimport type {\n  CoinTransactionRequestOutput,\n  ContractCreatedTransactionRequestOutput,\n  ContractTransactionRequestOutput,\n  VariableTransactionRequestOutput,\n} from '.';\nimport type {\n  TransactionRequestInput,\n  CoinTransactionRequestInput,\n  ContractTransactionRequestInput,\n  MessageTransactionRequestInput,\n} from './input';\nimport { inputify } from './input';\nimport type { TransactionRequestOutput, ChangeTransactionRequestOutput } from './output';\nimport { outputify } from './output';\nimport type { TransactionRequestStorageSlot } from './storage-slot';\nimport { storageSlotify } from './storage-slot';\nimport type { TransactionRequestWitness } from './witness';\nimport { witnessify } from './witness';\n\nexport { TransactionType };\n\n// We can't import this from `@fuel-ts/script` because it causes\n// cyclic dependency errors so we duplicate it here.\nexport const returnZeroScript: AbstractScript<void> = {\n  /*\n    Opcode::RET(REG_ZERO)\n    Opcode::NOOP\n  */\n  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281\n  bytes: arrayify('0x24000000'),\n  encodeScriptData: () => new Uint8Array(0),\n};\n\nexport const withdrawScript: AbstractScript<void> = {\n  /*\n\t\tThe following code loads some basic values into registers and calls SMO to create an output message\n\n\t\t5040C010 \t- ADDI r16 $is i16   [r16 now points to memory 16 bytes from the start of this program (start of receiver data)]\n\t\t5D44C006\t- LW r17 $is i6      [r17 set to the 6th word in this program (6*8=48 bytes from the start of this program)]\n\t\t4C400011\t- SMO r16 r0 r0 r17  [send message out to address starting at memory position r16 with amount in r17]\n\t\t24000000\t- RET                [return 0]\n\t\t00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 [recipient address]\n\t\t00000000 00000000 [amount value]\n\t*/\n  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281\n  bytes: arrayify('0x5040C0105D44C0064C40001124000000'),\n  encodeScriptData: () => new Uint8Array(0),\n};\n\ninterface BaseTransactionRequestLike {\n  /** Gas price for transaction */\n  gasPrice?: BigNumberish;\n  /** Gas limit for transaction */\n  gasLimit?: BigNumberish;\n  /** Block until which tx cannot be included */\n  maturity?: number;\n  /** List of inputs */\n  inputs?: TransactionRequestInput[];\n  /** List of outputs */\n  outputs?: TransactionRequestOutput[];\n  /** List of witnesses */\n  witnesses?: TransactionRequestWitness[];\n}\n\nexport class ChangeOutputCollisionError extends Error {\n  name = 'ChangeOutputCollisionError';\n  message = 'A ChangeOutput with the same \"assetId\" already exists for a different \"to\" address';\n}\n\nexport class NoWitnessAtIndexError extends Error {\n  name = 'NoWitnessAtIndexError';\n  constructor(public readonly index: number) {\n    super();\n    this.message = `Witness at index \"${index}\" was not found`;\n  }\n}\n\nexport class NoWitnessByOwnerError extends Error {\n  name = 'NoWitnessByOwnerError';\n  constructor(public readonly owner: AbstractAddress) {\n    super();\n    this.message = `A witness for the given owner \"${owner}\" was not found`;\n  }\n}\n\nabstract class BaseTransactionRequest implements BaseTransactionRequestLike {\n  /** Type of the transaction */\n  abstract type: TransactionType;\n  /** Gas price for transaction */\n  gasPrice: BN;\n  /** Gas limit for transaction */\n  gasLimit: BN;\n  /** Block until which tx cannot be included */\n  maturity: number;\n  /** List of inputs */\n  inputs: TransactionRequestInput[] = [];\n  /** List of outputs */\n  outputs: TransactionRequestOutput[] = [];\n  /** List of witnesses */\n  witnesses: TransactionRequestWitness[] = [];\n\n  constructor({\n    gasPrice,\n    gasLimit,\n    maturity,\n    inputs,\n    outputs,\n    witnesses,\n  }: BaseTransactionRequestLike = {}) {\n    this.gasPrice = bn(gasPrice ?? 0);\n    this.gasLimit = bn(gasLimit ?? 0);\n    this.maturity = maturity ?? 0;\n    this.inputs = [...(inputs ?? [])];\n    this.outputs = [...(outputs ?? [])];\n    this.witnesses = [...(witnesses ?? [])];\n  }\n\n  protected getBaseTransaction(): Pick<\n    Transaction,\n    keyof BaseTransactionRequestLike | 'inputsCount' | 'outputsCount' | 'witnessesCount'\n  > {\n    const inputs = this.inputs?.map(inputify) ?? [];\n    const outputs = this.outputs?.map(outputify) ?? [];\n    const witnesses = this.witnesses?.map(witnessify) ?? [];\n    return {\n      gasPrice: this.gasPrice,\n      gasLimit: this.gasLimit,\n      maturity: this.maturity,\n      inputs,\n      outputs,\n      witnesses,\n      inputsCount: inputs.length,\n      outputsCount: outputs.length,\n      witnessesCount: witnesses.length,\n    };\n  }\n\n  abstract toTransaction(): Transaction;\n\n  toTransactionBytes(): Uint8Array {\n    return new TransactionCoder().encode(this.toTransaction());\n  }\n\n  /**\n   * Pushes an input to the list without any side effects and returns the index\n   */\n  protected pushInput(input: TransactionRequestInput): number {\n    this.inputs.push(input);\n    return this.inputs.length - 1;\n  }\n\n  /**\n   * Pushes an output to the list without any side effects and returns the index\n   */\n  protected pushOutput(output: TransactionRequestOutput): number {\n    this.outputs.push(output);\n    return this.outputs.length - 1;\n  }\n\n  /**\n   * Creates an empty witness without any side effects and returns the index\n   */\n  protected createWitness() {\n    this.witnesses.push('0x');\n    return this.witnesses.length - 1;\n  }\n\n  updateWitnessByOwner(address: AbstractAddress, signature: BytesLike) {\n    const witnessIndex = this.getCoinInputWitnessIndexByOwner(address);\n    if (typeof witnessIndex === 'number') {\n      this.updateWitness(witnessIndex, signature);\n    }\n  }\n\n  /**\n   * Updates an existing witness without any side effects\n   */\n  updateWitness(index: number, witness: TransactionRequestWitness) {\n    if (!this.witnesses[index]) {\n      throw new NoWitnessAtIndexError(index);\n    }\n    this.witnesses[index] = witness;\n  }\n\n  getCoinInputs(): CoinTransactionRequestInput[] {\n    return this.inputs.filter(\n      (input): input is CoinTransactionRequestInput => input.type === InputType.Coin\n    );\n  }\n\n  getCoinOutputs(): CoinTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is CoinTransactionRequestOutput => output.type === OutputType.Coin\n    );\n  }\n\n  getChangeOutputs(): ChangeTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is ChangeTransactionRequestOutput => output.type === OutputType.Change\n    );\n  }\n\n  /**\n   * Returns the witnessIndex of the found CoinInput\n   */\n  getCoinInputWitnessIndexByOwner(owner: AddressLike): number | null {\n    const ownerAddress = addressify(owner);\n    return (\n      this.inputs.find(\n        (input): input is CoinTransactionRequestInput =>\n          input.type === InputType.Coin && input.owner === ownerAddress.toB256()\n      )?.witnessIndex ?? null\n    );\n  }\n\n  /**\n   * Updates the witness for the given CoinInput owner\n   */\n  updateWitnessByCoinInputOwner(owner: AddressLike, witness: BytesLike) {\n    const witnessIndex = this.getCoinInputWitnessIndexByOwner(owner);\n\n    if (!witnessIndex) {\n      throw new NoWitnessByOwnerError(addressify(owner));\n    }\n\n    this.updateWitness(witnessIndex, witness);\n  }\n\n  /**\n   * Converts the given Resource to a ResourceInput with the appropriate witnessIndex and pushes it\n   */\n  addResource(resource: Resource) {\n    const ownerAddress = isCoin(resource) ? resource.owner : resource.recipient;\n    const assetId = isCoin(resource) ? resource.assetId : NativeAssetId;\n    const type = isCoin(resource) ? InputType.Coin : InputType.Message;\n    let witnessIndex = this.getCoinInputWitnessIndexByOwner(ownerAddress);\n\n    // Insert a dummy witness if no witness exists\n    if (typeof witnessIndex !== 'number') {\n      witnessIndex = this.createWitness();\n    }\n\n    // Insert the Input\n    this.pushInput(\n      isCoin(resource)\n        ? ({\n            type,\n            ...resource,\n            owner: resource.owner.toB256(),\n            witnessIndex,\n            txPointer: '0x00000000000000000000000000000000',\n          } as CoinTransactionRequestInput)\n        : ({\n            type,\n            ...resource,\n            sender: resource.sender.toB256(),\n            recipient: resource.recipient.toB256(),\n            witnessIndex,\n            txPointer: '0x00000000000000000000000000000000',\n          } as MessageTransactionRequestInput)\n    );\n\n    // Find the ChangeOutput for the AssetId of the Resource\n    const changeOutput = this.getChangeOutputs().find(\n      (output) => hexlify(output.assetId) === assetId\n    );\n\n    // Throw if the existing ChangeOutput is not for the same owner\n    if (changeOutput && hexlify(changeOutput.to) !== ownerAddress.toB256()) {\n      throw new ChangeOutputCollisionError();\n    }\n\n    // Insert a ChangeOutput if it does not exist\n    if (!changeOutput) {\n      this.pushOutput({\n        type: OutputType.Change,\n        to: ownerAddress.toB256(),\n        assetId,\n      });\n    }\n  }\n\n  addResources(resources: ReadonlyArray<Resource>) {\n    resources.forEach((resource) => this.addResource(resource));\n  }\n\n  /**\n   * Converts the given Coin to a CoinInput with the appropriate witnessIndex and pushes it\n   */\n  addCoin(coin: Coin) {\n    let witnessIndex = this.getCoinInputWitnessIndexByOwner(coin.owner);\n\n    // Insert a dummy witness if no witness exists\n    if (typeof witnessIndex !== 'number') {\n      witnessIndex = this.createWitness();\n    }\n\n    // Insert the CoinInput\n    this.pushInput({\n      type: InputType.Coin,\n      ...coin,\n      owner: coin.owner.toB256(),\n      witnessIndex,\n      txPointer: '0x00000000000000000000000000000000',\n    });\n\n    // Find the ChangeOutput for the AssetId of the Coin\n    const changeOutput = this.getChangeOutputs().find(\n      (output) => hexlify(output.assetId) === coin.assetId\n    );\n\n    // Throw if the existing ChangeOutput is not for the same owner\n    if (changeOutput && hexlify(changeOutput.to) !== coin.owner.toB256()) {\n      throw new ChangeOutputCollisionError();\n    }\n\n    // Insert a ChangeOutput if it does not exist\n    if (!changeOutput) {\n      this.pushOutput({\n        type: OutputType.Change,\n        to: coin.owner.toB256(),\n        assetId: coin.assetId,\n      });\n    }\n  }\n\n  addCoins(coins: ReadonlyArray<Coin>) {\n    coins.forEach((coin) => this.addCoin(coin));\n  }\n\n  addCoinOutput(\n    /** Address of the destination */\n    to: AddressLike,\n    /** Amount of coins */\n    amount: BigNumberish,\n    /** Asset ID of coins */\n    assetId: BytesLike = NativeAssetId\n  ) {\n    this.pushOutput({\n      type: OutputType.Coin,\n      to: addressify(to).toB256(),\n      amount,\n      assetId,\n    });\n  }\n\n  addCoinOutputs(\n    /** Address of the destination */\n    to: AddressLike,\n    /** Quantities of coins */\n    quantities: CoinQuantityLike[]\n  ) {\n    quantities.map(coinQuantityfy).forEach((quantity) => {\n      this.pushOutput({\n        type: OutputType.Coin,\n        to: addressify(to).toB256(),\n        amount: quantity.amount,\n        assetId: quantity.assetId,\n      });\n    });\n  }\n\n  byteSize() {\n    return this.toTransactionBytes().length;\n  }\n\n  chargeableByteSize() {\n    const witnessSize = this.witnesses.reduce((total, w) => total + arrayify(w).length, 0);\n    return bn(this.toTransactionBytes().length - witnessSize);\n  }\n\n  /**\n   * Return the minimum amount in native coins required to create\n   * a transaction.\n   *\n   * Note: this is required even gasPrice = 0\n   */\n  calculateFee(): CoinQuantity {\n    const gasFee = calculatePriceWithFactor(this.gasLimit, this.gasPrice, GAS_PRICE_FACTOR);\n\n    return {\n      assetId: NativeAssetId,\n      amount: gasFee.isZero() ? bn(1) : gasFee,\n    };\n  }\n\n  /**\n   * Converts the given Message to a MessageInput\n   */\n  addMessage(message: Message) {\n    let witnessIndex = this.getCoinInputWitnessIndexByOwner(message.recipient);\n\n    // Insert a dummy witness if no witness exists\n    if (typeof witnessIndex !== 'number') {\n      witnessIndex = this.createWitness();\n    }\n\n    // Insert the MessageInput\n    this.pushInput({\n      type: InputType.Message,\n      ...message,\n      sender: message.sender.toBytes(),\n      recipient: message.recipient.toBytes(),\n      witnessIndex,\n    });\n  }\n\n  addMessages(messages: ReadonlyArray<Message>) {\n    messages.forEach((message) => this.addMessage(message));\n  }\n}\n\nexport interface ScriptTransactionRequestLike extends BaseTransactionRequestLike {\n  /** Script to execute */\n  script?: BytesLike;\n  /** Script input data (parameters) */\n  scriptData?: BytesLike;\n}\n\nexport class ScriptTransactionRequest extends BaseTransactionRequest {\n  static from(obj: ScriptTransactionRequestLike) {\n    if (obj instanceof this) {\n      return obj;\n    }\n    return new this(obj);\n  }\n\n  /** Type of the transaction */\n  type = TransactionType.Script as const;\n  /** Script to execute */\n  script: Uint8Array;\n  /** Script input data (parameters) */\n  scriptData: Uint8Array;\n  /** determined bytes offset for start of script data */\n  bytesOffset: number | undefined;\n\n  constructor({ script, scriptData, ...rest }: ScriptTransactionRequestLike = {}) {\n    super(rest);\n    this.script = arraifyFromUint8Array(script ?? returnZeroScript.bytes);\n    this.scriptData = arraifyFromUint8Array(scriptData ?? returnZeroScript.encodeScriptData());\n  }\n\n  toTransaction(): Transaction {\n    const script = arrayify(this.script ?? '0x');\n    const scriptData = arrayify(this.scriptData ?? '0x');\n    return {\n      type: TransactionType.Script,\n      ...super.getBaseTransaction(),\n      scriptLength: script.length,\n      scriptDataLength: scriptData.length,\n      receiptsRoot: ZeroBytes32,\n      script: hexlify(script),\n      scriptData: hexlify(scriptData),\n    };\n  }\n\n  getContractInputs(): ContractTransactionRequestInput[] {\n    return this.inputs.filter(\n      (input): input is ContractTransactionRequestInput => input.type === InputType.Contract\n    );\n  }\n\n  getContractOutputs(): ContractTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is ContractTransactionRequestOutput => output.type === OutputType.Contract\n    );\n  }\n\n  getVariableOutputs(): VariableTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is VariableTransactionRequestOutput => output.type === OutputType.Variable\n    );\n  }\n\n  setScript<T>(script: AbstractScript<T>, data: T) {\n    this.script = script.bytes;\n    this.scriptData = script.encodeScriptData(data);\n\n    if (this.bytesOffset === undefined) {\n      this.bytesOffset = this.scriptData.byteLength;\n    }\n  }\n\n  addVariableOutputs(numberOfVariables: number = 1) {\n    let outputsNumber = numberOfVariables;\n\n    while (outputsNumber) {\n      this.pushOutput({\n        type: OutputType.Variable,\n      });\n      outputsNumber -= 1;\n    }\n\n    return this.outputs.length - 1;\n  }\n\n  addMessageOutputs(numberOfMessages: number = 1) {\n    let outputsNumber = numberOfMessages;\n\n    while (outputsNumber) {\n      this.pushOutput({\n        type: OutputType.Message,\n        recipient: '0x0000000000000000000000000000000000000000000000000000000000000000',\n        amount: 0,\n      });\n      outputsNumber -= 1;\n    }\n\n    return this.outputs.length - 1;\n  }\n\n  addContract(contract: ContractIdLike) {\n    const contractAddress = addressify(contract);\n\n    // Add only one input contract per contractId\n    if (this.getContractInputs().find((i) => i.contractId === contractAddress.toB256())) {\n      return;\n    }\n\n    const inputIndex = super.pushInput({\n      type: InputType.Contract,\n      contractId: contractAddress.toB256(),\n      txPointer: '0x00000000000000000000000000000000',\n    });\n\n    this.pushOutput({\n      type: OutputType.Contract,\n      inputIndex,\n    });\n  }\n}\n\nexport interface CreateTransactionRequestLike extends BaseTransactionRequestLike {\n  /** Witness index of contract bytecode to create */\n  bytecodeWitnessIndex?: number;\n  /** Salt */\n  salt?: BytesLike;\n  /** List of storage slots to initialize */\n  storageSlots?: TransactionRequestStorageSlot[];\n}\n\nexport class CreateTransactionRequest extends BaseTransactionRequest {\n  static from(obj: CreateTransactionRequestLike) {\n    if (obj instanceof this) {\n      return obj;\n    }\n    return new this(obj);\n  }\n\n  /** Type of the transaction */\n  type = TransactionType.Create as const;\n  /** Witness index of contract bytecode to create */\n  bytecodeWitnessIndex: number;\n  /** Salt */\n  salt: string;\n  /** List of storage slots to initialize */\n  storageSlots: TransactionRequestStorageSlot[];\n\n  constructor({\n    bytecodeWitnessIndex,\n    salt,\n    storageSlots,\n    ...rest\n  }: CreateTransactionRequestLike = {}) {\n    super(rest);\n    this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;\n    this.salt = hexlify(salt ?? ZeroBytes32);\n    this.storageSlots = [...(storageSlots ?? [])];\n  }\n\n  toTransaction(): Transaction {\n    const baseTransaction = this.getBaseTransaction();\n    const bytecodeWitnessIndex = this.bytecodeWitnessIndex;\n    const storageSlots = this.storageSlots?.map(storageSlotify) ?? [];\n    return {\n      type: TransactionType.Create,\n      ...baseTransaction,\n      bytecodeLength: baseTransaction.witnesses[bytecodeWitnessIndex].dataLength / 4,\n      bytecodeWitnessIndex,\n      storageSlotsCount: storageSlots.length,\n      salt: this.salt ? hexlify(this.salt) : ZeroBytes32,\n      storageSlots,\n    };\n  }\n\n  getContractCreatedOutputs(): ContractCreatedTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is ContractCreatedTransactionRequestOutput =>\n        output.type === OutputType.ContractCreated\n    );\n  }\n\n  addContractCreatedOutput(\n    /** Contract ID */\n    contractId: BytesLike,\n    /** State Root */\n    stateRoot: BytesLike\n  ) {\n    this.pushOutput({\n      type: OutputType.ContractCreated,\n      contractId,\n      stateRoot,\n    });\n  }\n}\n\nexport type TransactionRequest = ScriptTransactionRequest | CreateTransactionRequest;\nexport type TransactionRequestLike =\n  | ({ type: TransactionType.Script } & ScriptTransactionRequestLike)\n  | ({ type: TransactionType.Create } & CreateTransactionRequestLike);\n\nexport const transactionRequestify = (obj: TransactionRequestLike): TransactionRequest => {\n  if (obj instanceof ScriptTransactionRequest || obj instanceof CreateTransactionRequest) {\n    return obj;\n  }\n  switch (obj.type) {\n    case TransactionType.Script: {\n      return ScriptTransactionRequest.from(obj);\n    }\n    case TransactionType.Create: {\n      return CreateTransactionRequest.from(obj);\n    }\n    default: {\n      throw new Error(\n        `Unknown transaction type: ${\n          // @ts-expect-error Unreachable code\n          obj.type\n        }`\n      );\n    }\n  }\n};\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify } from '@ethersproject/bytes';\nimport type { BN } from '@fuel-ts/math';\nimport { multiply, bn } from '@fuel-ts/math';\nimport type { ReceiptPanic, ReceiptRevert } from '@fuel-ts/transactions';\nimport {\n  FAILED_TRANSFER_TO_ADDRESS_SIGNAL,\n  GAS_PRICE_FACTOR,\n  ReceiptType,\n} from '@fuel-ts/transactions';\n\nimport type { TransactionResultReceipt } from './transaction-response';\n\n// TODO: create a fuel-ts/bytes package\n// This custom arrayify enables to parse a object from Uint8Array\n// stringify back to a Uint8Array by setting the missing length field\nexport const arraifyFromUint8Array = (bytes: BytesLike): Uint8Array => {\n  if (bytes.length == null && typeof bytes === 'object') {\n    const length = Object.keys(bytes).length;\n    return arrayify({\n      ...bytes,\n      length,\n    });\n  }\n  return arrayify(bytes);\n};\n\nexport const calculatePriceWithFactor = (gasUsed: BN, gasPrice: BN, priceFactor: BN): BN =>\n  bn(Math.ceil(gasUsed.toNumber() / priceFactor.toNumber()) * gasPrice.toNumber());\n\nexport const getGasUsedFromReceipts = (receipts: Array<TransactionResultReceipt>): BN => {\n  const scriptResult = receipts.find((receipt) => receipt.type === ReceiptType.ScriptResult);\n\n  if (scriptResult && scriptResult.type === ReceiptType.ScriptResult) {\n    return scriptResult.gasUsed;\n  }\n\n  return bn(0);\n};\n\nexport function sleep(time: number = 1000) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(true);\n    }, time);\n  });\n}\n\nconst doesReceiptHaveMissingOutputVariables = (\n  receipt: TransactionResultReceipt\n): receipt is ReceiptRevert =>\n  receipt.type === ReceiptType.Revert &&\n  receipt.val.toString('hex') === FAILED_TRANSFER_TO_ADDRESS_SIGNAL;\n\nconst doesReceiptHaveMissingContractId = (\n  receipt: TransactionResultReceipt\n): receipt is ReceiptPanic =>\n  receipt.type === ReceiptType.Panic &&\n  receipt.contractId !== '0x0000000000000000000000000000000000000000000000000000000000000000';\n\nexport const getReceiptsWithMissingData = (receipts: Array<TransactionResultReceipt>) =>\n  receipts.reduce<{\n    missingOutputVariables: Array<ReceiptRevert>;\n    missingOutputContractIds: Array<ReceiptPanic>;\n  }>(\n    (memo, receipt) => {\n      if (doesReceiptHaveMissingOutputVariables(receipt)) {\n        memo.missingOutputVariables.push(receipt);\n      }\n      if (doesReceiptHaveMissingContractId(receipt)) {\n        memo.missingOutputContractIds.push(receipt);\n      }\n      return memo;\n    },\n    {\n      missingOutputVariables: [],\n      missingOutputContractIds: [],\n    }\n  );\n\nexport const calculateTransactionFee = ({\n  receipts,\n  gasPrice,\n  margin,\n}: {\n  receipts: TransactionResultReceipt[];\n  gasPrice: BN;\n  margin?: number;\n}) => {\n  const gasUsed = multiply(getGasUsedFromReceipts(receipts), margin || 1);\n  const fee = calculatePriceWithFactor(gasUsed, gasPrice, GAS_PRICE_FACTOR);\n\n  return {\n    gasUsed,\n    fee,\n  };\n};\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { hexlify, arrayify } from '@ethersproject/bytes';\nimport type { StorageSlot } from '@fuel-ts/transactions';\n\nexport type TransactionRequestStorageSlot =\n  | {\n      /** Key */\n      key: BytesLike;\n      /** Value */\n      value: BytesLike;\n    }\n  | [key: BytesLike, value: BytesLike];\n\n// Make sure all values have 32 bytes\nconst getStorageValue = (value: BytesLike): Uint8Array => {\n  const v = new Uint8Array(32);\n  v.set(arrayify(value));\n  return v;\n};\n\nexport const storageSlotify = (storageSlot: TransactionRequestStorageSlot): StorageSlot => {\n  let key;\n  let value;\n\n  if (Array.isArray(storageSlot)) {\n    key = storageSlot[0];\n    value = storageSlot[1];\n  } else {\n    key = storageSlot.key;\n    value = storageSlot.value;\n  }\n\n  return {\n    key: hexlify(key),\n    value: hexlify(getStorageValue(value)),\n  };\n};\n","import type { BytesLike } from '@ethersproject/bytes';\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport type { Witness } from '@fuel-ts/transactions';\n\nexport type TransactionRequestWitness = BytesLike;\n\nexport const witnessify = (value: TransactionRequestWitness): Witness => {\n  const data = arrayify(value);\n\n  return {\n    data: hexlify(data),\n    dataLength: data.length,\n  };\n};\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { arrayify } from '@ethersproject/bytes';\nimport type { BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport type {\n  ReceiptCall,\n  ReceiptLog,\n  ReceiptLogData,\n  ReceiptPanic,\n  ReceiptReturn,\n  ReceiptReturnData,\n  ReceiptRevert,\n  ReceiptTransfer,\n  ReceiptTransferOut,\n  ReceiptScriptResult,\n  ReceiptMessageOut,\n  Transaction,\n} from '@fuel-ts/transactions';\nimport { TransactionCoder, ReceiptType, ReceiptCoder } from '@fuel-ts/transactions';\n\nimport type {\n  GqlGetTransactionWithReceiptsQuery,\n  GqlReceiptFragmentFragment,\n} from '../__generated__/operations';\nimport type Provider from '../provider';\nimport { calculateTransactionFee, sleep } from '../util';\n\nexport type TransactionResultCallReceipt = ReceiptCall;\nexport type TransactionResultReturnReceipt = ReceiptReturn;\nexport type TransactionResultReturnDataReceipt = ReceiptReturnData & { data: string };\nexport type TransactionResultPanicReceipt = ReceiptPanic;\nexport type TransactionResultRevertReceipt = ReceiptRevert;\nexport type TransactionResultLogReceipt = ReceiptLog;\nexport type TransactionResultLogDataReceipt = ReceiptLogData & { data: string };\nexport type TransactionResultTransferReceipt = ReceiptTransfer;\nexport type TransactionResultTransferOutReceipt = ReceiptTransferOut;\nexport type TransactionResultScriptResultReceipt = ReceiptScriptResult;\nexport type TransactionResultMessageOutReceipt = ReceiptMessageOut;\n\nexport type TransactionResultReceipt =\n  | TransactionResultCallReceipt\n  | TransactionResultReturnReceipt\n  | TransactionResultReturnDataReceipt\n  | TransactionResultPanicReceipt\n  | TransactionResultRevertReceipt\n  | TransactionResultLogReceipt\n  | TransactionResultLogDataReceipt\n  | TransactionResultTransferReceipt\n  | TransactionResultTransferOutReceipt\n  | TransactionResultScriptResultReceipt\n  | TransactionResultMessageOutReceipt;\n\nexport type TransactionResult<TStatus extends 'success' | 'failure'> = {\n  status: TStatus extends 'success'\n    ? { type: 'success'; programState: any }\n    : { type: 'failure'; reason: any };\n  /** Receipts produced during the execution of the transaction */\n  receipts: TransactionResultReceipt[];\n  transactionId: string;\n  blockId: any;\n  time: any;\n  gasUsed: BN;\n  fee: BN;\n  transaction: Transaction;\n};\n\nconst STATUS_POLLING_INTERVAL_MAX_MS = 5000;\nconst STATUS_POLLING_INTERVAL_MIN_MS = 500;\n\nconst processGqlReceipt = (gqlReceipt: GqlReceiptFragmentFragment): TransactionResultReceipt => {\n  const receipt = new ReceiptCoder().decode(arrayify(gqlReceipt.rawPayload), 0)[0];\n\n  switch (receipt.type) {\n    case ReceiptType.ReturnData: {\n      return {\n        ...receipt,\n        data: gqlReceipt.data!,\n      };\n    }\n    case ReceiptType.LogData: {\n      return {\n        ...receipt,\n        data: gqlReceipt.data!,\n      };\n    }\n    default:\n      return receipt;\n  }\n};\n\nexport class TransactionResponse {\n  /** Transaction ID */\n  id: string;\n  /** Current provider */\n  provider: Provider;\n  /** Gas used on the transaction */\n  gasUsed: BN = bn(0);\n  /** Number off attempts to get the committed tx */\n  attempts: number = 0;\n\n  constructor(id: string, provider: Provider) {\n    this.id = id;\n    this.provider = provider;\n  }\n\n  async #fetch(): Promise<NonNullable<GqlGetTransactionWithReceiptsQuery['transaction']>> {\n    const { transaction } = await this.provider.operations.getTransactionWithReceipts({\n      transactionId: this.id,\n    });\n    if (!transaction) {\n      throw new Error('No Transaction was received from the client.');\n    }\n    return transaction;\n  }\n\n  /** Waits for transaction to succeed or fail and returns the result */\n  async waitForResult(): Promise<TransactionResult<any>> {\n    const transaction = await this.#fetch();\n\n    const decodedTransaction = new TransactionCoder().decode(\n      arrayify(transaction.rawPayload),\n      0\n    )?.[0];\n\n    switch (transaction.status?.type) {\n      case 'SubmittedStatus': {\n        // This code implements a similar approach from the fuel-core await_transaction_commit\n        // https://github.com/FuelLabs/fuel-core/blob/cb37f9ce9a81e033bde0dc43f91494bc3974fb1b/fuel-client/src/client.rs#L356\n        // double the interval duration on each attempt until max is reached\n        //\n        // This can wait forever, it would be great to implement a max timeout here, but it would require\n        // improve request handler as response Error not mean that the tx fail.\n        this.attempts += 1;\n        await sleep(\n          Math.min(STATUS_POLLING_INTERVAL_MIN_MS * this.attempts, STATUS_POLLING_INTERVAL_MAX_MS)\n        );\n        return this.waitForResult();\n      }\n      case 'FailureStatus': {\n        const receipts = transaction.receipts!.map(processGqlReceipt);\n        const { gasUsed, fee } = calculateTransactionFee({\n          receipts,\n          gasPrice: bn(transaction?.gasPrice),\n        });\n\n        this.gasUsed = gasUsed;\n        return {\n          status: { type: 'failure', reason: transaction.status.reason },\n          receipts,\n          transactionId: this.id,\n          blockId: transaction.status.block.id,\n          time: transaction.status.time,\n          gasUsed,\n          fee,\n          transaction: decodedTransaction,\n        };\n      }\n      case 'SuccessStatus': {\n        const receipts = transaction.receipts!.map(processGqlReceipt);\n        const { gasUsed, fee } = calculateTransactionFee({\n          receipts,\n          gasPrice: bn(transaction?.gasPrice),\n        });\n\n        return {\n          status: { type: 'success', programState: transaction.status.programState },\n          receipts,\n          transactionId: this.id,\n          blockId: transaction.status.block.id,\n          time: transaction.status.time,\n          gasUsed,\n          fee,\n          transaction: decodedTransaction,\n        };\n      }\n      default: {\n        throw new Error('Invalid Transaction status');\n      }\n    }\n  }\n\n  /** Waits for transaction to succeed and returns the result */\n  async wait(): Promise<TransactionResult<'success'>> {\n    const result = await this.waitForResult();\n\n    if (result.status.type === 'failure') {\n      throw new Error(`Transaction failed: ${result.status.reason}`);\n    }\n\n    return result;\n  }\n}\n"],"mappings":"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","names":["hexlify","NativeAssetId","bn","coinQuantityfy","coinQuantityLike","_a","_b","_c","_d","assetId","amount","max","gql","GqlCoinStatus","TransactionFragmentFragmentDoc","gql","ReceiptFragmentFragmentDoc","CoinFragmentFragmentDoc","MessageFragmentFragmentDoc","MessageProofFragmentFragmentDoc","BalanceFragmentFragmentDoc","BlockFragmentFragmentDoc","ChainInfoFragmentFragmentDoc","GetVersionDocument","GetInfoDocument","GetChainDocument","GetTransactionDocument","GetTransactionWithReceiptsDocument","GetTransactionsDocument","GetTransactionsByOwnerDocument","GetBlockDocument","GetBlockWithTransactionsDocument","GetBlocksDocument","GetCoinDocument","GetCoinsDocument","GetResourcesToSpendDocument","GetContractDocument","GetBalanceDocument","GetBalancesDocument","GetMessagesDocument","GetMessageProofDocument","DryRunDocument","SubmitDocument","StartSessionDocument","EndSessionDocument","ExecuteDocument","ResetDocument","defaultWrapper","action","_operationName","_operationType","getSdk","client","withWrapper","variables","requestHeaders","wrappedRequestHeaders","arrayify","hexlify","AbiCoder","Address","NativeAssetId","max","bn","TransactionType","InputMessageCoder","MAX_GAS_PER_TX","ReceiptType","ReceiptCoder","TransactionCoder","GraphQLClient","cloneDeep","isRawCoin","resource","isRawMessage","isCoin","isMessage","arrayify","hexlify","ZeroBytes32","bn","toNumber","InputType","inputify","value","_a","_b","_c","_d","_e","predicate","predicateData","hexlify","ZeroBytes32","bn","OutputType","outputify","value","arrayify","hexlify","addressify","NativeAssetId","ZeroBytes32","bn","TransactionType","TransactionCoder","InputType","OutputType","GAS_PRICE_FACTOR","arrayify","multiply","bn","FAILED_TRANSFER_TO_ADDRESS_SIGNAL","GAS_PRICE_FACTOR","ReceiptType","arraifyFromUint8Array","bytes","length","calculatePriceWithFactor","gasUsed","gasPrice","priceFactor","getGasUsedFromReceipts","receipts","scriptResult","receipt","sleep","time","resolve","doesReceiptHaveMissingOutputVariables","doesReceiptHaveMissingContractId","getReceiptsWithMissingData","memo","calculateTransactionFee","margin","fee","hexlify","arrayify","getStorageValue","value","v","storageSlotify","storageSlot","key","arrayify","hexlify","witnessify","value","data","returnZeroScript","arrayify","withdrawScript","ChangeOutputCollisionError","NoWitnessAtIndexError","index","NoWitnessByOwnerError","owner","BaseTransactionRequest","gasPrice","gasLimit","maturity","inputs","outputs","witnesses","bn","_a","_b","_c","_d","_e","_f","inputify","outputify","witnessify","TransactionCoder","input","output","address","signature","witnessIndex","witness","InputType","OutputType","ownerAddress","addressify","resource","isCoin","assetId","NativeAssetId","type","changeOutput","hexlify","resources","coin","coins","to","amount","quantities","coinQuantityfy","quantity","witnessSize","total","w","gasFee","calculatePriceWithFactor","GAS_PRICE_FACTOR","message","messages","ScriptTransactionRequest","script","scriptData","rest","TransactionType","arraifyFromUint8Array","obj","ZeroBytes32","data","numberOfVariables","outputsNumber","numberOfMessages","contract","contractAddress","i","inputIndex","CreateTransactionRequest","bytecodeWitnessIndex","salt","storageSlots","baseTransaction","storageSlotify","contractId","stateRoot","transactionRequestify","arrayify","bn","TransactionCoder","ReceiptType","ReceiptCoder","STATUS_POLLING_INTERVAL_MAX_MS","STATUS_POLLING_INTERVAL_MIN_MS","processGqlReceipt","gqlReceipt","receipt","ReceiptCoder","arrayify","ReceiptType","_fetch","fetch_fn","TransactionResponse","id","provider","__privateAdd","bn","_a","_b","transaction","__privateMethod","decodedTransaction","TransactionCoder","sleep","receipts","gasUsed","fee","calculateTransactionFee","result","MAX_RETRIES","processGqlReceipt","gqlReceipt","receipt","ReceiptCoder","arrayify","ReceiptType","processGqlChain","chain","bn","i","processNodeInfo","nodeInfo","Provider","url","transactionRequest","missingOutputVariableCount","missingOutputContractIdsCount","tries","TransactionType","encodedTransaction","hexlify","gqlReceipts","receipts","missingOutputVariables","missingOutputContractIds","getReceiptsWithMissingData","contractId","Address","gqlClient","GraphQLClient","getSdk","nodeVersion","transactionRequestLike","transactionRequestify","gasUsed","minGasPrice","transactionId","TransactionResponse","utxoValidation","tolerance","cloneDeep","gasPrice","max","margin","MAX_GAS_PER_TX","fee","calculateTransactionFee","owner","assetId","paginationArgs","edge","coin","quantities","excludedIds","_a","_b","excludeInput","id","coinQuantityfy","amount","maxPerAsset","resource","isRawCoin","InputMessageCoder","idOrHeight","variables","block","tx","TransactionCoder","transaction","contract","balance","address","message","messageId","result","predicate","amountToSpend","receiverAddress","predicateData","NativeAssetId","predicateOptions","walletAddress","predicateResources","options","request","ScriptTransactionRequest","encoded","AbiCoder","totalInPredicate","prev","requiredCoinQuantities","resources","error"]}