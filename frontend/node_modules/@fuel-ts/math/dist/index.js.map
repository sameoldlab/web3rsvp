{"version":3,"sources":["../src/index.ts","../src/bn.ts","../src/constants.ts","../src/decimal.ts","../src/functional.ts","../src/math.ts"],"sourcesContent":["export * from './bn';\nexport * from './constants';\nexport * from './decimal';\nexport * from './functional';\nexport * from './math';\nexport * from './types';\n","import BnJs from 'bn.js';\n\nimport { DECIMAL_UNITS, DEFAULT_MIN_PRECISION, DEFAULT_PRECISION } from './constants';\nimport { toFixed } from './decimal';\nimport type { FormatConfig } from './types';\n\ntype CompareResult = -1 | 0 | 1;\nexport type BNInput = number | string | number[] | Uint8Array | Buffer | BnJs;\ninterface BNHelper {\n  caller(v: BNInput, methodName: string): BN | boolean | CompareResult;\n  toHex: (bytesPadding?: number) => string;\n  toBytes: (bytesPadding?: number) => Uint8Array;\n  toJSON: () => string;\n}\ninterface BNInputOverrides {\n  add: (v: BNInput) => BN;\n  pow: (v: BNInput) => BN;\n  sub: (v: BNInput) => BN;\n  div: (v: BNInput) => BN;\n  mul: (v: BNInput) => BN;\n  mod: (v: BNInput) => BN;\n  divRound: (v: BNInput) => BN;\n  lt: (v: BNInput) => boolean;\n  lte: (v: BNInput) => boolean;\n  gt: (v: BNInput) => boolean;\n  gte: (v: BNInput) => boolean;\n  eq: (v: BNInput) => boolean;\n  cmp: (v: BNInput) => CompareResult;\n}\ninterface BNOverrides {\n  sqr: () => BN;\n  neg: () => BN;\n  abs: () => BN;\n  toTwos: (width: number) => BN;\n  fromTwos: (width: number) => BN;\n}\ninterface BNHiddenTypes {\n  mulTo: (num: BN, out: BN) => BN;\n  divmod: (num: BNInput, mode?: string, positive?: boolean) => { mod: BN; div: BN };\n}\ntype BNInputOverridesKeys = keyof BNInputOverrides;\n\nexport class BN extends BnJs implements BNInputOverrides, BNHiddenTypes, BNHelper, BNOverrides {\n  constructor(value?: BNInput | null, base?: number | 'hex', endian?: BnJs.Endianness) {\n    if (BN.isBN(value)) {\n      super(value.toArray(), base, endian);\n      return;\n    }\n    // trim '0x' from hex strings as BN doesn't support it - https://github.com/ChainSafe/web3.js/issues/3847\n    if (typeof value === 'string' && value.slice(0, 2) === '0x') {\n      super(value.substring(2), base || 'hex', endian);\n      return;\n    }\n    const defaultValue = value == null ? 0 : value;\n    super(defaultValue, base, endian);\n  }\n\n  // ANCHOR: HELPERS\n  // make sure we always include `0x` in hex strings\n  toString(base?: number | 'hex', length?: number) {\n    const output = super.toString(base, length);\n\n    if (base === 16 || base === 'hex') return `0x${output}`;\n\n    return output;\n  }\n\n  toHex(bytesPadding?: number): string {\n    const bytes = bytesPadding || 0;\n    const bytesLength = bytes * 2;\n\n    if (this.isNeg()) {\n      throw new Error('cannot convert negative value to hex');\n    }\n    if (bytesPadding && this.byteLength() > bytesPadding) {\n      throw new Error(`value ${this} exceeds bytes ${bytesPadding}`);\n    }\n\n    return this.toString(16, bytesLength);\n  }\n\n  toBytes(bytesPadding?: number): Uint8Array {\n    if (this.isNeg()) {\n      throw new Error('cannot convert negative value to Bytes');\n    }\n\n    return Uint8Array.from(this.toArray(undefined, bytesPadding));\n  }\n\n  toJSON(): string {\n    return this.toString(16);\n  }\n\n  valueOf(): string {\n    return this.toString();\n  }\n\n  format(options?: FormatConfig): string {\n    const {\n      units = DECIMAL_UNITS,\n      precision = DEFAULT_PRECISION,\n      minPrecision = DEFAULT_MIN_PRECISION,\n    } = options || {};\n\n    const formattedUnits = this.formatUnits(units);\n    const formattedFixed = toFixed(formattedUnits, { precision, minPrecision });\n\n    // increase precision if formatted is zero, but has more numbers out of precision\n    if (!parseFloat(formattedFixed)) {\n      const [, originalDecimals = '0'] = formattedUnits.split('.');\n      const firstNonZero = originalDecimals.match(/[1-9]/);\n\n      if (firstNonZero && firstNonZero.index && firstNonZero.index + 1 > precision) {\n        const [valueUnits = '0'] = formattedFixed.split('.');\n        return `${valueUnits}.${originalDecimals.slice(0, firstNonZero.index + 1)}`;\n      }\n    }\n\n    return formattedFixed;\n  }\n\n  formatUnits(units: number = DECIMAL_UNITS): string {\n    const valueUnits = this.toString().slice(0, units * -1);\n    const valueDecimals = this.toString().slice(units * -1);\n    const length = valueDecimals.length;\n    const defaultDecimals = Array.from({ length: units - length })\n      .fill('0')\n      .join('');\n    const integerPortion = valueUnits ? `${valueUnits}.` : '0.';\n\n    return `${integerPortion}${defaultDecimals}${valueDecimals}`;\n  }\n  // END ANCHOR: HELPERS\n\n  // ANCHOR: OVERRIDES to accept better inputs\n  add(v: BNInput): BN {\n    return this.caller(v, 'add') as BN;\n  }\n\n  pow(v: BNInput): BN {\n    return this.caller(v, 'pow') as BN;\n  }\n\n  sub(v: BNInput): BN {\n    return this.caller(v, 'sub') as BN;\n  }\n\n  div(v: BNInput): BN {\n    return this.caller(v, 'div') as BN;\n  }\n\n  mul(v: BNInput): BN {\n    return this.caller(v, 'mul') as BN;\n  }\n\n  mod(v: BNInput): BN {\n    return this.caller(v, 'mod') as BN;\n  }\n\n  divRound(v: BNInput): BN {\n    return this.caller(v, 'divRound') as BN;\n  }\n\n  lt(v: BNInput): boolean {\n    return this.caller(v, 'lt') as boolean;\n  }\n\n  lte(v: BNInput): boolean {\n    return this.caller(v, 'lte') as boolean;\n  }\n\n  gt(v: BNInput): boolean {\n    return this.caller(v, 'gt') as boolean;\n  }\n\n  gte(v: BNInput): boolean {\n    return this.caller(v, 'gte') as boolean;\n  }\n\n  eq(v: BNInput): boolean {\n    return this.caller(v, 'eq') as boolean;\n  }\n\n  cmp(v: BNInput): CompareResult {\n    return this.caller(v, 'cmp') as CompareResult;\n  }\n  // END ANCHOR: OVERRIDES to accept better inputs\n\n  // ANCHOR: OVERRIDES to output our BN type\n  sqr(): BN {\n    return new BN(super.sqr().toArray());\n  }\n\n  neg(): BN {\n    return new BN(super.neg().toArray());\n  }\n\n  abs(): BN {\n    return new BN(super.abs().toArray());\n  }\n\n  toTwos(width: number): BN {\n    return new BN(super.toTwos(width).toArray());\n  }\n\n  fromTwos(width: number): BN {\n    return new BN(super.fromTwos(width).toArray());\n  }\n  // END ANCHOR: OVERRIDES to output our BN type\n\n  // ANCHOR: OVERRIDES to avoid losing references\n  caller(v: BNInput, methodName: BNInputOverridesKeys): BN | boolean | CompareResult {\n    const output = super[methodName](new BN(v));\n\n    if (BN.isBN(output)) {\n      return new BN(output.toArray());\n    }\n\n    if (typeof output === 'boolean') {\n      return output as boolean;\n    }\n\n    return output as CompareResult;\n  }\n\n  clone() {\n    return new BN(this.toArray());\n  }\n\n  mulTo(num: BN, out: BN) {\n    const output: BnJs = (new BnJs(this.toArray()) as BN).mulTo(num, out);\n\n    return new BN(output.toArray());\n  }\n\n  egcd(p: BnJs) {\n    const { a, b, gcd } = new BnJs(this.toArray()).egcd(p);\n\n    return {\n      a: new BN(a.toArray()),\n      b: new BN(b.toArray()),\n      gcd: new BN(gcd.toArray()),\n    };\n  }\n\n  divmod(num: BNInput, mode?: string, positive?: boolean): { mod: BN; div: BN } {\n    const { div, mod } = (new BnJs(this.toArray()) as BN).divmod(new BN(num), mode, positive);\n\n    return {\n      div: new BN(div?.toArray()),\n      mod: new BN(mod?.toArray()),\n    };\n  }\n  // END ANCHOR: OVERRIDES to avoid losing references\n}\n\n// functional shortcut to create BN\nexport const bn = (value?: BNInput | null, base?: number | 'hex', endian?: BnJs.Endianness) =>\n  new BN(value, base, endian);\n\nbn.parseUnits = (value: string, units: number = DECIMAL_UNITS): BN => {\n  const valueToParse = value === '.' ? '0.' : value;\n  const [valueUnits = '0', valueDecimals = '0'] = valueToParse.split('.');\n  const length = valueDecimals.length;\n\n  if (length > units) {\n    throw new Error(\"Decimal can't be bigger than the units\");\n  }\n\n  const decimals = Array.from({ length: units }).fill('0');\n  decimals.splice(0, length, valueDecimals);\n  const amount = `${valueUnits.replace(',', '')}${decimals.join('')}`;\n  return bn(amount);\n};\n","export const DEFAULT_PRECISION = 3;\nexport const DEFAULT_MIN_PRECISION = 1;\nexport const DECIMAL_UNITS = 9;\n","import { DEFAULT_MIN_PRECISION, DEFAULT_PRECISION } from './constants';\nimport type { ToFixedConfig } from './types';\n\nexport function toFixed(value?: string | number, options?: ToFixedConfig) {\n  const { precision = DEFAULT_PRECISION, minPrecision = DEFAULT_MIN_PRECISION } = options || {};\n\n  const [valueUnits = '0', valueDecimals = '0'] = String(value || '0.0').split('.');\n  const groupRegex = /(\\d)(?=(\\d{3})+\\b)/g;\n  const units = valueUnits.replace(groupRegex, '$1,');\n  let decimals = valueDecimals.slice(0, precision);\n\n  // strip traling zeros limited by minPrecision\n  if (minPrecision < precision) {\n    const trimmedDecimal = decimals.match(/.*[1-9]{1}/);\n    const lastNonZeroIndex = trimmedDecimal?.[0].length || 0;\n    const keepChars = Math.max(minPrecision, lastNonZeroIndex);\n    decimals = decimals.slice(0, keepChars);\n  }\n\n  const decimalPortion = decimals ? `.${decimals}` : '';\n  return `${units}${decimalPortion}`;\n}\n","import type { BNInput } from './bn';\nimport { bn } from './bn';\nimport type { FormatConfig } from './types';\n\n/**\n * Functional shortcuts\n */\n\n// Shortcut to bn(value).toNumber\nexport function toNumber(value: BNInput): number {\n  return bn(value).toNumber();\n}\n\n// Shortcut to bn(value).toHex\nexport function toHex(value: BNInput, bytesPadding?: number): string {\n  return bn(value).toHex(bytesPadding);\n}\n\n// Shortcut to bn(value).toBytes\nexport function toBytes(value: BNInput, bytesPadding?: number): Uint8Array {\n  return bn(value).toBytes(bytesPadding);\n}\n\n// Shortcut to bn.(value).formatUnits\nexport function formatUnits(value: BNInput, units?: number): string {\n  return bn(value).formatUnits(units);\n}\n\n// Shortcut to bn.(value).format\nexport function format(value: BNInput, options?: FormatConfig): string {\n  return bn(value).format(options);\n}\n","import type { BN } from './bn';\nimport { bn } from './bn';\nimport type { BigNumberish } from './types';\n\nexport function max(...numbers: Array<BigNumberish>): BN {\n  return numbers.reduce<BN>((prev, cur) => (bn(cur).gt(prev) ? bn(cur) : prev), bn(0));\n}\n\nexport function multiply(...numbers: Array<BigNumberish>): BN {\n  return bn(Math.ceil(numbers.reduce<BN>((a, b) => bn(a).mul(b), bn(1)).toNumber()));\n}\n"],"mappings":"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","names":["src_exports","__export","BN","DECIMAL_UNITS","DEFAULT_MIN_PRECISION","DEFAULT_PRECISION","bn","format","formatUnits","max","multiply","toBytes","toFixed","toHex","toNumber","__toCommonJS","import_bn","DEFAULT_PRECISION","DEFAULT_MIN_PRECISION","DECIMAL_UNITS","toFixed","value","options","precision","minPrecision","valueUnits","valueDecimals","groupRegex","units","decimals","trimmedDecimal","lastNonZeroIndex","keepChars","decimalPortion","BN","BnJs","value","base","endian","defaultValue","length","output","bytesPadding","bytesLength","options","units","precision","minPrecision","formattedUnits","formattedFixed","toFixed","originalDecimals","firstNonZero","valueUnits","valueDecimals","defaultDecimals","v","width","methodName","num","out","p","a","b","gcd","mode","positive","div","mod","bn","valueToParse","decimals","amount","toNumber","value","bn","toHex","bytesPadding","toBytes","formatUnits","units","format","options","max","numbers","prev","cur","bn","multiply","a","b"]}